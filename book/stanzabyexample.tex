

\title{Stanza by Example}
\author{Patrick S. Li}
\documentclass[10pt,oneside]{book}
\usepackage{color}
\usepackage{hyperref}
\usepackage{parskip}
%\setlength{\parskip}{0.2em}
\usepackage[letterpaper, margin=1in]{geometry}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\usepackage{listings}
\lstdefinestyle{mycode}{
  basicstyle=\footnotesize\ttfamily,
  backgroundcolor=\color{lightgray}
}
\lstset{style=mycode}
\begin{document}
\raggedright
\maketitle


{\em Stanza by Example} is an introductory book for teaching readers how to program in the L.B. Stanza programming language. Readers are assumed to have basic programming experience, at about the level required to implement and understand a basic sorting algorithm. This book is not a reference book, and is meant to be read in order from front to back. The material is written expecting readers to follow along with the coding examples and to the suggested exercises. By following the book, readers will gain a thorough understanding of Stanza's fundamental mechanisms and coding style. 

For absolute beginners to programming, the pace of the first chapter will feel a bit fast, and readers are encouraged to take their time to understand and {\em experiment} with the examples. When I was young, I taught myself to program by reading {\em Beginning Java 2} by Ivor Horton, and one of the goals of this book is to help beginners get started with programming in the same way that Mr. Horton's book has helped me. Once you get the hang of it, programming is an extremely creative and satisfying endeavor. 

I hope you enjoy the book, and Stanza. 

  -Patrick
\tableofcontents
\chapter{Getting Started}
This chapter explains how to download and install Stanza for your system, compile the example programs, and also write your own very first Stanza program.

\section{Get Stanza}
\subsection*{Download Stanza}
Navigate to \texttt{\frenchspacing www.lbstanza.org}, go to the Downloads section of the webpage, and download the zip file containing the Stanza compiler for your platform. Unzip the file contents to a folder called \texttt{\frenchspacing mystanza}. This is the directory where Stanza will be installed.

The main Stanza compiler should be located at
\begin{lstlisting}
mystanza/stanza
\end{lstlisting}

and the core and collections libraries should be located at
\begin{lstlisting}
mystanza/core/core.stanza
mystanza/core/collections.stanza
\end{lstlisting}

\subsection*{Installing on Linux and OS-X}
If you're on a linux platform, open the terminal and type
\begin{lstlisting}
cd mystanza
./stanza install -platform linux
\end{lstlisting}

If you're on Mac OS-X, then type instead
\begin{lstlisting}
cd mystanza
./stanza install -platform os-x
\end{lstlisting}

This creates a \texttt{\frenchspacing .stanza} file in your home directory that contains the installation directory for Stanza.

\subsection*{Put Stanza in your Path}
Type the following if you want to be able to call Stanza from any working directory.
\begin{lstlisting}
sudo ln stanza /usr/local/bin/stanza
\end{lstlisting}

\subsection*{Installing on Windows}
Open \texttt{\frenchspacing cmd.exe} and type
\begin{lstlisting}
cd mystanza
stanza install -platform windows -path .
\end{lstlisting}

This creates a \texttt{\frenchspacing .stanza} file in the \texttt{\frenchspacing mystanza} directory. Stanza will print out a message telling you to set the \texttt{\frenchspacing STANZA\_CONFIG} environment variable to the installation directory. Additionally, add the \texttt{\frenchspacing mystanza} directory to the \texttt{\frenchspacing PATH} environment variable to be able to run stanza from any directory.

Running Stanza on windows additionally requires the MinGW-w64 port of the gcc compiler. Download the \texttt{\frenchspacing mingw-w64-install.exe} installer from \href{https://sourceforge.net/projects/mingw-w64/}{https://sourceforge.net/projects/mingw-w64/} and run it. By default, it is installed in \texttt{\frenchspacing C:\textbackslash Program Files\textbackslash mingw-w64}. Add the MinGW-w64 \texttt{\frenchspacing bin} directory to the \texttt{\frenchspacing PATH} environment variable.

At the time of writing, the \texttt{\frenchspacing bin} directory corresponding to our MinGW-w64 installation was located at
\begin{lstlisting}
C:\Program Files\mingw-w64\x86_64-5.3.0-posix-seh-rt_v4-rev0\mingw64\bin
\end{lstlisting}

\subsection*{Test}
Type the following in the terminal
\begin{lstlisting}
stanza version
\end{lstlisting}
It should print out the version of the Stanza compiler that you downloaded. If you don't see this, then double check that
\begin{enumerate}
\item you downloaded Stanza for the right platform.
\item you installed Stanza with the correct \texttt{\frenchspacing -platform} flag.
\item you put Stanza on your path.
\end{enumerate}

\subsection*{Compile an Example}
Type the following in the terminal
\begin{lstlisting}
cd mystanza
stanza examples/helloworld.stanza -o helloworld
\end{lstlisting}
This should compile the \texttt{\frenchspacing helloworld} example that comes with Stanza and generate an executable called \texttt{\frenchspacing helloworld}. If this does not work, then double check that
\begin{enumerate}
\item you are in the \texttt{\frenchspacing mystanza} folder.
\item you installed Stanza with the correct \texttt{\frenchspacing -platform} flag.
\item you have the Gnu C compiler installed and can call it by typing \texttt{\frenchspacing cc} (or \texttt{\frenchspacing gcc} for Windows) in the terminal.
\end{enumerate}

\subsection*{Run the Example}
Type the following to run the compiled executable. It should print out "hello world".
\begin{lstlisting}
./helloworld
\end{lstlisting}

If you're running Windows, then type either
\begin{lstlisting}
helloworld
\end{lstlisting}
or
\begin{lstlisting}
helloworld.exe
\end{lstlisting}

Congratulations! You've successfully installed Stanza! Now try compiling and running the other examples in the \texttt{\frenchspacing examples} directory.

\section{Write a Program}
\subsection*{Basic Skeleton}
Create a folder called \texttt{\frenchspacing stanzaprojects} and create a file called \texttt{\frenchspacing hello.stanza} containing
\begin{lstlisting}
defpackage mypackage :
   import core
   
defn main () :
   println("Timon")
   println("and")
   println("Pumbaa")

main()
\end{lstlisting}
Make sure you don't forget the space between the \texttt{\frenchspacing main} and the \texttt{\frenchspacing ()}! We will explain later why this is important. Compile and run it by typing
\begin{lstlisting}
stanza hello.stanza -o hello
./hello
\end{lstlisting}

It should print out
\begin{lstlisting}
Timon
and
Pumbaa
\end{lstlisting}

\subsection*{More println Statements}
Surround the call to \texttt{\frenchspacing main} with the following print statements
\begin{lstlisting}
println("Simba")
main()
println("and Nala")
\end{lstlisting}

Run the program again and it should print out
\begin{lstlisting}
Simba
Timon
and
Pumbaa
and Nala
\end{lstlisting}

The program runs in the order that it sees the top-level statements.

\subsection*{Delete the Call to main}
Delete the call to \texttt{\frenchspacing main} entirely.
\begin{lstlisting}
println("Simba")
println("and Nala")
\end{lstlisting}

Now the program prints out
\begin{lstlisting}
Simba
and Nala
\end{lstlisting}

If you don't call \texttt{\frenchspacing main} then it never runs.

\subsection*{Rename main}
Rename the \texttt{\frenchspacing main} function to \texttt{\frenchspacing hakuna}. 
\begin{lstlisting}
defpackage mypackage :
   import core
   
defn hakuna () :
   println("Timon")
   println("and")
   println("Pumbaa")

hakuna()
\end{lstlisting}

The program still prints out
\begin{lstlisting}
Timon
and
Pumbaa
\end{lstlisting}

There is nothing special about the \texttt{\frenchspacing main} function. Name it whatever you like.

\chapter{The Very Basics}
This chapter introduces the basic programming constructs in Stanza. After this chapter, you'll be able to write basic programs that do simple things.

\section{Project Framework}
Follow these steps to set up a project framework.

\subsection*{Create basics.stanza}
In your \texttt{\frenchspacing stanzaprojects} directory, create a file called \texttt{\frenchspacing basics.stanza} containing
\begin{lstlisting}
defpackage mypackage :
   import core

defn main () :
   println("Code goes here")

main()
\end{lstlisting}
Again, make sure you do not forget the space between the \texttt{\frenchspacing main} and the \texttt{\frenchspacing ()}. We'll explain why this is necessary when we discuss Stanza's lexical structure.

\subsection*{Compile and Run}
Compile and run the basic framework by typing the following in the terminal
\begin{lstlisting}
stanza basics.stanza -o basics
./basics
\end{lstlisting}

The basic framework should print out
\begin{lstlisting}
Code goes here
\end{lstlisting}

Follow the chapter and try out the examples by replacing the \texttt{\frenchspacing println} command with the example code.

\subsection*{Indentation}
Try changing the basic framework to
\begin{lstlisting}
defpackage mypackage :
import core

defn main () :
   println("Code goes here")

main()
\end{lstlisting}
and try to compile it. It won't work. My Stanza installation says
\begin{lstlisting}
Syntax Error: Import clause expected here.
\end{lstlisting}

Indentation is important in Stanza programs. Be careful when trying out the examples. 

And don't use tabs. Stanza won't let you. We don't like tabs.

\section{Printing Simple Messages}
Printing is important. It's the only way to observe what your program is doing.

\subsection*{Strings}
This is a {\em string}. 
\begin{lstlisting}
"Timon and Pumbaa"
\end{lstlisting}
It's a bunch of characters surrounded in double quotes.

\subsection*{Printing Strings}
Use the \texttt{\frenchspacing println} function to print strings.
\begin{lstlisting}
println("Timon")
println("and")
println("Pumbaa")
\end{lstlisting}
prints out
\begin{lstlisting}
Timon
and
Pumbaa
\end{lstlisting}

\subsection*{Print Without a New Line}
Use the \texttt{\frenchspacing print} function to print strings without starting a new line at the end.
\begin{lstlisting}
print("Timon")
print(" and")
print(" Pumbaa")
\end{lstlisting}
prints out
\begin{lstlisting}
Timon and Pumbaa
\end{lstlisting}

\subsection*{Ints}
This is an {\em integer}.
\begin{lstlisting}
42
\end{lstlisting}
It's a bunch of digits, and represents the integers that you were taught in school.

\subsection*{Printing Integers}
The \texttt{\frenchspacing print} and \texttt{\frenchspacing println} function works on integers too.
\begin{lstlisting}
print(1)
print(" and a ")
print(2)
print(" and a ")
println(1)
println(2)
println(3)
println(4)
\end{lstlisting}
prints out
\begin{lstlisting}
1 and a 2 and a 1
2
3
4
\end{lstlisting}

Actually \texttt{\frenchspacing print} and \texttt{\frenchspacing println} works on a lot of things. We'll learn about that later.

\subsection*{Printing Multiple Things}
Calling \texttt{\frenchspacing println} repeatedly to print multiple things is tedious. Use \texttt{\frenchspacing println-all} to print out multiple things.
\begin{lstlisting}
println-all([1 " and a " 2 " and a "])
println-all([1 2 3 4 "."])
\end{lstlisting}
prints out
\begin{lstlisting}
1 and a 2 and a 
1234.
\end{lstlisting}

If you don't want to start a new line at the end, use \texttt{\frenchspacing print-all} instead.
\begin{lstlisting}
print-all([1 " and a " 2 " and a "])
println-all([1 2 3 4 "."])
\end{lstlisting}
prints out
\begin{lstlisting}
1 and a 2 and a 1234.
\end{lstlisting}

Don't fret about the \texttt{\frenchspacing []} brackets for now. They create {\em tuples}. We'll learn about those later.

\subsection*{Formatted Printing}
Sometimes it's tedious to print multiple things even with \texttt{\frenchspacing println-all}. Here's how to print things according to a {\em format string}.
\begin{lstlisting}
println("%_ and a %_ and a %_, %_, %_, %_!" % [1 2 1 2 3 4])
\end{lstlisting}
prints out
\begin{lstlisting}
1 and a 2 and a 1, 2, 3, 4!
\end{lstlisting}

Notice that you're calling the same \texttt{\frenchspacing println} function that you've already learned. The \texttt{\frenchspacing \%} operator is what's doing all the work. We'll learn other operators later.

\subsection*{Where's the Commas?}
Some of you may have noticed the lack of commas in the examples. Try adding them back in.
\begin{lstlisting}
println("%_ and a %_ and a %_, %_, %_, %_!" % [1, 2, 1, 2, 3, 4])
\end{lstlisting}
still prints out
\begin{lstlisting}
1 and a 2 and a 1, 2, 3, 4!
\end{lstlisting}

Commas are treated identically to spaces in Stanza. (Unless they are part of a string.) Try going crazy!
\begin{lstlisting}
println("%_ and a %_ and a %_, %_, %_, %_!" % [1 2,1,2,,,,3,,,,,4])
\end{lstlisting}
The above still prints out what it used to. But don't do that. That was just an example.

\section{Lexical Structure}
Before compilation, a Stanza program is {\em lexed} into individual identifiers, numbers, and lists. Here are the rules that you'll need to know.

\subsection*{Lexemes}
The first thing that Stanza does is break down a program into a sequence of {\em lexemes}, where each lexeme is separated by either whitespace or one of the following characters.
\begin{lstlisting}
, . : & | < > [ ] { } ( )
\end{lstlisting}

\subsection*{Numbers}
A number is a lexeme that begins with a digit, or a hyphen followed by a digit. Here are some examples.
\begin{lstlisting}
3
50
-13
100L
\end{lstlisting}

\subsection*{Operators}
An operator is any lexeme that is made up of the following characters.
\begin{lstlisting}
~ ! @ # $ % ^ * + - = / . : & | < >
\end{lstlisting}
Here are some example operators.
\begin{lstlisting}
+
*
&
&&
+=
>>>
<+>
::=
<^.^>
\end{lstlisting}

\subsection*{Identifiers}
An identifier is any lexeme that is not a number or operator. Here are some examples.
\begin{lstlisting}
x
timon
timon_and_pumbaa
timon-and-pumbaa
#timon
$timon
timon?
x+one
x1
x+1-3
\end{lstlisting}

\subsection*{Opening Brackets}
Syntactically, an identifier followed {\em immediately} by a opening bracket character is treated {\em differently} than if the two were separated by spaces. For example
\begin{lstlisting}
f(x)
\end{lstlisting}
is syntactically different than
\begin{lstlisting}
f (x)
\end{lstlisting}
The former calls the function \texttt{\frenchspacing f} with \texttt{\frenchspacing x}. The latter is simply the function \texttt{\frenchspacing f} followed by the value \texttt{\frenchspacing x}.

This is similar to how
\begin{lstlisting}
ab
\end{lstlisting}
is syntactically different than
\begin{lstlisting}
a b
\end{lstlisting}
The two mean different things. Please keep this in mind when following the examples in this book. For example, this is why it was stressed to you to remember the space after \texttt{\frenchspacing main} in
\begin{lstlisting}
defn main () :
   ...
\end{lstlisting}

Additionally, 
\begin{lstlisting}
f[x]
\end{lstlisting}
is syntactically different than
\begin{lstlisting}
f [x]
\end{lstlisting}
and
\begin{lstlisting}
f{x}
\end{lstlisting}
is syntactically different than
\begin{lstlisting}
f {x}
\end{lstlisting}
and
\begin{lstlisting}
f<x>
\end{lstlisting}
is syntactically different than
\begin{lstlisting}
f <x>
\end{lstlisting}



\section{Comments}
Comments begin with the \texttt{\frenchspacing ;} character, and every following character in the line will be regarded as a comment and won't affect the behaviour of the code. Here's an example of using comments.
\begin{lstlisting}
;My favorite characters
println("Timon")  ;The small one
println("and")
println("Pumbaa") ;and the smart one
\end{lstlisting}
Code without comments is very difficult to understand. Use comments often.

\section{Operators}
\subsection*{Basic Arithmetic}
To add two numbers together, use the \texttt{\frenchspacing +} operator. 
\begin{lstlisting}
println(10 + 32)
\end{lstlisting}
prints out
\begin{lstlisting}
42
\end{lstlisting}

That means the result of adding \texttt{\frenchspacing 32} to \texttt{\frenchspacing 10} is \texttt{\frenchspacing 42}. We say that the expression \texttt{\frenchspacing 10 + 32} {\em returns} \texttt{\frenchspacing 42}. We'll learn later why we use the word {\em returns}. 

Here are examples of using the other arithmetic operators.
\begin{lstlisting}
68 + 32 ;Addition
68 - 32 ;Subtraction
68 * 32 ;Multiplication
68 / 32 ;Division
68 % 32 ;Modulus
\end{lstlisting}

\subsection*{Bitwise Arithmetic}

Here are examples of using the bitwise operators.
\begin{lstlisting}
24 << 2 ;Left Bit Shift
24 >> 2 ;Right Bit Shift
24 >>> 2 ;Arithmetic Right Bit Shift
24 & 2 ;Bitwise And
24 | 2 ;Bitwise Or
24 ^ 2 ;Bitwise Xor
\end{lstlisting}

\subsection*{Operator Precedence}

All the operators are {\em left associative}. This means that in the following expression
\begin{lstlisting}
1 + 2 - 3 + 4 - 5 + 6
\end{lstlisting}
the operators are applied left to right. The above is equivalent to
\begin{lstlisting}
((((1 + 2) - 3) + 4) - 5) + 6
\end{lstlisting}

In expressions containing a mix of operators, the operators with highest precedence are grouped together first, followed by the operators with second highest precedence, until you reach the operators with lowest precedence. The shift operators (\texttt{\frenchspacing <<}, \texttt{\frenchspacing >>}, \texttt{\frenchspacing >>>}) have precedence 3. The multiply, divide, modulo, bitwise and, and bitwise xor operators (\texttt{\frenchspacing *}, \texttt{\frenchspacing /}, \texttt{\frenchspacing \%}, \texttt{\frenchspacing \&}, \texttt{\frenchspacing \^}) have precedence 2. Addition, subtraction, and bitwise or, (\texttt{\frenchspacing +}, \texttt{\frenchspacing -}, \texttt{\frenchspacing |}), have precedence 1.

The following expression
\begin{lstlisting}
3 + 2 << 2 * 3 + 3 << 1
\end{lstlisting}
first groups the precedence 3 operators
\begin{lstlisting}
3 + (2 << 2) * 3 + (3 << 1)
\end{lstlisting}
followed by the precedence 2 operators
\begin{lstlisting}
3 + ((2 << 2) * 3) + (3 << 1)
\end{lstlisting}
followed by the precedence 1 operators
\begin{lstlisting}
(3 + ((2 << 2) * 3)) + (3 << 1)
\end{lstlisting}

\subsection*{Unary Operators}
Here's how to negate a number.
\begin{lstlisting}
(- 3)
\end{lstlisting}
The parentheses are not optional! 

Here's how to flip all the bits in a number.
\begin{lstlisting}
(~ 3)
\end{lstlisting}
Again, the parentheses are not optional! This is different than most other languages. There's a good reason for this. But don't forget them!  

\section{Values}
\subsection*{Syntax}
The statement
\begin{lstlisting}
val a:Int = 3 * 71
\end{lstlisting}
calculates the result of \texttt{\frenchspacing 3 * 71} and {\em stores} the result in the {\em value} \texttt{\frenchspacing a}. 

After the storing the result in \texttt{\frenchspacing a}, you can then use that value afterwards by name.
\begin{lstlisting}
println(a)
\end{lstlisting}

You cannot change what is stored in a value once it is initialized. 

\subsection*{Breaking up Complicated Expressions}

You can use values to break up complicated expressions into smaller ones.
\begin{lstlisting}
println(1 + 30 * 2 * 3 - 30 / (3 << 1))
\end{lstlisting}
can be rewritten as
\begin{lstlisting}
val a:Int = 30 * 2 * 3
val b:Int = 30 / (3 << 1)
println(1 + a - b)
\end{lstlisting}

\subsection*{Types}
The \texttt{\frenchspacing Int} in the previous example is called a {\em type annotation}. It says that only an {\em integer} can be stored in \texttt{\frenchspacing a}. 

Stanza won't let you store anything else into \texttt{\frenchspacing a}. We can try to store a string
\begin{lstlisting}
val a:Int = "Timon"
\end{lstlisting}
but attempting to compile it gives us this error.
\begin{lstlisting}
Cannot assign expression of type String to value a with declared type Int.
\end{lstlisting}

If you want to store a string into \texttt{\frenchspacing a}, then you have to declare it like this.
\begin{lstlisting}
val a:String = "Timon"
\end{lstlisting}

Later, we will learn more about types and about types other than \texttt{\frenchspacing Int} and \texttt{\frenchspacing String}. 

\subsection*{Type Inference}
If you leave off the type annotation
\begin{lstlisting}
val a = 3 * 71
\end{lstlisting}
then Stanza figures out the type based on the expression it's initialized with.

Most Stanza programmers leave off type declarations for values.

\section{Variables}

A variable is declared like a value, but using \texttt{\frenchspacing var} instead of \texttt{\frenchspacing val}.
\begin{lstlisting}
var a:Int = 10 + 30
\end{lstlisting}

Just like a value, the result of calculating \texttt{\frenchspacing 10 + 30} is stored in the variable \texttt{\frenchspacing a}. 

And just like a value, you can refer to it by name afterwards.
\begin{lstlisting}
println(a)
\end{lstlisting}

The difference is that, even after it is initialized, you can still store something {\em else} into a variable. 
\begin{lstlisting}
var a:Int = 3 * 71
println(a)
a = -10
println(a)
\end{lstlisting}
prints out
\begin{lstlisting}
213
-10
\end{lstlisting}

After we print out \texttt{\frenchspacing a} for the first time, we use the \texttt{\frenchspacing =} operator to store \texttt{\frenchspacing -10} into \texttt{\frenchspacing a}. The second time we print out \texttt{\frenchspacing a}, it prints out \texttt{\frenchspacing -10}.

\subsection*{Types}
Just like values, a variable's type annotation restricts what you can store inside it. Here's what happens when we attempt to store a string into \texttt{\frenchspacing a}.
\begin{lstlisting}
var a:Int = 3 * 71
a = "Timon"
\end{lstlisting}
Compiling the above gives us
\begin{lstlisting}
Cannot assign expression of type String to variable a with declared type Int.
\end{lstlisting}

\subsection*{Type Inference}
Just like values, you can leave off the type annotation for a variable.
\begin{lstlisting}
var a = 3 * 71
println(a)
a = -10
println(a)
\end{lstlisting}

{\em However}, the inferred type for a variable depends upon {\em all} the values assigned to it, not just the initial one. 

For various reasons, Stanza cannot always infer the type of a variable, as in this example. (Don't mind the functions you don't know. We'll learn them later.) 
\begin{lstlisting}
var a = 3 * 71
a = cons(a, List())
\end{lstlisting}
Attempting to compile the above gives us this error.
\begin{lstlisting}
Could not infer type of variable a.
\end{lstlisting}

In these cases, you'll have to provide an explicit type annotation for the variable.

\subsection*{Uninitialized Variables}
Variables don't have to be declared with an initial value. Here's a variable, declared to only hold integers, but with no initial value.
\begin{lstlisting}
var x:Int
\end{lstlisting}

Attempting to read from an uninitialized variable will crash the program. The following program
\begin{lstlisting}
var x:Int
println(x)
\end{lstlisting}
when compiled and ran crashes with this error.
\begin{lstlisting}
FATAL ERROR: Variable is uninitialized.
\end{lstlisting}

\section{Functions}

Here's a function that subtracts forty two from its argument.
\begin{lstlisting}
defn subtract-forty-two (x:Int) -> Int :
   x - 42   
\end{lstlisting}

And here's how you {\em call} the function.
\begin{lstlisting}
subtract-forty-two(43)
\end{lstlisting}

Here's the complete program.
\begin{lstlisting}
defpackage mypackage :
   import core

defn subtract-forty-two (x:Int) -> Int :
   x - 42   

println(subtract-forty-two(43))
\end{lstlisting}
It prints out:
\begin{lstlisting}
1
\end{lstlisting}

This means that the result of calling \texttt{\frenchspacing subtract-forty-two} with \texttt{\frenchspacing 43} is \texttt{\frenchspacing 1}. We say that \texttt{\frenchspacing subtract-forty-two(43)} {\em returned} \texttt{\frenchspacing 1}. 

\subsection*{Return Value}
Here's a silly change we can make to \texttt{\frenchspacing subtract-forty-two}. 
\begin{lstlisting}
defn subtract-forty-two (x:Int) -> Int :
   x + 43
   x - 42   
\end{lstlisting}
\texttt{\frenchspacing subtract-forty-two(43)} still returns \texttt{\frenchspacing 1} though. The result of the last expression in a function's body is the value returned by the function. 

\subsection*{Side Effects}
Here's another change we can make to \texttt{\frenchspacing subtract-forty-two}.
\begin{lstlisting}
defn subtract-forty-two (x:Int) -> Int :
   println("Subtracting 42 from %_." % [x])
   x - 42   
\end{lstlisting}

Now the following code
\begin{lstlisting}
println(subtract-forty-two(43))
\end{lstlisting}
prints
\begin{lstlisting}
Subtracting 42 from 43.
1
\end{lstlisting}

The expressions in a function body are evaluated one at a time, but only the result of the last one is returned.

\subsection*{Return Type}
The \texttt{\frenchspacing Int} following the \texttt{\frenchspacing ->} in \texttt{\frenchspacing subtract-forty-two} is the function's {\em return type}. It says that the function must return an integer. 

Stanza won't let you return anything else. If we try to return a string
\begin{lstlisting}
defn subtract-forty-two (x:Int) -> Int :
   println("Subtracting 42 from %_." % [x])
   "Timon"
\end{lstlisting}
then the Stanza compiler gives us this error.
\begin{lstlisting}
Cannot return an expression of type String for function 
subtract-forty-two with declared return type Int.
\end{lstlisting}

You can leave off the return type annotation
\begin{lstlisting}
defn subtract-forty-two (x:Int) :
   println("Subtracting 42 from %_." % [x])
   x - 42   
\end{lstlisting}
in which case, Stanza will figure out the return type automatically based on the last expression in the function body. In certain cases, Stanza will not be able to figure it out and you'll have to provide it explicitly.

\subsection*{Argument Types}
The \texttt{\frenchspacing :Int} following the \texttt{\frenchspacing x} argument in \texttt{\frenchspacing subtract-forty-two} is the type annotation for the argument. This type annotation does two things. The first is that it restricts what values you can call \texttt{\frenchspacing subtract-forty-two} with. Compiling the following code
\begin{lstlisting}
subtract-forty-two("Hello")
\end{lstlisting}
gives the error
\begin{lstlisting}
Cannot call function subtract-forty-two of type Int -> Int
with arguments of type (String).
\end{lstlisting}

The second is that it restricts what you are allowed to do with \texttt{\frenchspacing x}. Here is what happens if we try to use \texttt{\frenchspacing x} as if it were a format string.
\begin{lstlisting}
defn subtract-forty-two (x:Int) :
   println(x % [1, 2, 3])
   x - 42   
\end{lstlisting}
Compiling it gives us this error.
\begin{lstlisting}
No appropriate function modulo for arguments of type 
(Int, [Int, Int, Int]). Possibilities are:
   modulo: (String, Seqable) -> Printable at core/core.stanza:1982.12
   modulo: (Byte, Byte) -> Byte at core/core.stanza:2444.21
   modulo: (Int, Int) -> Int at core/core.stanza:2575.12
   modulo: (Long, Long) -> Long at core/core.stanza:2644.21
\end{lstlisting}

Roughly, that error message tells us that there are four different functions called {\em modulo}, and none of them can called with \texttt{\frenchspacing x} and \texttt{\frenchspacing [1, 2, 3]}. We'll learn later how to interpret that error message more precisely.

\subsection*{Example: String Arguments}
Here is an example of a function that accepts a string as an argument.
\begin{lstlisting}
defn timon-and-pumbaa-says (format:String) :
   println(format % ["Timon", "Pumbaa"])

timon-and-pumbaa-says(
   "%_ says they're fireflies, while %_ says they're big balls of gas.")
   
timon-and-pumbaa-says(
   "When the world turns their back on %_, %_ turns their back on the world.")
\end{lstlisting}
Compiling and running the above prints
\begin{lstlisting}
Timon says they're fireflies, while Pumbaa says they're big balls of gas.
When the world turns their back on Timon, Pumbaa turns their back on the world.
\end{lstlisting}

We did not provide an explicit return type for \texttt{\frenchspacing timon-and-pumbaa-says}. Thus Stanza figures it out automatically from the result of the last expression, the \texttt{\frenchspacing println}. It turns out that \texttt{\frenchspacing println} returns the value \texttt{\frenchspacing false} which has type \texttt{\frenchspacing False}. We could explicitly provide the return type as well.
\begin{lstlisting}
defn timon-and-pumbaa-says (format:String) -> False :
   println(format % ["Timon", "Pumbaa"])
\end{lstlisting}

\subsection*{Leaving off the Argument Type}
{\em Beware}. Argument types are {\em not} inferred automatically. You can leave off the argument types
\begin{lstlisting}
defn subtract-forty-two (x) :
   x - 42   
\end{lstlisting}
but this is {\em not} equivalent to declaring \texttt{\frenchspacing x} as an \texttt{\frenchspacing Int}.

If you leave off the type annotation for an argument, it means that the argument can be {\em anything}. You can call the function with whatever you want, and within the body of the function Stanza will let you do whatever you wish with the argument. If you do something wrong then the program will crash when ran.

Here is an {\em incorrect} program that compiles correctly.
\begin{lstlisting}
defn subtract-forty-two (x) :
   println(x % ["Timon", "Pumbaa"])
   x - 42

subtract-forty-two("%_ and %_ say Hakuna Matata!")
\end{lstlisting}
But when the program is ran, it crashes with this error.
\begin{lstlisting}
Timon and Pumbaa say Hakuna Matata!
FATAL ERROR: Cannot cast value to type.
   at core/core.stanza:2566.12
   at stanzaprojects/basics.stanza:6.3
   at stanzaprojects/basics.stanza:8.0
\end{lstlisting}

The error message is saying that in the expression \texttt{\frenchspacing x - 42} it could not convert \texttt{\frenchspacing x} into the appropriate type needed by the \texttt{\frenchspacing -} operator (\texttt{\frenchspacing Int}). 

\subsection*{The Unknown Type}
More precisely, leaving off the type annotation for an argument is equivalent to declaring the argument with the \texttt{\frenchspacing ?} type. So the above program can be written equivalently as
\begin{lstlisting}
defn subtract-forty-two (x:?) :
   println(x % ["Timon", "Pumbaa"])
   x - 42

subtract-forty-two("%_ and %_ say Hakuna Matata!")
\end{lstlisting}

The \texttt{\frenchspacing ?} type is very special and forms the foundation of Stanza's optional type system. You can pass {\em any} value to a location where a \texttt{\frenchspacing ?} is expected. {\em And}, you can use a value of \texttt{\frenchspacing ?} type anywhere.

You can use the \texttt{\frenchspacing ?} type in variable and value declarations too. Here is an example of using them with variables.
\begin{lstlisting}
var x:? = "%_ says Hakuna."
println(x % ["Timon"])
x = 10 + 32
println("There are about %_ fireflies in the universe." % [x])
\end{lstlisting}
It prints out
\begin{lstlisting}
Timon says Hakuna.
There are about 42 fireflies in the universe.
\end{lstlisting}

Notice that we're using \texttt{\frenchspacing x} as a format string in one case, and a number in the other case. The \texttt{\frenchspacing ?} type allows us to do this.

\section{Comparisons}

\subsection*{Comparison Operators}
To test whether one integer is smaller than another number, you can use the \texttt{\frenchspacing <} operator. Here's an example.
\begin{lstlisting}
println(10 < 32)
\end{lstlisting}
It prints out
\begin{lstlisting}
true
\end{lstlisting}
This means that \texttt{\frenchspacing 10} is less than \texttt{\frenchspacing 32}. The expression \texttt{\frenchspacing 10 < 32} returned the value \texttt{\frenchspacing true}. Conversely, 

\begin{lstlisting}
println(10 > 32)
\end{lstlisting}
prints out
\begin{lstlisting}
false
\end{lstlisting}
This means that \texttt{\frenchspacing 10} is not greater than \texttt{\frenchspacing 32}. The expression \texttt{\frenchspacing 10 > 32} returned the value \texttt{\frenchspacing false}. 

Here's all the other comparison operators you can use.
\begin{lstlisting}
10 < 32     ;Less Than
10 <= 32    ;Less Than or Equal to
10 > 32     ;Greater Than
10 >= 32    ;Greater Than or Equal to
10 == 32    ;Equal
10 != 32    ;Not Equal
\end{lstlisting}

\subsection*{Logical Operators}
You can use the \texttt{\frenchspacing not}, \texttt{\frenchspacing and}, and \texttt{\frenchspacing or} operators to combine the results of multiple comparisons. Here is how to test whether \texttt{\frenchspacing 1} is less than \texttt{\frenchspacing 3} {\em and} greater than \texttt{\frenchspacing 5}.
\begin{lstlisting}
println(1 < 3 and 1 > 5)
\end{lstlisting}

Here is how to test whether \texttt{\frenchspacing 1} is less than \texttt{\frenchspacing 3} {\em or} greater than \texttt{\frenchspacing 5}.
\begin{lstlisting}
println(1 < 3 or 1 > 5)
\end{lstlisting}

Here is how to test whether \texttt{\frenchspacing 1} is {\em not} less than \texttt{\frenchspacing 3}.
\begin{lstlisting}
println(not 1 < 3)
\end{lstlisting}

\section{If Expressions}
If expressions let you test whether a value is \texttt{\frenchspacing true} or \texttt{\frenchspacing false} and do different things depending on the result.
\begin{lstlisting}
val x = 10 < 32
if x :
   println("Timon is better!")
else :
   println("Pumbaa is better!")
\end{lstlisting}
prints out
\begin{lstlisting}
Timon is better!
\end{lstlisting}

The result of \texttt{\frenchspacing 10 < 32} (\texttt{\frenchspacing true}) is stored in \texttt{\frenchspacing x}. Then because \texttt{\frenchspacing x} (the {\em predicate}) is \texttt{\frenchspacing true}, the {\em consequent} branch of the if expression is evaluated instead of the {\em alternate} branch.

Change the \texttt{\frenchspacing <} operator to a \texttt{\frenchspacing >} operator to root for Pumbaa instead.

\subsection*{Result of an If Expression}
If expressions evaluate to a result. The {\em result} of an if expression is the result of the last expression in the consequent branch if the predicate is \texttt{\frenchspacing true}. Otherwise it is the result of the last expression in the alternate branch.

Here's an example of using the result of an if expression.
\begin{lstlisting}
val x =
   if 10 < 32 :
      "Timon"
   else :
      "Pumbaa"
println("%_ is better!" % [x])
\end{lstlisting}
It prints out the same message as the last example.

\subsection*{Default Else Branch}
If you leave off the \texttt{\frenchspacing else} branch in an if expression, then the if expression simply evaluates to \texttt{\frenchspacing false} if the predicate is not \texttt{\frenchspacing true}. In the following code
\begin{lstlisting}
if 10 > 32 :
   println("Timon is better!")
\end{lstlisting}
nothing is ever printed. 

\subsection*{Nested If Expressions}
You can nest if expressions inside other if expressions. The following code prints different messages when x falls in different ranges.
\begin{lstlisting}
val x = 32
if x < 0 :
   println("x is negative!")
else :
   if x < 10 :
      println("x is between 0 and 10")
   else :
      if x < 30 :
         println("x is between 20 and 30")
      else :
         println("x is really big!")
\end{lstlisting}
It uses nested if expressions to test a series of conditions.

Because nested if expressions are so common, you are allowed to omit the colon after the \texttt{\frenchspacing else} keyword if it is followed by an \texttt{\frenchspacing if} expression. The above can be rewritten equivalently as

\begin{lstlisting}
val x = 32
if x < 0 :
   println("x is negative!")
else if x < 10 :
   println("x is between 0 and 10")
else if x < 30 :
   println("x is between 20 and 30")
else :
   println("x is really big!")
\end{lstlisting}

Here's another example. \texttt{\frenchspacing sign} is a function that computes the sign of its argument.
\begin{lstlisting}
defn sign (x:Int) :
   if x < 0 :
      -1
   else if x == 0 :
      0
   else :
      1
\end{lstlisting}

\subsection*{True and False}
The \texttt{\frenchspacing true} and \texttt{\frenchspacing false} values can be created directly simply by referring to them by name. 

The following
\begin{lstlisting}
val worries? = true
if worries? :
   println("Chill out!")
else :
   println("Hakuna Matata!")
\end{lstlisting}
prints out
\begin{lstlisting}
Chill out!
\end{lstlisting}

To print \texttt{\frenchspacing Hakuna Matata!} instead, change the \texttt{\frenchspacing true} to \texttt{\frenchspacing false}. 

The value \texttt{\frenchspacing true} has type \texttt{\frenchspacing True}, and the value \texttt{\frenchspacing false} has type \texttt{\frenchspacing False}. 

\section{Expression Sequences}

Multiple expressions can be grouped together as an {\em expression sequence} by surrounding them with parentheses. 
\begin{lstlisting}
val x = (println("A"), 42)
println(x)
\end{lstlisting}
prints out
\begin{lstlisting}
A
42
\end{lstlisting}

The expressions in an expression sequence are evaluated one at a a time, and the result of the last expression is the result of the expression sequence.

In the above example, the first expression in the sequence, \texttt{\frenchspacing println("A")}, is evaluated, and then the last expression, \texttt{\frenchspacing 42}, is the result of the sequence and is stored in \texttt{\frenchspacing x}. \texttt{\frenchspacing x} is then printed to the screen.

\section{Structure Through Indentation}

Some of you may be concerned about Stanza's use of structure through indentation due to how this system has been implemented in the past. Don't worry. Stanza's indentation structuring mechanism is very simple and {\em predictable}.

The indentation structuring mechanism is governed by a single rule: a line ending colon automatically inserts parentheses around the following indented block.

Thus, after the implicit parentheses have been added, the previous \texttt{\frenchspacing sign} example looks like this.
\begin{lstlisting}
defn sign (x:Int) : (
   if x < 0 : (
      -1)
   else if x == 0 : (
      0)
   else : (
      1))
\end{lstlisting}

A program with no line ending colons can even be written on a single line if desired.
\begin{lstlisting}
defn sign (x:Int) : (if x < 0 : (-1) else if x == 0 : (0) else : (1))
\end{lstlisting}

Here is one more example.
\begin{lstlisting}
defn hakuna () :
   println("Timon")
   println("Pumbaa")
\end{lstlisting}
becomes the following after implicit parentheses are added.
\begin{lstlisting}
defn hakuna () : (
   println("Timon")
   println("Pumbaa"))
\end{lstlisting}

Here is \texttt{\frenchspacing hakuna} written out on a single line.
\begin{lstlisting}
defn hakuna () : (println("Timon") println("Pumbaa"))
\end{lstlisting}

As you may have noticed, the indentation mechanism is simply used as a shorthand for creating expression sequences out of indented blocks.

\section{While Loops}
The following
\begin{lstlisting}
var x = 1
while x < 1000 :
   println("x is %_" % [x])
   x = x * 2
\end{lstlisting}
prints out
\begin{lstlisting}
x is 1
x is 2
x is 4
x is 8
x is 16
x is 32
x is 64
x is 128
x is 256
x is 512
\end{lstlisting}

Here is the general form.
\begin{lstlisting}
while predicate : body   
\end{lstlisting}

A while loop repeatedly evaluates a block of code so long as the predicate expression evaluates to \texttt{\frenchspacing true}. 

Here is the order in which the while loop does things.
\begin{enumerate}
\item Evaluate the predicate.
\item If the predicate evaluates to \texttt{\frenchspacing false}, then the loop is done.
\item Otherwise, evaluate the body and then repeat from step 1. 
\end{enumerate}

\section{For "Loops"}
Stanza's for construct is {\em extremely} powerful. "Loops" is in double quotes because, strictly speaking, the for construct is not a looping mechanism. But it is often used as one, so we'll explain it here as if it were. Later, we'll learn the general form of the for construct.

\subsection*{Counting Loops}
The following
\begin{lstlisting}
for i in 0 to 4 do :
   println("Pumbaa is Better!")
\end{lstlisting}
prints out \texttt{\frenchspacing Pumbaa is Better!} four times. 

The following
\begin{lstlisting}
for i in 0 to 4 do :
   println("i is %_" % [i])
\end{lstlisting}
prints out
\begin{lstlisting}
i is 0
i is 1
i is 2
i is 3
\end{lstlisting}

A counting loop has this general form.
\begin{lstlisting}
for x in start to end do : body
\end{lstlisting}

For each integer between \texttt{\frenchspacing start} (inclusive) and \texttt{\frenchspacing end} (exclusive), the body is evaluated once with \texttt{\frenchspacing x} {\em bound} to that integer. 

\subsection*{Range Expressions}
In the previous example, the expression \texttt{\frenchspacing 0 to 4} creates a \texttt{\frenchspacing Range} object. A \texttt{\frenchspacing Range} object represents a sequence of integers between some starting index and optional ending index.

Here's how to create a \texttt{\frenchspacing Range} object that counts up in steps of 2.
\begin{lstlisting}
0 to 10 by 2
\end{lstlisting}
It represents the numbers \texttt{\frenchspacing 0, 2, 4, 6, 8}.

The following
\begin{lstlisting}
for i in 0 to 10 by 2 do :
   println("i is %_" % [i])
\end{lstlisting}
prints out
\begin{lstlisting}
i is 0
i is 2
i is 4
i is 6
i is 8
\end{lstlisting}

To make the ending index inclusive rather than exclusive, use the \texttt{\frenchspacing through} keyword rather than the \texttt{\frenchspacing to} keyword.
\begin{lstlisting}
0 through 10 by 2
\end{lstlisting}
represents the numbers \texttt{\frenchspacing 0, 2, 4, 6, 8, 10}.

If you use \texttt{\frenchspacing false} for the ending index, then the range represents an {\em infinite} sequence of numbers.
\begin{lstlisting}
0 to false by 3
\end{lstlisting}
represents the numbers \texttt{\frenchspacing 0, 3, 6, 9, ...}. 

\section{Labeled Scopes}

\subsection*{For Returning Early}
As you've learned so far, functions return the result of the last expression in its body. But what if you want to return earlier? 

As an example, here's a function that computes the n'th fibonacci number. 
\begin{lstlisting}
defn fibonacci (n:Int) -> Int :
   var a:Int = 0
   var b:Int = 1
   var i = 0
   while i < n :
      val c = a + b
      a = b
      b = c
      i = i + 1
   b
\end{lstlisting}

Let's use a labeled scope to change \texttt{\frenchspacing fibonacci} to return \texttt{\frenchspacing -1} immediately if the argument \texttt{\frenchspacing n} is negative. 
\begin{lstlisting}
defn fibonacci (n:Int) -> Int :
   label<Int> myreturn :
      if n < 0 : myreturn(-1)
      var a:Int = 0
      var b:Int = 1
      var i = 0
      while i < n :
         val c = a + b
         a = b
         b = c
         i = i + 1
      b
\end{lstlisting}

The first line within the labeled scope
\begin{lstlisting}
if n < 0 : myreturn(-1)
\end{lstlisting}
checks to see whether \texttt{\frenchspacing n} is negative, and if it is, it {\em immediately} returns the value \texttt{\frenchspacing -1} from the function by calling the {\em exit function} \texttt{\frenchspacing myreturn}. 

\subsection*{For Breaking From Loops}
Labeled scopes are also useful for breaking early out of loops.

Here's how the while loop in \texttt{\frenchspacing fibonacci} could have been written.
\begin{lstlisting}
defn fibonacci (n:Int) -> Int :
   var a:Int = 0
   var b:Int = 1
   var i = 0
   label<False> break :
      while true :
         if i == n : break(false)
         val c = a + b
         a = b
         b = c
         i = i + 1
   b
\end{lstlisting}
 
The code above starts an infinite loop, but breaks out of it when \texttt{\frenchspacing i} is equal to \texttt{\frenchspacing n}.

\subsection*{General Form}
The general form of a labeled scope is
\begin{lstlisting}
label<Type> exit :
   body
\end{lstlisting}
\texttt{\frenchspacing Type} is the type of the value returned by the labeled scope and \texttt{\frenchspacing exit} is the name of the exit function. 

You can name the exit function whatever you like. When used to return early from a function, \texttt{\frenchspacing return} is a popular name for the exit function. When used to break early from a loop, \texttt{\frenchspacing break} is a popular name.

The label construct simply executes the given body. If the exit function is never called then the result of the body expression is the result of the label construct. If the exit function is called, then we {\em immediately} stop evaluation of the body, and the argument to the exit function is the result of the label construct.

\subsection*{Well-Typed Labeled Scopes}

The type annotation on the label construct enforces two properties.
\begin{enumerate}
\item The argument to the exit function must be of the specified type. 
\item The result of the body itself must be of the specified type, as that is the value that is returned by the label construct if the exit function is never called.
\end{enumerate}

The first restriction is fairly obvious. If you pass an argument of the wrong type to the exit function
\begin{lstlisting}
defn fibonacci (n:Int) -> Int :
   label<Int> myreturn :
      if n < 0 : myreturn("Timon")
      var a:Int = 0
      var b:Int = 1
      var i = 0
      while i < n :
         val c = a + b
         a = b
         b = c
         i = i + 1
      b
\end{lstlisting}
then Stanza will issue an error.
\begin{lstlisting}
Cannot call function myreturn of type Int -> Void with arguments of type (String).
\end{lstlisting}

The second restriction sometimes arises in more subtle situations. The following function computes the first integer whose square is greater than 1000.
\begin{lstlisting}
defn first-big-square () :
   label<Int> return :
      for i in 0 to false do :
         if i * i > 1000 :
            return(i)   
\end{lstlisting}
But compiling it gives us this error.
\begin{lstlisting}
Cannot return an expression of type False for anonymous function
with declared return type Int.
\end{lstlisting}
This message says that the body of the labeled scope returns \texttt{\frenchspacing False} but it's declared to return \texttt{\frenchspacing Int}. This arises because the for construct with the \texttt{\frenchspacing do} operating function returns \texttt{\frenchspacing false}, but the type annotation on the label construct was \texttt{\frenchspacing Int}.

Since we {\em know} that the \texttt{\frenchspacing return} exit function is guaranteed to be called, we can explicitly handle this case by causing the program to fail if the loop ever finished without calling \texttt{\frenchspacing return}. 
\begin{lstlisting}
defn first-big-square () :
   label<Int> return :
      for i in 0 to false do :
         if i * i > 1000 :
            return(i)
      fatal("Unreachable Statement")      
\end{lstlisting}

\section{Scopes and the Let Expression}
We have now seen a number of expressions that introduce a new {\em scope}: functions, while loops, for loops, if expressions, and labeled scopes. Values and variables defined within a scope are only visible within that scope. For example, in the following code
\begin{lstlisting}
val x = 3
if x < 5 :
   val y = 10
   println(y)
else :
   val z = 12
   println(z)
\end{lstlisting}
\texttt{\frenchspacing y} is in the scope of the consequent branch of the if expression, and it is {\em only} visible from within the consequent branch of the if expression. And \texttt{\frenchspacing z} is only visible from within the alternate branch of the if expression. Referencing \texttt{\frenchspacing y} and \texttt{\frenchspacing z} from outside the scope in which they were declared
\begin{lstlisting}
val x = 3
if x < 5 :
   val y = 10
   println(y)
else :
   val z = 12
   println(z)
   
println(y)
println(z)
\end{lstlisting}
is illegal and would not pass the Stanza compiler. 

Scopes may themselves contain other nested scopes. In the above example, \texttt{\frenchspacing x}'s scope, contains both the scope of the consequent branch, and the scope of the alternate branch of the if statement. At any point in the program, you may only refer to a value or variable defined in a containing scope. The following {\em is} legal.
\begin{lstlisting}
val x = 3
if x < 5 :
   val y = 10
   println(y)
   println(x)
else :
   val z = 12
   println(z)
   println(x)
\end{lstlisting}

If there are multiple values with the same name that are visible, you automatically refer to the one in the nearest scope. Thus the following code prints \texttt{\frenchspacing 11}, not \texttt{\frenchspacing 3}. 
\begin{lstlisting}
val x = 3
if x < 10 :
   val x = 11
   println(x)
\end{lstlisting}
This feature is called {\em shadowing}.

Sometimes it is useful to artificially introduce a new scope, simply because you will define a number of values that you only want visible within the scope. You can do this using the let expression.
\begin{lstlisting}
val x = 3
let :
   val y = 4
   println(y)
\end{lstlisting}
In the above code, the let expression introduces a new scope where \texttt{\frenchspacing y} is defined. After the let expression, \texttt{\frenchspacing y} will no longer be visible. 

\section{Arrays}

Arrays are one of Stanza's most fundamental datastructures. The following
\begin{lstlisting}
val a = Array<Int>(10)
\end{lstlisting}
creates an array of length 10 and gives it the name \texttt{\frenchspacing a}. You can imagine an array to look like a row of boxes, into which you can put and retrieve objects. So \texttt{\frenchspacing a} is a row of ten boxes, each capable of holding an integer.

\subsection*{Putting Things In}
You can put things into the boxes like this.
\begin{lstlisting}
a[0] = 42
a[1] = 13
\end{lstlisting}
The first box is numbered box 0. The next box is numbered box 1. The last box in \texttt{\frenchspacing a} is box 9 because \texttt{\frenchspacing a} has only ten boxes in total. 

\subsection*{Getting Things Out}
You can retrieve the contents of boxes like this.
\begin{lstlisting}
println(a[0])
println(a[1])
\end{lstlisting}
prints out
\begin{lstlisting}
42
13
\end{lstlisting}

\subsection*{Asking For Its Length}
You can call the \texttt{\frenchspacing length} function to ask for the length of an array.
\begin{lstlisting}
val l = length(a)
println("a has %_ boxes." % [l])
\end{lstlisting}
prints out
\begin{lstlisting}
a has 10 boxes.
\end{lstlisting}

The type of \texttt{\frenchspacing a} is \texttt{\frenchspacing Array<Int>} indicating that it is an array for holding integers. An array for holding strings would have type \texttt{\frenchspacing Array<String>}. And an array that can hold anything would have type \texttt{\frenchspacing Array<?>}. 

\subsection*{Arrays and Loops}
Arrays are most powerful when combined with loops. This function
\begin{lstlisting}
defn array-sum (xs:Array<Int>) :
   var sum = 0
   for i in 0 to length(xs) do :
      sum = sum + xs[i]
   sum   
\end{lstlisting}
computes the sum of every integer in an array. Let's use it to compute the sum of 10, 11, 7, and 8. 
\begin{lstlisting}
val a = Array<Int>(4)
a[0] = 10
a[1] = 11
a[2] = 7
a[3] = 8
println(array-sum(a))
\end{lstlisting}
prints out
\begin{lstlisting}
36
\end{lstlisting}

\section{Tuples}
Tuples represent an immutable collection of items. The following creates a two-element type.
\begin{lstlisting}
val t:[Int, String] = [42, "Hello"]
\end{lstlisting}
It contains an \texttt{\frenchspacing Int} and a \texttt{\frenchspacing String}. To extract the elements of a tuple, type
\begin{lstlisting}
val [x, y] = t
\end{lstlisting}
The above code checks that \texttt{\frenchspacing t} is a two-element tuple, and then puts the first element of \texttt{\frenchspacing t} in \texttt{\frenchspacing x} and the second element of \texttt{\frenchspacing t} in \texttt{\frenchspacing y}.

Notice that the type of the expression \texttt{\frenchspacing [42, "Hello"]} is \texttt{\frenchspacing [Int, String]}. That type says its a two-element tuple containing an \texttt{\frenchspacing Int} and a \texttt{\frenchspacing String}. 

\subsection*{Returning Multiple Values}
Tuples are often used to return multiple values from a function. The following function takes an argument, \texttt{\frenchspacing n}, and a distance, \texttt{\frenchspacing d}, and returns both \texttt{\frenchspacing n - d} and \texttt{\frenchspacing n + d}.
\begin{lstlisting}
defn bracket (n:Int, d:Int) :
   [n - d, n + d]
\end{lstlisting}
We can call and receive both return values from \texttt{\frenchspacing bracket} like this.
\begin{lstlisting}
val [lo, hi] = bracket(5, 3)
println("Bracket around %_ and %_" % [lo, hi])
\end{lstlisting}

\section{Basic Types}
At this point, we have seen a couple of different types now. Here is a listing of the other basic types in Stanza.
\begin{lstlisting}
Byte :     e.g. 1Y, 42Y, 255Y
Int :      e.g. 10, 42
Long :     e.g. 10L, 420020020L
Float :    e.g. 1.0f, 42.0f
Double :   e.g. 1.0, 42.0
String :   e.g. "Timon", "Pumbaa"
Char :     e.g. 'a', 'Z'
True :     e.g. true
False :    e.g. false
\end{lstlisting}

As we've said already, the \texttt{\frenchspacing ?} type is special and any value can be passed to a place expecting a \texttt{\frenchspacing ?}.

All of the types listed in the previous table are examples of {\em ground} types. It means that you refer to them simply by their name and they don't take any parameters. With the introduction of arrays, you have now also been introduced to your first {\em parametric} type. 
\begin{lstlisting}
Array<Int> :          Arrays of Ints
Array<String> :       Arrays of Strings
Array<Array<Int>> :   Arrays of Arrays of Ints
Array<?> :            Arrays of anything
\end{lstlisting}

Unlike ground types, parametric types take additional {\em type parameters}. An array needs to know what type of objects it holds, so it has one type parameter for specifying that. 

Note that for parametric types, if you leave off its parameters, then it is equivalent to specifying \texttt{\frenchspacing ?} for all of its type parameters. Thus
\begin{lstlisting}
Array
\end{lstlisting}
is equivalent to
\begin{lstlisting}
Array<?>
\end{lstlisting}

And
\begin{lstlisting}
Array<Array>
\end{lstlisting}
is equivalent to
\begin{lstlisting}
Array<Array<?>>
\end{lstlisting}

Tuple types have their own syntax, and consists of surrounding the types of all of its elements with the \texttt{\frenchspacing []} brackets. Here is a tuple containing an integer and a string.
\begin{lstlisting}
[Int, String]
\end{lstlisting}
Here is a tuple containing an integer, a string, and a tuple of a single integer.
\begin{lstlisting}
[Int, String, [Int]]
\end{lstlisting}

\section{Structs}
For convenience, Stanza provides a simple way to create compound types out of existing types using structs. Here is how to define a new \texttt{\frenchspacing Dog} type with two fields, a name, and a breed.
\begin{lstlisting}
defstruct Dog :
   name: String
   breed: String
\end{lstlisting}

Once \texttt{\frenchspacing Dog} is defined, you can create new \texttt{\frenchspacing Dog} objects by calling the \texttt{\frenchspacing Dog} function.
\begin{lstlisting}
val d1 = Dog("Chance", "Pitbull")
val d2 = Dog("Shadow", "Golden Retriever")
\end{lstlisting}

\subsection*{Getter Functions}
To retrieve the values of the fields it was constructed from, you may call the \texttt{\frenchspacing name} and \texttt{\frenchspacing breed} getter functions.
\begin{lstlisting}
println("%_ is a %_." % [name(d1), breed(d1)])
\end{lstlisting}
prints out
\begin{lstlisting}
Chance is a Pitbull.
\end{lstlisting}

\subsection*{Struct Type}
Additionally, once a struct is defined, you may now also use it as the name of a type. Here is a function that prints out the contents of an array of \texttt{\frenchspacing Dog} objects.
\begin{lstlisting}
defn kennel-contents (dogs:Array<Dog>) :
   println("There are %_ dogs in the kennel." % [length(dogs)])
   for i in 0 to length(dogs) do :
      println("%_ the %_" % [name(dogs[i]), breed(dogs[i])])
\end{lstlisting}
Let's try calling \texttt{\frenchspacing kennel-contents}.
\begin{lstlisting}
val kennel = Array<Dog>(3)
kennel[0] = Dog("Chance", "Pitbull")
kennel[1] = Dog("Shadow", "Golden Retriever")
kennel[2] = Dog("Bud", "Basketball Player")
kennel-contents(kennel)
\end{lstlisting}
prints out
\begin{lstlisting}
There are 3 dogs in the kennel.
Chance the Pitbull
Shadow the Golden Retriever
Bud the Basketball Player
\end{lstlisting}

Structs are just a convenient form for quickly declaring a new type, constructor function, and getter functions. Later we'll learn the general method for creating new types.

\section{Exercises}
\begin{enumerate}
\item Write a function called \texttt{\frenchspacing nearest-pow-2} that takes a single positive integer \texttt{\frenchspacing n} and returns the closest number to \texttt{\frenchspacing n} that can be represented as a power of 2.

\item Write a program that prints out different messages depending on a value called \texttt{\frenchspacing temperature}. If \texttt{\frenchspacing temperature} is below 20, then print \texttt{\frenchspacing Too Cold!}. If it is between 20 and 40 then print \texttt{\frenchspacing Getting There!}, and print \texttt{\frenchspacing Pumbaa Approves!} if it is over 40. 

\item Use a for loop and a variable to compute the sum of all the integers between 100 (inclusive) to 500 (also inclusive). 

\item Use a labeled scope and for loops to compute the minimum number, n, for which the sum of the integers between 0 and n (inclusive) is above 10000. 

\item Use a while loop and variables to calculate the great common divisor of two variables, \texttt{\frenchspacing x} and \texttt{\frenchspacing y}. The Euclidean algorithm is the simplest one to use. Look online for a description about how the algorithm works.

\item Write a function to print out the following pattern of stars. Allow the width and height of the rectangle to be indicated by the arguments \texttt{\frenchspacing width} and \texttt{\frenchspacing height} respectively.
\begin{lstlisting}
*************
*           *
*           *
*           *
*           *
*           *
*           *
*************
\end{lstlisting}

\item Write a program to print out the following pattern of stars. Allow the height of the triangle to be indicated by an argument named \texttt{\frenchspacing height}.
\begin{lstlisting}
        *                              
       ***                             
      *****                            
     *******                           
    *********                          
   ***********                         
  *************                        
 ***************                       
*****************                     
\end{lstlisting}

\item For the following code, predict what will be printed out and then test your prediction.
\begin{lstlisting}
val x = 42
println(x)
let :
   println(x)
   val x = "Hi"
   println(x)
   let :
      val x = 42
      println(x)
   let :
      val x = "There"
      println(x)
println(x)
let :
   val x = x + 1
   println(x)
println(x)
\end{lstlisting}

\item For the following code, write it out completely on a single line, grouping expressions with parentheses where necessary. Run both versions and ensure that they behave identically.
\begin{lstlisting}
val x = (42 10)
for i in 0 to 10 do :
   println(x)
      println("B")
println("C")
for i in 0 to 10 do : println("D")
   println("E")
\end{lstlisting}
\end{enumerate}

\chapter{The Less Basic}

\section{More about Structs}
\subsection*{Mutable Fields}
In the last chapter, you were taught how to define structs and create objects. But the structs you created were {\em immutable}. You couldn't change the objects at all after you created them. 

Here was our original definition of \texttt{\frenchspacing Dog}. 
\begin{lstlisting}
defstruct Dog :
   name: String
   breed: String
\end{lstlisting}

We can create a dog by calling the \texttt{\frenchspacing Dog} function with a provided name and breed. But once created, you cannot change a dog's name or breed. Here's how to define \texttt{\frenchspacing Dog} with a {\em setter function} for changing its name.
\begin{lstlisting}
defstruct Dog :
   name: String with: (setter => set-name)
   breed: String
\end{lstlisting}
Now we can use the \texttt{\frenchspacing set-name} function to change a dog's name.
\begin{lstlisting}
val d = Dog("Shadow", "Golden Retriever")
println("I used to be called %_." % [name(d)])
set-name(d, "Sir Shadow the Wise")
println("But now I am called %_." % [name(d)])
\end{lstlisting}
prints out
\begin{lstlisting}
I used to be called Shadow.
But now I am called Sir Shadow the Wise.
\end{lstlisting}

With the above definition of \texttt{\frenchspacing Dog}, we can change a dog's name but not its breed. If we want to be able to change the breed as well then we need to similarly give it a setter function. 

The convention is to call the setter function the same name as the field it's setting but with a \texttt{\frenchspacing set-} prefix. Follow this convention unless you have a good reason not to.

\subsection*{Providing Custom Printing Behaviour}
We are used to using the \texttt{\frenchspacing print} and \texttt{\frenchspacing println} functions for printing things. Almost all of Stanza's core types can be printed using \texttt{\frenchspacing print}. But \texttt{\frenchspacing print} doesn't yet know how to print \texttt{\frenchspacing Dog} objects. So the following
\begin{lstlisting}
val d = Dog("Shadow", "Golden Retriever")
println("They call me %_." % [d])
\end{lstlisting}
prints out the fairly useless message
\begin{lstlisting}
They call me [Unprintable Object].
\end{lstlisting}

Here is how to provide custom printing behaviour for \texttt{\frenchspacing Dog} objects.
\begin{lstlisting}
defmethod print (o:OutputStream, d:Dog) :
   print(o, "%_ the %_." % [name(d), breed(d)])
\end{lstlisting}

Now the same code
\begin{lstlisting}
val d = Dog("Shadow", "Golden Retriever")
println("They call me %_." % [d])
\end{lstlisting}
prints out
\begin{lstlisting}
They call me Shadow the Golden Retriever.
\end{lstlisting}

The \texttt{\frenchspacing defmethod} keyword {\em extends} a defined {\em multi} with a new {\em method}. We'll learn what that all means later. This gives you small taste of Stanza's multimethod functionality and is the basis for Stanza's class-less object system. 

In the body of the \texttt{\frenchspacing print} method
\begin{lstlisting}
print(o, "%_ the %_." % [name(d), breed(d)])
\end{lstlisting}
be especially mindful of the \texttt{\frenchspacing o} argument to \texttt{\frenchspacing print}. This argument says to print the message to the \texttt{\frenchspacing o} {\em output stream}.

\section{The Match Expression}
Now that you are familiar with a number of different types and know how to create objects of each one, you'll have to learn how to differentiate between them. 
Here's how to write a function that does different things depending on whether its argument is an integer or a string.
\begin{lstlisting}
defn what-am-i (x) :
   match(x) :
      (i:Int) : println("I am %_. I am an integer." % [i])
      (s:String) : println("I am %_. I am a string." % [s])
\end{lstlisting}
If we call it with an integer
\begin{lstlisting}
what-am-i(42)
\end{lstlisting}
then it prints out
\begin{lstlisting}
I am 42. I am an integer.
\end{lstlisting}

But if we call it with a string
\begin{lstlisting}
what-am-i("Timon")
\end{lstlisting}
then it prints out
\begin{lstlisting}
I am Timon. I am a string.
\end{lstlisting}

If we call it with neither an integer or a string
\begin{lstlisting}
what-am-i(false)
\end{lstlisting}
then the program crashes.
\begin{lstlisting}
FATAL ERROR: No matching branch.
   at stanzaproject/lessbasic.stanza:5.9
   at stanzaproject/lessbasic.stanza:9.0
\end{lstlisting}

\subsection*{General Form}
Here's the general form of a match expression.
\begin{lstlisting}
match(argument expressions ...) :
   (argname:ArgType ...) : body
   ...
\end{lstlisting}
A match expression
\begin{enumerate}
\item computes the result of evaluating all the argument expressions,
\item then tests to see whether the results match the argument types indicated in the first branch.
\item If the types match, then the branch argument names are {\em bound} to the results, and the branch body is evaluated. The result of the branch is the result of the entire match expression.
\item If the types do not match, then the subsequent branch is tried. This continues either until a branch finally matches, or no branch matches and the program crashes.
\end{enumerate}

\subsection*{Name Shadowing}
The match expression branches each start a new scope, and the branch arguments are only visible from within that scope. To avoid confusing you we gave new names (\texttt{\frenchspacing i} and \texttt{\frenchspacing s}) to the branch arguments in our example
\begin{lstlisting}
defn what-am-i (x) :
   match(x) :
      (i:Int) : println("I am %_. I am an integer." % [i])
      (s:String) : println("I am %_. I am a string." % [s])
\end{lstlisting}
but you can really use any name for the branch arguments. In fact, it is common to use the same name as the value that you are matching on.
\begin{lstlisting}
defn what-am-i (x) :
   match(x) :
      (x:Int) : println("I am %_. I am an integer." % [x])
      (x:String) : println("I am %_. I am a string." % [x])
\end{lstlisting}

\subsection*{Matching Multiple Arguments}
The match expression supports matching against {\em multiple} arguments. Here's a function that returns different things depending on the types of both of its arguments.
\begin{lstlisting}
defn differentiate (x, y) :
   match(x, y) :
      (x:Int, y:Int) : 0
      (x:Int, y:String) : 1
      (x:String, y:Int) : 2
      (x:String, y:String) : 3
\end{lstlisting}
If we call it with different combinations of integers and strings
\begin{lstlisting}
println(differentiate(42, 42))
println(differentiate(42, "Timon"))
println(differentiate("Pumbaa", 42))
println(differentiate("Timon", "Pumbaa"))
\end{lstlisting}
it returns different results for each. The above prints out
\begin{lstlisting}
0
1
2
3
\end{lstlisting}

\subsection*{Example: Cats and Dogs}
Here's a definition of two structs, \texttt{\frenchspacing Cat} and \texttt{\frenchspacing Dog}. 
\begin{lstlisting}
defstruct Dog : (name:String)
defstruct Cat : (name:String)
\end{lstlisting}

Here's the definition of a \texttt{\frenchspacing say-hi} function that prints different messages depending on whether \texttt{\frenchspacing x} is a \texttt{\frenchspacing Cat} or \texttt{\frenchspacing Dog}. 
\begin{lstlisting}
defn say-hi (x) :
   match(x) :
      (x:Dog) : println("Woof says %_ the dog." % [name(x)])
      (x:Cat) : println("Meow says %_ the cat." % [name(x)])
\end{lstlisting}

Let's call it a few times. 
\begin{lstlisting}
say-hi(Dog("Shadow"))
say-hi(Dog("Chance"))
say-hi(Cat("Sassy"))
\end{lstlisting}
prints out
\begin{lstlisting}
Woof says Shadow the dog.
Woof says Chance the dog.
Meow says Sassy the cat.
\end{lstlisting}

\subsection*{Introducing Union Types}
One problem with the \texttt{\frenchspacing say-hi} function is that it allows us to pass obviously incorrect arguments to it, which crashes the program.
\begin{lstlisting}
say-hi(42)
\end{lstlisting}
results in
\begin{lstlisting}
FATAL ERROR: No matching branch.
   at stanzaproject/lessbasic.stanza:5.9
   at stanzaproject/lessbasic.stanza:9.0
\end{lstlisting}

This is because we didn't give \texttt{\frenchspacing x} a type annotation
\begin{lstlisting}
defn say-hi (x)
\end{lstlisting}
which we've said is equivalent to declaring it with the \texttt{\frenchspacing ?} type.
\begin{lstlisting}
defn say-hi (x:?)
\end{lstlisting}
The \texttt{\frenchspacing ?} type, by definition, allows us to pass anything to it, so Stanza is doing what it should, even though it's not what we want.

We would like to give \texttt{\frenchspacing x} a type annotation that prevents us from passing \texttt{\frenchspacing 42} to \texttt{\frenchspacing say-hi}, but what should it be? It's neither \texttt{\frenchspacing Dog} nor \texttt{\frenchspacing Cat} because \texttt{\frenchspacing say-hi} has to accept them both. The solution is to annotate \texttt{\frenchspacing say-hi} to take {\em either} a \texttt{\frenchspacing Dog} {\em or} a \texttt{\frenchspacing Cat}. 
\begin{lstlisting}
defn say-hi (x:Dog|Cat) :
   match(x) :
      (x:Dog) : println("Woof says %_ the dog." % [name(x)])
      (x:Cat) : println("Meow says %_ the cat." % [name(x)])
\end{lstlisting}

You can verify that calling \texttt{\frenchspacing say-hi} with dogs and cats continue to work, but more importantly, that calling \texttt{\frenchspacing say-hi} with \texttt{\frenchspacing 42} {\em doesn't} work. Attempting to compile
\begin{lstlisting}
say-hi(42)
\end{lstlisting}
gives the error
\begin{lstlisting}
Cannot call function say-hi of type Cat|Dog -> False with arguments of type (Int).
\end{lstlisting}

\texttt{\frenchspacing Cat|Dog} is an example of a {\em union type}. Union types allow us to specify the concept of "either this type or that type". 

\subsection*{Branches with Unspecified Types}
If you leave off the type annotation for an argument in a match expression branch, then Stanza will automatically infer it to have the same type as the match argument expression. The following
\begin{lstlisting}
defn f (x:Int|String) :
   match(x) :
      (x:Int) : body
      (x) : body2
\end{lstlisting}
is equivalent to
\begin{lstlisting}
defn f (x:Int|String) :
   match(x) :
      (x:Int) : body
      (x:Int|String) : body2
\end{lstlisting}

This is often used to provide a default branch to run when none of the preceeding branches match.

\subsection*{Revisiting the If Expression}
Now that you've been introduced to the match expression, it's time to unveil the inner workings of the if expression. It turns out that the if expression is just a slightly decorated match expression.
\begin{lstlisting}
if x < 4 :
   println("Do this")
else :
   println("Do that")
\end{lstlisting}
is completely equivalent to
\begin{lstlisting}
match(x < 4) :
   (p:True) : println("Do this")
   (p:False) : println("Do that")
\end{lstlisting}

The if expression is an example of a simple {\em macro}. Macros are very powerful tools for simplifying the syntax of commonly used patterns. Stanza includes many constructs that are simply decorated versions of other constructs, each implemented as a macro. The defstruct statement is another example. Later, we'll learn how to write our own macros to provide custom syntax for common patterns.

\section{The Is Expression}
Often you simply want to determine whether an object is of a certain type. Here is a long-winded method for checking whether \texttt{\frenchspacing x} is a \texttt{\frenchspacing Dog} object or not.
\begin{lstlisting}
val dog? = match(x) :
              (x:Dog) : true
              (x) : false
\end{lstlisting}

Because this operation is so common, Stanza provides a shorthand for it. The above can be rewritten equivalently as
\begin{lstlisting}
val dog? = x is Dog
\end{lstlisting}

Here is the general form.
\begin{lstlisting}
exp is Type
\end{lstlisting}
It first evaluates \texttt{\frenchspacing exp} and then returns \texttt{\frenchspacing true} if the result is of type \texttt{\frenchspacing Type}. Otherwise it returns \texttt{\frenchspacing false}. The is expression is another example of a convenience syntax implemented using a macro. As you've noticed by now, Stanza's core library makes heavy use of macros.

The negative form of the is expression is the is-not expression. The following determines whether \texttt{\frenchspacing x} is {\em not} a type of \texttt{\frenchspacing Dog}.
\begin{lstlisting}
val not-dog? = x is-not Dog
\end{lstlisting}

\section{Casts}
Stanza's type system is designed primarily to be {\em predictable}, not necessarily smart. This means that, as the programmer, you will often be able to infer a more specific type for an object than Stanza. Here is an example.
\begin{lstlisting}
defn meow (x:Cat) :
   println("Meow!!!")
   
defn f (x:Cat|Dog) :
   val catness = if x is Cat : 1 else : -1
   if catness > 0 :
      meow(x)
\end{lstlisting}
Attempting to compile the above gives the error
\begin{lstlisting}
Cannot call function meow of type Cat -> False with arguments of type (Dog|Cat).
\end{lstlisting}

Stanza believes that \texttt{\frenchspacing x} is a \texttt{\frenchspacing Dog|Cat}, but from our reasoning, the only way that \texttt{\frenchspacing meow} can be called is if \texttt{\frenchspacing catness} is positive. And \texttt{\frenchspacing catness} is only positive if \texttt{\frenchspacing x} is a \texttt{\frenchspacing Cat}. Therefore \texttt{\frenchspacing x} must be a \texttt{\frenchspacing Cat} in the call to \texttt{\frenchspacing meow} and the code should be fine.

To force Stanza to accept \texttt{\frenchspacing x} as a \texttt{\frenchspacing Cat}, we can explicitly {\em cast} \texttt{\frenchspacing x}.
\begin{lstlisting}
defn f (x:Cat|Dog) :
   val catness = if x is Cat : 1 else : -1
   if catness > 0 :
      meow(x as Cat)
\end{lstlisting}
The cast tells Stanza to trust your assertion that \texttt{\frenchspacing x} is indeed a \texttt{\frenchspacing Cat}. If, for some reason, your reasoning is faulty and \texttt{\frenchspacing x} turns out not to be a \texttt{\frenchspacing Cat}, then the incorrect cast will cause the program to crash at that point.

\section{Deep Casts}
Stanza's cast mechanism is much more flexible than many other languages, and, in particular, supports the notion of a {\em deep cast}. 
Here is a function that takes an array of integers or strings, and replaces each string in the array with its length.
\begin{lstlisting}
defn compute-lengths (xs:Array<Int|String>) :
   for i in 0 to length(xs) do :
      match(xs[i]) :
         (x:String) : xs[i] = length(x)
         (x:Int) : false
\end{lstlisting}

And here is a function that computes the sum of an array of integers.
\begin{lstlisting}
defn sum-integers (xs:Array<Int>) :
   var sum = 0
   for i in 0 to length(xs) do :
      sum = sum + xs[i]
   sum   
\end{lstlisting}

Now, given an array containing both integers and strings, we want to first replace each string with its length, and then compute the sum of the integers in the array.
\begin{lstlisting}
val xs = Array<Int|String>(4)
xs[0] = 42
xs[1] = 7
xs[2] = "Timon"
xs[3] = "Pumbaa"

compute-lengths(xs)
sum-integers(xs)
\end{lstlisting}

Attempting to compile the above gives us the error
\begin{lstlisting}
Cannot call function sum-integers of type Array<Int> -> Int with arguments 
of type (Array<String|Int>).
\end{lstlisting}
Stanza is complaining that \texttt{\frenchspacing sum-integers} requires an array of integers, so \texttt{\frenchspacing xs} is an illegal argument as it might contain strings. 

But {\em we} know that \texttt{\frenchspacing xs} will not contain any strings at that point because \texttt{\frenchspacing compute-lengths} replaced all of them with their lengths. So we can use a cast to force Stanza to trust this assertion.
\begin{lstlisting}
sum-integers(xs as Array<Int>)
\end{lstlisting}
With the above correction, the program now compiles and runs correctly.

\subsection*{Types as Contracts}
The above was an example of a {\em deep} cast, because it wasn't a direct assertion about the type of \texttt{\frenchspacing xs}, but about the types of the objects it {\em contains}. You might be wondering, then, what exactly does that cast do? Does it iterate through the array and check every element to see if it is an \texttt{\frenchspacing Int}? You'll be relieved to hear that it does not. That would be hopelessly inefficient, and also impossible in general. 

To answer the question, let's investigate what the cast does in the case that we're wrong. Change the definition of \texttt{\frenchspacing compute-lengths} to this.
\begin{lstlisting}
defn compute-lengths (xs:Array<Int|String>) :
   for i in 0 to length(xs) - 1 do :
      match(xs[i]) :
         (x:String) : xs[i] = length(x)
         (x:Int) : false
\end{lstlisting}
It now forgets to check the last element. So even after the call to \texttt{\frenchspacing compute-lengths}, \texttt{\frenchspacing xs} still contains one last string (\texttt{\frenchspacing "Pumbaa"}) at the end, and thus our cast is incorrect.

Compile and run the program. It should crash with this error.
\begin{lstlisting}
FATAL ERROR: Cannot cast value to type.
   at core/core.stanza:3062.16
   at stanzaprojects/lessbasic.stanza:13.18
   at core/core.stanza:2292.9
   at core/core.stanza:4042.16
   at stanzaprojects/lessbasic.stanza:12.28
   at stanzaprojects/lessbasic.stanza:23.0
\end{lstlisting}
The file position \texttt{\frenchspacing stanzaprojects/lessbasic.stanza:13.18} tells us that the error occurred in the reference to \texttt{\frenchspacing xs[i]} in \texttt{\frenchspacing sum-integers}. Stanza is saying that it was expecting \texttt{\frenchspacing xs[i]} to be an \texttt{\frenchspacing Int} because you promised that \texttt{\frenchspacing xs} is an \texttt{\frenchspacing Array<Int>}. But \texttt{\frenchspacing xs[i]} is {\em not} an \texttt{\frenchspacing Int}, and so your program is wrong.

In general, a value's type in Stanza does not directly say what it {\em is}. Instead, a value's type is a {\em contract} on how it should behave. Part of the contract for an \texttt{\frenchspacing Array<Int>} is that it should only contain \texttt{\frenchspacing Int} objects. The above program crashed as soon as Stanza determined that \texttt{\frenchspacing xs} does not satisfy its contract. 

\section{Operations on Strings}
There are many useful operations on \texttt{\frenchspacing String} objects available in the core library. We'll show a few of them here.

\subsection*{Length}
Here's how to obtain the length of a string.
\begin{lstlisting}
val s = "Hello World"
length(s)
\end{lstlisting}

\subsection*{Retrieve Character}
Here's how to retrieve a given character in a string.
\begin{lstlisting}
val s = "Hello World"
s[4]
\end{lstlisting}
The first character has index 0, and the last character is indexed one less than the length of the string. There is no function for setting the character in a string because strings are {\em immutable} in Stanza. 

\subsection*{Convert to String}
Here's how to convert any object into a string.
\begin{lstlisting}
to-string(42)
\end{lstlisting}

\subsection*{Append}
Here's how to form a longer string from appending two strings together.
\begin{lstlisting}
val s1 = "Hello "
val s2 = "World"
append(s1, s2)
\end{lstlisting}

\subsection*{Substring}
Here's how to retrieve a range of characters within a string.
\begin{lstlisting}
val str = "Hello World"
println(str[4 to 9])
\end{lstlisting}
prints out
\begin{lstlisting}
o Wor
\end{lstlisting}
It's all the characters between index 4 (inclusive) and index 9 (exclusive) in the string.

If we wanted to include the ending index, then we can use the \texttt{\frenchspacing through} keyword, just as we've learned from the previous chapter.
\begin{lstlisting}
println(str[4 through 9])
\end{lstlisting}
prints out
\begin{lstlisting}
o Worl
\end{lstlisting}

If we wanted to extract all characters from index 4 until the end of the string, we can use \texttt{\frenchspacing false} as the ending index.
\begin{lstlisting}
println(str[4 to false])
\end{lstlisting}
prints out
\begin{lstlisting}
o World
\end{lstlisting}

Check out the reference documentation for a listing of operations supported by \texttt{\frenchspacing String} objects.

\section{Operations on Tuples}
Tuples support a few additional operations for querying its properties.

\subsection*{Length}
Here is how to retrieve the length of a tuple.
\begin{lstlisting}
val t = [4, 42, "Hello"]
length(t)
\end{lstlisting}

\subsection*{Retrieve an Element}
Here is how to retrieve an element in a tuple at a {\em dynamically} calculated index.
\begin{lstlisting}
val t = [4, 42, "Hello"]
val i = 1 + 1
println(t[i])
\end{lstlisting}
prints out
\begin{lstlisting}
Hello
\end{lstlisting}

Note that, in general, a dynamically calculated index is not known until the program actually runs. This means that Stanza does not try to determine a precise type for the result of \texttt{\frenchspacing t[i]}. The resulting type of \texttt{\frenchspacing t[i]} is the union of all the element types in the tuple.

Attempting to compile this
\begin{lstlisting}
val t = [4, 42, "Hello"]
val x:Int = t[0 + 1]
\end{lstlisting}
results in the error
\begin{lstlisting}
Cannot assign expression of type Int|String to value x with declared type Int.
\end{lstlisting}
The tuple \texttt{\frenchspacing t} has type \texttt{\frenchspacing [Int, Int, String]}, and so an arbitrary element at an unknown index has type \texttt{\frenchspacing Int|String}. 

To overcome this, you may explicitly cast the result to an \texttt{\frenchspacing Int} yourself. 
\begin{lstlisting}
val t = [4, 42, "Hello"]
val x:Int = t[0 + 1] as Int
\end{lstlisting}

Check out the reference documentation for a listing of operations supported by tuples.

\subsection*{Tuples of Unknown Length}
The type \texttt{\frenchspacing [Int]} is a tuple containing one integer, and the type \texttt{\frenchspacing [Int, Int]} is a tuple containing two integers, et cetera. But what if we want to write a function that takes a tuple of {\em any} number of integers?

Here is a function that prints out every number in a tuple of integers.
\begin{lstlisting}
defn print-tuple (t:Tuple<Int>) :
   for i in 0 to length(t) do :
      println(t[i])
\end{lstlisting}

The following
\begin{lstlisting}
print-tuple([1, 2, 3])
\end{lstlisting}
prints out
\begin{lstlisting}
1
2
3
\end{lstlisting}

But the following
\begin{lstlisting}
print-tuple([1, "Timon"])
\end{lstlisting}
fails to compile with the error
\begin{lstlisting}
Cannot call function print-tuple of type Tuple<Int> -> False with arguments
of type ([Int, String]).
\end{lstlisting}

In general, the type \texttt{\frenchspacing Tuple<Type>}  represents a tuple of unknown length where each element type is of type \texttt{\frenchspacing Type}. 

\section{Packages}
Thus far, all of your code has been contained in a single package. When your projects get larger, you'll start to feel the need to split up the entire program into smaller isolated components. In Stanza, you would do this by partitioning your program into multiple {\em packages}. 

Create a separate file called \texttt{\frenchspacing animals.stanza} containing
\begin{lstlisting}
defpackage animals :
   import core

defstruct Dog :
   name: String
defstruct Cat :
   name: String

defn sound (x:Dog|Cat) :
   match(x) :
      (x:Dog) : "woof"
      (x:Cat) : "meow"
\end{lstlisting}
The \texttt{\frenchspacing animals} package contains all of our code for handling dogs and cats. It contains the struct definitions for \texttt{\frenchspacing Dog} and \texttt{\frenchspacing Cat}, as well as the \texttt{\frenchspacing sound} function that returns the sound made by each animal.

Now create a file called \texttt{\frenchspacing mainprogram.stanza} containing
\begin{lstlisting}
defpackage animal-main :
   import core

defn main () :
   val d = Dog("Shadow")
   val c = Cat("Sassy")
   println("My dog %_ goes %_!" % [name(d), sound(d)])
   println("My cat %_ goes %_!" % [name(c), sound(c)])
   
main()
\end{lstlisting}
The \texttt{\frenchspacing animal-main} package contains the main code of the program and it will use the \texttt{\frenchspacing animals} package as a library. 

\subsection*{Importing Packages}
Now compile both of your source files by typing in the terminal
\begin{lstlisting}
stanza animals.stanza mainprogram.stanza -o animals
\end{lstlisting}
Oops! Something's wrong! Stanza reports these errors.
\begin{lstlisting}
mainprogram.stanza:5.11: Could not resolve Dog.
mainprogram.stanza:6.11: Could not resolve Cat.
mainprogram.stanza:7.44: Could not resolve sound.
mainprogram.stanza:8.44: Could not resolve sound.
\end{lstlisting}

The problem is that our \texttt{\frenchspacing animal-main} package never {\em imported} the \texttt{\frenchspacing animals} package. Packages must be imported before they can be used. So change
\begin{lstlisting}
defpackage animal-main :
   import core
\end{lstlisting}
to
\begin{lstlisting}
defpackage animal-main :
   import core
   import animals
\end{lstlisting}
and try compiling again. Stanza {\em still} reports the same errors.
\begin{lstlisting}
mainprogram.stanza:5.11: Could not resolve Dog.
mainprogram.stanza:6.11: Could not resolve Cat.
mainprogram.stanza:7.44: Could not resolve sound.
mainprogram.stanza:8.44: Could not resolve sound.
\end{lstlisting}

\subsection*{Public Visibility}
What's going on? The problem now is that our \texttt{\frenchspacing animals} package did not make any of its definitions {\em public}. By default, definitions are not visible from outside the package it is declared in. To make a definition visible, you must prefix the definition with the \texttt{\frenchspacing public} keyword. 

Let's declare our \texttt{\frenchspacing Dog} and \texttt{\frenchspacing Cat} structs, and the \texttt{\frenchspacing sound} function to be publicly visible.
\begin{lstlisting}
defpackage animals :
   import core

public defstruct Dog :
   name: String
public defstruct Cat :
   name: String

public defn sound (x:Dog|Cat) :
   match(x) :
      (x:Dog) : "woof"
      (x:Cat) : "meow"
\end{lstlisting}

Now the program compiles successfully and prints out
\begin{lstlisting}
My dog Shadow goes woof!
My cat Sassy goes meow!
\end{lstlisting}

\subsection*{Private Visibility}
By default, all definitions are {\em private} to the package that they are defined in. There is {\em no} way to refer to a private definition from outside the package. This is a very powerful guarantee as it also means that there is no way for any outside code to depend upon the existence of a private definition. 

For example, suppose we rely on a helper function called \texttt{\frenchspacing dog?} to help us define the \texttt{\frenchspacing sound} function. 
\begin{lstlisting}
defpackage animals :
   import core

public defstruct Dog :
   name: String
public defstruct Cat :
   name: String

defn dog? (x:Dog|Cat) :
   match(x) :
      (x:Dog) : true
      (x:Cat) : false

public defn sound (x:Dog|Cat) :
   if dog?(x) : "woof"
   else : "meow"
\end{lstlisting}
\texttt{\frenchspacing dog?} is private to the \texttt{\frenchspacing animals} package, so at any time in the future, if we wanted to rename \texttt{\frenchspacing dog?} or remove it, we can safely do so without affecting other code.

\section{Function Overloading}
By this point, we've learned about arrays, tuples, strings, and how to retrieve the length of each of them.
\begin{lstlisting}
val a = Array<Int>(4)
val b = "Timon and Pumbaa"
val c = [1, 2, 3, 4]
length(a) ;Retrieve length of a array
length(b) ;Retrieve length of a string
length(c) ;Retrieve length of a tuple
\end{lstlisting}
You simply call the \texttt{\frenchspacing length} function. Here is what is happening behind the scenes. The \texttt{\frenchspacing core} package actually contains {\em many} functions called \texttt{\frenchspacing length}, but they differ in the type of the argument that they accept. 
\begin{lstlisting}
defn length (x:Array) -> Int
defn length (x:String) -> Int
defn length (x:Tuple) -> Int
\end{lstlisting}
When you call \texttt{\frenchspacing length(a)}, Stanza automatically figures out which \texttt{\frenchspacing length} function you are trying to call based on the type of its argument. \texttt{\frenchspacing a} is an array, and so you're obviously trying to call the \texttt{\frenchspacing length} function that accepts an \texttt{\frenchspacing Array}. No other \texttt{\frenchspacing length} function would be legal to call! Similarly, \texttt{\frenchspacing b} is a string, so the call to \texttt{\frenchspacing length(b)} is obviously a call to the \texttt{\frenchspacing length} function that accepts a \texttt{\frenchspacing String}. This is a feature called {\em function overloading} and is a key part of Stanza's object system. 

Functions can be overloaded based on the number of arguments that they take, and the types of each argument. Let's write our own overloaded function.
\begin{lstlisting}
defstruct Dog
defstruct Tree
defstruct Captain

defn bark (d:Dog) -> False :
   println("Woof!")
defn bark (t:Tree) -> String :
   "Furrowed Cork"
defn bark (c:Captain) -> False :
   println("A teeeen-hut!")
\end{lstlisting}
Now let's try calling each of them. The following
\begin{lstlisting}
val d = Dog()
val t = Tree()
val c = Captain()
bark(d)
println(bark(t))
bark(c)
\end{lstlisting}
prints out
\begin{lstlisting}
Woof!
Furrowed Cork
A teeeen-hut!
\end{lstlisting}

Notice that the \texttt{\frenchspacing bark} function for \texttt{\frenchspacing Tree} returns a \texttt{\frenchspacing String}, while the \texttt{\frenchspacing bark} functions for \texttt{\frenchspacing Dog} and \texttt{\frenchspacing Captain} return \texttt{\frenchspacing False}. There is no requirement for any of the \texttt{\frenchspacing bark} functions to be related or aware of each other. They can even be declared in separate packages! 

\section{Operator Mapping}
In the previous chapter, you were introduced to the basic arithmetic operators. Here we'll show you a bit about how they work underneath. The following
\begin{lstlisting}
val a = 13
val b = 24
a + b
a - b
a * b
a / b
a % b
(- a)
\end{lstlisting}
can be rewritten equivalently as
\begin{lstlisting}
val a = 13
val b = 24
plus(a, b)
minus(a, b)
times(a, b)
divide(a, b)
modulo(a, b)
negate(a)
\end{lstlisting}
Thus you can see here that all operators in Stanza are simply syntactic shorthands for specific function calls. Here is a listing of what each operator expands to.
\begin{lstlisting}
a + b     expands to   plus(a, b)
a - b     expands to   minus(a, b)
a * b     expands to   times(a, b)
a / b     expands to   divide(a, b)
a % b     expands to   modulo(a, b)
(- x)     expands to   negate(x)

a << b    expands to   shift-left(a, b)
a >> b    expands to   shift-right(a, b)
a >>> b   expands to   arithmetic-shift-right(a, b)
a & b     expands to   bit-and(a, b)
a | b     expands to   bit-or(a, b)
a ^ b     expands to   bit-xor(a, b)
(~ x)     expands to   bit-not(x)

a == b    expands to   equal?(a, b)
a != b    expands to   not-equal?(a, b)
a < b     expands to   less?(a, b)
a <= b    expands to   less-eq?(a, b)
a > b     expands to   greater?(a, b)
a >= b    expands to   greater-eq?(a, b)
not x     expands to   complement(x)
\end{lstlisting}

\subsection*{Operator Overloading}
The benefit to mapping each operator to a function call is that you can very easily reuse these operators for your own objects. Here is an example struct definition for modeling points on the cartesian plane.
\begin{lstlisting}
defstruct Point :
   x: Double
   y: Double
\end{lstlisting}

Next let's define a function called \texttt{\frenchspacing plus} that can add together two \texttt{\frenchspacing Point} objects.
\begin{lstlisting}
defn plus (a:Point, b:Point) :
   Point(x(a) + x(b), y(a) + y(b))
\end{lstlisting}

Let's try out our function.
\begin{lstlisting}
defn main () :
   val a = plus(Point(1.0,3.0), Point(4.0,5.0))
   val b = plus(a, Point(7.0,1.0))
   println("b is (%_, %_)" % [x(b), y(b)])

main()
\end{lstlisting}
The above prints out
\begin{lstlisting}
b is (12.000000000000000, 9.000000000000000)
\end{lstlisting}

But, as mentioned, the \texttt{\frenchspacing +} operator is a shorthand for calling the \texttt{\frenchspacing plus} function. So our \texttt{\frenchspacing main} function can be written more naturally as
\begin{lstlisting}
defn main () :
   val a = Point(1.0,3.0) + Point(4.0,5.0)
   val b = a + Point(7.0,1.0)
   println("b is (%_, %_)" % [x(b), y(b)])
\end{lstlisting}

\subsection*{Get and Set}
Two other operators that we have been using without being aware of it are the get and set operators. The following code
\begin{lstlisting}
val a = Array<Int>(4)
a[0] = 42
a[0]
\end{lstlisting}
is equivalent to
\begin{lstlisting}
val a = Array<Int>(4)
set(a, 0, 42)
get(a, 0)
\end{lstlisting}

Thus the \texttt{\frenchspacing a[i]} form expands to calls to the \texttt{\frenchspacing get} function.
\begin{lstlisting}
a[i]         expands to   get(a, i)
a[i, j]      expands to   get(a, i, j)
a[i, j, k]   expands to   get(a, i, j, k)
etc ...
\end{lstlisting}
And the \texttt{\frenchspacing a[i] = v} form expands to calls to the \texttt{\frenchspacing set} function.
\begin{lstlisting}
a[i] = v         expands to   set(a, i, v)
a[i, j] = v      expands to   set(a, i, j, v)
a[i, j, k] = v   expands to   set(a, i, j, k, v)
etc ...
\end{lstlisting}

\section{Vectors}
So far we've only called the library functions in the \texttt{\frenchspacing core} package. The \texttt{\frenchspacing collections} package contains commonly used datastructures useful for daily programming.

Here is a program that imports the \texttt{\frenchspacing collections} package and creates and prints a \texttt{\frenchspacing Vector} object.
\begin{lstlisting}
defpackage mypackage :
   import core
   import collections

defn main () :
   val v = Vector<Int>()
   add(v, 1)
   add(v, 2)
   add(v, 3)
   println(v)

main()
\end{lstlisting}
It prints out
\begin{lstlisting}
[1 2 3]
\end{lstlisting}

A \texttt{\frenchspacing Vector} object is similar to an array and represents a mutable collection of items where each item is associated with an integer index. However, whereas arrays are of fixed length, a vector can grow and shrink to accomodate more or less items. 

The type of the \texttt{\frenchspacing v} vector in the example above is 
\begin{lstlisting}
Vector<Int>
\end{lstlisting}
indicating that it is a vector for storing integers.

Here is how to add additional elements to the end of a vector.
\begin{lstlisting}
add(v, 42)
\end{lstlisting}

Here is how to retrieve and remove the element at the end of the vector.
\begin{lstlisting}
pop(v)
\end{lstlisting}

Identical to the case of arrays, here is how to retrieve the length of a vector, retrieve a value at a particular index, and assign a value to a particular index.
\begin{lstlisting}
length(v) ;Retrieve a vector's length
v[0] = 42 ;Assign a value to index 0
v[0] ;Retrieve the value at index 0
\end{lstlisting}

\section{HashTables}
Hash tables are another commonly used datastructure in the \texttt{\frenchspacing collections} package. A table associates a value object with a particular key object. It can be imagined as a two-column table (hence the name) where the left column is named {\em keys} and the right column is named {\em values}. Each entry in the table is recorded as a new row. The key object is recorded in the keys column, and its corresponding value object is recorded in the values column.

Here is how to create a HashTable where strings are used as keys, and integers are used as values.
\begin{lstlisting}
val num-pets = HashTable<String,Int>()
num-pets["Luca"] = 2
num-pets["Patrick"] = 1
num-pets["Emmy"] = 3
println(num-pets)
\end{lstlisting}
The above prints out
\begin{lstlisting}
["Patrick" => 1 "Luca" => 2 "Emmy" => 3]
\end{lstlisting}

\subsection*{Creation}
The function
\begin{lstlisting}
HashTable<String,Int>()
\end{lstlisting}
creates a new hash table that associates integer values with string keys. The type of the table created by the above function is
\begin{lstlisting}
HashTable<String,Int>
\end{lstlisting}
which indicates that it is a hash table whose keys have type \texttt{\frenchspacing String} and whose values have type \texttt{\frenchspacing Int}.

\subsection*{Set}
The calls to \texttt{\frenchspacing set}
\begin{lstlisting}
num-pets["Luca"] = 2
num-pets["Patrick"] = 1
num-pets["Emmy"] = 3
\end{lstlisting}
associates the value 2 with the key "Luca" in the table, the value 1 with "Patrick", and the value 3 with "Emmy". 

\subsection*{Get}
Here's how to retrieve the value associated with a key.
\begin{lstlisting}
println("Emmy has %_ pets." % [num-pets["Emmy"]])
\end{lstlisting}
which prints out
\begin{lstlisting}
Emmy has 3 pets.
\end{lstlisting}

\subsection*{Does a Key Exist?}
Attempting to retrieve the value in a table corresponding to a key that doesn't exist is a fatal error. Use the \texttt{\frenchspacing key?} function to check whether a key exists in the table.
\begin{lstlisting}
if key?(num-pets, "George") :
   println("George has %_ pets." % [num-pets["George"]])
else :
   println("I don't know how many pets George has.")
\end{lstlisting}

\subsection*{Default Values}
A hash table can also be created with a {\em default} value. If a hash table has a default value, then this default value is returned when retrieving the corresponding value for a key that does not exist in the table. Change the definition of num-pets to
\begin{lstlisting}
val num-pets = HashTable<String,Int>(0)
\end{lstlisting}
Now when we retrieve the number of pets owned by George,
\begin{lstlisting}
println("George has %_ pets." % [num-pets["George"]])
\end{lstlisting}
it prints out
\begin{lstlisting}
George has 0 pets.
\end{lstlisting}

\section{KeyValue Pairs}
A \texttt{\frenchspacing KeyValue} object represents an association between a key object and a value object. It can be created using the \texttt{\frenchspacing KeyValue} function.
\begin{lstlisting}
val kv = KeyValue(4, "Hello")
\end{lstlisting}
creates a \texttt{\frenchspacing KeyValue} object that represents the mapping from the key \texttt{\frenchspacing 4} to the value \texttt{\frenchspacing "Hello"}. This is done very commonly, so Stanza also provides a convenient operator. The above can be written equivalently as
\begin{lstlisting}
val kv = 4 => "Hello"
\end{lstlisting}

The type of the \texttt{\frenchspacing kv} object created above is
\begin{lstlisting}
KeyValue<Int,String>
\end{lstlisting}
which indicates that it represents an association between a key of type \texttt{\frenchspacing Int} and a value of type \texttt{\frenchspacing String}.

The key and the value objects in a \texttt{\frenchspacing KeyValue} object can be retrieved using the \texttt{\frenchspacing key} and \texttt{\frenchspacing value} functions respectively.
\begin{lstlisting}
key(kv) ;Retrieve the key
value(kv) ;Retrieve the value
\end{lstlisting}

\section{For Loops over Sequences}
Thus far you've only been shown how to use the for construct for simple counting loops. Here you'll see how the for construct generalizes to all types of collections.

The for loop can be used to iterate directly through the items of an array like so.
\begin{lstlisting}
val xs = Array<Int>(4)
xs[0] = 2
xs[1] = 42
xs[2] = 7
xs[3] = 1

for x in xs do :
   println(x)
\end{lstlisting}
which prints out
\begin{lstlisting}
2
42
7
1
\end{lstlisting}

\subsection*{General Form}
Here is the general form.
\begin{lstlisting}
for x in xs do :
   body
\end{lstlisting}
For each item in the {\em collection} \texttt{\frenchspacing xs}, the for loop executes \texttt{\frenchspacing body} once with \texttt{\frenchspacing x} bound to the next item in the collection. In our example, \texttt{\frenchspacing xs} contains the numbers \texttt{\frenchspacing 2}, \texttt{\frenchspacing 42}, \texttt{\frenchspacing 7}, and \texttt{\frenchspacing 1}, and thus \texttt{\frenchspacing body} is executed once each with \texttt{\frenchspacing x} bound to \texttt{\frenchspacing 2}, \texttt{\frenchspacing 42}, \texttt{\frenchspacing 7}, and finally \texttt{\frenchspacing 1}. 

\subsection*{Examples of Collections}
We will more precisely specify what constitutes a {\em collection} later. For now, just accept that arrays, vectors, and tuples are collections, and strings are collections of characters. For example,
\begin{lstlisting}
for c in "Timon" do :
   print("Next char is ")
   println(c)
\end{lstlisting}
prints out
\begin{lstlisting}
Next char is T
Next char is i
Next char is m
Next char is o
Next char is n
\end{lstlisting}

And similarly,
\begin{lstlisting}
for x in [1, 3, "Timon"] do :
   print("Next item is ")
   println(x)
\end{lstlisting}
prints out
\begin{lstlisting}
Next item is 1
Next item is 3
Next item is Timon
\end{lstlisting}

In fact, \texttt{\frenchspacing Range} objects are collections of integers, so the counting loops we saw before are actually just a special case of iterating through the items in a \texttt{\frenchspacing Range}. 
\begin{lstlisting}
val r = 0 to 4
for x in r do :
   print("Next number is ")
   println(x)
\end{lstlisting}
prints out
\begin{lstlisting}
Next number is 0
Next number is 1
Next number is 2
Next number is 3
\end{lstlisting}

Tables are also collections, but they are collections of \texttt{\frenchspacing KeyValue} objects, each representing one of the entries in the table. The following
\begin{lstlisting}
val num-pets = HashTable<String,Int>()
num-pets["Luca"] = 2
num-pets["Patrick"] = 1
num-pets["Emmy"] = 3

for entry in num-pets do :
   println("%_ has %_ pets." % [key(entry), value(entry)])
\end{lstlisting}
prints out
\begin{lstlisting}
Patrick has 1 pets.
Luca has 2 pets.
Emmy has 3 pets.
\end{lstlisting}

As you can see, Stanza's for construct is extremely powerful. In truth, the form shown here is {\em still} not the most general form of the for construct. We'll learn about that after we've covered first class functions.

\section{Extended Example: Complex Number Package}
In this extended example, we will implement a package for creating and performing arithmetic with complex numbers. 

\subsection*{The Complex Package}
Create a file called \texttt{\frenchspacing complex.stanza} with the following content.
\begin{lstlisting}
defpackage complex :
   import core

public defstruct Cplx :
   real: Double
   imag: Double
\end{lstlisting}
This struct will be our representation for complex numbers. It is stored in cartesian form and has real and imaginary components. 

\subsection*{Printing Complex Numbers}
To be able to print \texttt{\frenchspacing Cplx} objects, we provide a custom print method.
\begin{lstlisting}
defmethod print (o:OutputStream, x:Cplx) :
   if imag(x) >= 0.0 :
      print(o, "%_ + %_i" % [real(x), imag(x)])
   else :
      print(o, "%_ - %_i" % [real(x), (- imag(x))])
\end{lstlisting}

\subsection*{Main Driver}
To test our program thus far, create a file called \texttt{\frenchspacing complexmain.stanza} with the following content.
\begin{lstlisting}
defpackage complex/main :
   import core
   import complex

defn main () :
   val a = Cplx(1.0, 5.0)
   val b = Cplx(3.0, -4.0)
   println(a)
   println(b)

main()
\end{lstlisting}

Compile and run the program by typing the following in the terminal.
\begin{lstlisting}
stanza complex.stanza complexmain.stanza -o cplx
./cplx
\end{lstlisting}
It should print out
\begin{lstlisting}
1.000000000000000 + 5.000000000000000i
3.000000000000000 - 4.000000000000000i
\end{lstlisting}

Great! So now we can create and print out complex numbers. If you're an electrical engineer, you may substitute \texttt{\frenchspacing i} for \texttt{\frenchspacing j} in the \texttt{\frenchspacing print} method.

 \subsection*{Arithmetic Operations}
The next step is to implement the standard arithmetic operations for complex numbers. Pull out your old algebra textbooks and look up the formulas. Or pick up a pencil and derive them yourself. 
\begin{lstlisting}
public defn plus (a:Cplx, b:Cplx) :
   Cplx(real(a) + real(b), imag(a) + imag(b))

public defn minus (a:Cplx, b:Cplx) :
   Cplx(real(a) - real(b), imag(a) - imag(b))

public defn times (a:Cplx, b:Cplx) :
   val x = real(a)
   val y = imag(a)
   val u = real(b)
   val v = imag(b)
   Cplx(x * u - y * v, x * v + y * u)

public defn divide (a:Cplx, b:Cplx) :
   val x = real(a)
   val y = imag(a)
   val u = real(b)
   val v = imag(b)
   val den = u * u + v * v
   Cplx((x * u + y * v) / den, (y * u - x * v) / den)
\end{lstlisting}

Let's test out our operators.
\begin{lstlisting}
defn main () :
   val a = Cplx(1.0, 5.0)
   val b = Cplx(3.0, -4.0)
   println("(%_) + (%_) = %_" % [a, b, a + b])
   println("(%_) - (%_) = %_" % [a, b, a - b])
   println("(%_) * (%_) = %_" % [a, b, a * b])
   println("(%_) / (%_) = %_" % [a, b, a / b])

main()
\end{lstlisting}
The program prints out
\begin{lstlisting}
(1.000000000000000 + 5.000000000000000i) + (3.000000000000000 - 4.000000000000000i)
    = 4.000000000000000 + 1.000000000000000i
(1.000000000000000 + 5.000000000000000i) - (3.000000000000000 - 4.000000000000000i)
    = -2.000000000000000 + 9.000000000000000i
(1.000000000000000 + 5.000000000000000i) * (3.000000000000000 - 4.000000000000000i)
    = 23.000000000000000 + 11.000000000000000i
(1.000000000000000 + 5.000000000000000i) / (3.000000000000000 - 4.000000000000000i)
    = -0.680000000000000 + 0.760000000000000i
\end{lstlisting}
which looks right to me!

\subsection*{Root Finding}
Armed with our new complex number package, let's now put it to good use and solve an equation. We will use the Newton-Raphson method to solve the following equation.
\begin{lstlisting}
x ^ 3 - 1 = 0
\end{lstlisting}

Here is our numerical solver which takes an initial guess, \texttt{\frenchspacing x0}, and the number of iterations, \texttt{\frenchspacing num-iter}, and performs \texttt{\frenchspacing num-iter} number of Newton-Raphson iterations to find the root of the equation.
\begin{lstlisting}
defn newton-raphson (x0:Cplx, num-iter:Int) :
   var xn = x0
   for i in 0 to num-iter do :
      xn = xn - (xn * xn * xn - Cplx(1.0,0.0)) / (Cplx(3.0,0.0) * xn * xn)
   xn   
\end{lstlisting}

Let's test it!
\begin{lstlisting}
defn main () :
   println(newton-raphson(Cplx(1.0,1.0), 100))
\end{lstlisting}
The program prints out
\begin{lstlisting}
1.000000000000000 + 0.000000000000000i
\end{lstlisting}
which is indeed one of the solutions to the equation! Fantastic!

\subsection*{Find all the Roots!}
But according to the Fundamental Theorem of Algebra, the equation should have two more solutions. Different initial guesses will converge to different solutions so let's try a whole bunch of different guesses and try to find them all.

Here is a function that takes in a tuple of initial guesses and tries them all.
\begin{lstlisting}
defn guess (xs:Tuple<Cplx>) :
   for x in xs do :
      val r = newton-raphson(x, 100)
      println("Initial guess %_ gave us solution %_." % [x, r])
\end{lstlisting}

And let's call it with a bunch of random guesses.
\begin{lstlisting}
defn main () :
   guess([Cplx(1.0,1.0), Cplx(2.0,2.0), Cplx(-1.0,3.0), Cplx(-1.0,-1.0)])
\end{lstlisting}

The program prints out
\begin{lstlisting}
Initial guess 1.000000000000000 + 1.000000000000000i gave 
   us solution 1.000000000000000 + 0.000000000000000i.
Initial guess 2.000000000000000 + 2.000000000000000i gave 
   us solution 1.000000000000000 + 0.000000000000000i.
Initial guess -1.000000000000000 + 3.000000000000000i gave 
   us solution -0.500000000000000 + 0.866025403784439i.
Initial guess -1.000000000000000 - 1.000000000000000i gave 
   us solution -0.500000000000000 - 0.866025403784439i.
\end{lstlisting}

Thus the three solutions to the equation are \texttt{\frenchspacing 1}, \texttt{\frenchspacing -0.5 + 0.866i}, and \texttt{\frenchspacing -0.5 - 0.866i}. Problem solved!

\chapter{Architecting Programs}

Stanza's object system differs significantly from most other programming languages. Most other languages (e.g. Java, C\#, Python, Ruby, Objective-C, C++, Swift, Scala, OCaml, etc.) employ a {\em class} based object system. In a class based object system, each {\em thing} in the program is represented using a class. For each {\em ability} that a thing has, the user adds another method to its class. Classes have all the power in a class-based object system. Methods live inside classes.

In contrast, Stanza employs a {\em class-less} object system. In Stanza, each {\em thing} is represented as a type. There is a minimal set of fundamental operations that defines the behaviour of a type. After that, everything that can be {\em done} with each thing is implemented as a simple function. Both types and functions have equal standing. Types do not live inside functions, nor do functions live inside types. The careful balance between these constructs is what gives Stanza its flexibility and architectural power.

\section{A Shape Library}
In \texttt{\frenchspacing shapes.stanza}, let's create a package for creating and manipulating two-dimensional shapes.
\begin{lstlisting}
defpackage shapes :
   import core
   import math

public defstruct Point :
   x: Double
   y: Double

public defstruct Circle :
   x: Double
   y: Double
   radius: Double

public defn area (s:Point|Circle) -> Double :
   match(s) :
      (s:Point) : 0.0
      (s:Circle) : PI * radius(s) * radius(s)

defmethod print (o:OutputStream, p:Point) :
   print(o, "Point(%_, %_)" % [x(p), y(p)])

defmethod print (o:OutputStream, c:Circle) :
   print(o, "Circle(%_, %_, radius = %_)" % [x(c), y(c), radius(c)])
\end{lstlisting}
The \texttt{\frenchspacing shapes} package contains struct definitions for points and circles, methods for printing them, as well as an \texttt{\frenchspacing area} function for computing the areas of these shapes. It imports the \texttt{\frenchspacing math} package to access the definition of the mathematical constant \texttt{\frenchspacing PI}. 

In \texttt{\frenchspacing shapes-main.stanza}, as our main program, let's compute the total area of a bunch of shapes. 
\begin{lstlisting}
defpackage shapes/main :
   import core
   import collections
   import shapes

defn total-area (ss:Vector<Point|Circle>) :
   var total = 0.0
   for s in ss do :
      total = total + area(s)
   total   

defn main () :
   val ss = Vector<Point|Circle>()
   add(ss, Point(1.0, 1.0))
   add(ss, Circle(2.0, 2.0, 3.0))
   add(ss, Circle(3.0, 0.0, 1.0))
   println("Shapes:")
   println(ss)
   println("Total area = %_" % [total-area(ss)])

main()
\end{lstlisting}

Compile and run the program by typing the following in the terminal.
\begin{lstlisting}
stanza shapes.stanza shapes-main.stanza -o shapes
./shapes
\end{lstlisting}

It should print out
\begin{lstlisting}
Shapes:
[Point(1.000000000000000, 1.000000000000000)
 Circle(2.000000000000000, 2.000000000000000, radius = 3.000000000000000)
 Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)]
Total area = 31.415926535897931
\end{lstlisting}

\section{Creating a New Shape}
Our \texttt{\frenchspacing shapes} package supports points and circles, but let's now extend it to support rectangles. What do we need to change in order to support another shape?
\begin{enumerate}
\item First we need to define a \texttt{\frenchspacing Rectangle} struct for representing rectangles.
\item Next we need to provide custom printing behavior for rectangles.
\item We need to change \texttt{\frenchspacing area}'s type signature to now accept a \texttt{\frenchspacing Point|Circle|Rectangle}.
\item We need to add another branch to the implementation of \texttt{\frenchspacing area} to support rectangles.
\item We need to change \texttt{\frenchspacing total-area}'s type signature to now accept a \texttt{\frenchspacing Vector<Point|Circle|Rectangle>}.
\item We need to change how \texttt{\frenchspacing ss} is created to allow it to also hold rectangles.
\end{enumerate}

The first two items are straightforward so let's do that immediately.
\begin{lstlisting}
public defstruct Rectangle :
   x: Double
   y: Double
   width: Double
   height: Double

defmethod print (o:OutputStream, r:Rectangle) :
   print(o, "Rectangle(%_, %_, size = %_ x %_)" %
         [x(r), y(r), width(r), height(r)])
\end{lstlisting}
A rectangle is defined by the coordinates of its bottom-left corner and its width and height.

The other items on the list are not hard to implement at present but it is clear that it is not a sustainable strategy. Here's how it would look.
\texttt{\frenchspacing area} in the \texttt{\frenchspacing shapes} package is updated to
\begin{lstlisting}
public defn area (s:Point|Circle|Rectangle) -> Double :
   match(s) :
      (s:Point) : 0.0
      (s:Circle) : PI * radius(s) * radius(s)
      (s:Rectangle) : width(s) * height(s)
\end{lstlisting}
\texttt{\frenchspacing total-area} in the \texttt{\frenchspacing shapes/main} package is updated to
\begin{lstlisting}
defn total-area (ss:Vector<Point|Circle|Rectangle>) :
   var total = 0.0
   for s in ss do :
      total = total + area(s)
   total  
\end{lstlisting}
And the creation of \texttt{\frenchspacing ss} in the \texttt{\frenchspacing main} function is updated to
\begin{lstlisting}
val ss = Vector<Point|Circle|Rectangle>()
\end{lstlisting}
It is not a pretty solution. Imagine if we had ten more types shapes to define. \texttt{\frenchspacing area}'s type signature would quickly become unwieldy as we tack on more and more types to the argument. Every new shape requires manually editing the internals of the \texttt{\frenchspacing area} function. Currently \texttt{\frenchspacing area} is the only function defined on shapes, but what if there were a dozen more? Would we have to manually edit the internals of each of them? 

By far, the worst aspect of the solution is the need to update the definition of the user's \texttt{\frenchspacing total-area} function and \texttt{\frenchspacing ss} vector. The user simply wants \texttt{\frenchspacing total-area} to accept a vector of shapes. Which shapes? Well, {\em any} shape! There must be a better way to express that than an explicit union containing the names of every single type of shape currently defined.

\section{Subtyping}
Here is the definition of a new {\em type} called \texttt{\frenchspacing Shape}.
\begin{lstlisting}
public deftype Shape
\end{lstlisting}
A \texttt{\frenchspacing Shape} is a general representation of a two-dimensional shape. If an object has type \texttt{\frenchspacing Shape}, then we know that it is definitely a shape, though we may not know which particular shape it is. 

Here is how to annotate our \texttt{\frenchspacing Point} struct as being a {\em subtype} of \texttt{\frenchspacing Shape}.
\begin{lstlisting}
public defstruct Point <: Shape :
   x: Double
   y: Double
\end{lstlisting}
This annotation tells Stanza that all points are shapes. Thus if we write a function that requires \texttt{\frenchspacing Shape} objects,
\begin{lstlisting}
defn its-a-shape (s:Shape) :
   println("%_ is a shape!" % [s])
\end{lstlisting}
then we are allowed to pass it \texttt{\frenchspacing Point} objects. The following
\begin{lstlisting}
its-a-shape(Point(1.0, 2.0))
\end{lstlisting}
compiles correctly and prints out
\begin{lstlisting}
Point(1.000000000000000, 2.000000000000000) is a shape!
\end{lstlisting}

Note, however, that though all points are shapes, {\em not} all shapes are points. Thus if we write a function that requires \texttt{\frenchspacing Point} objects,
\begin{lstlisting}
defn its-a-point (p:Point) :
   println("%_ is a point!" % [p])
\end{lstlisting}
and try it to call it with a \texttt{\frenchspacing Shape} object,
\begin{lstlisting}
var s:Shape
its-a-point(s)
\end{lstlisting}
Stanza will give the following error.
\begin{lstlisting}
Cannot call function its-a-point of type Point -> False with arguments
of type (Shape).
\end{lstlisting}

Thus the relationship
\begin{lstlisting}
Point <: Shape
\end{lstlisting}
says that \texttt{\frenchspacing Point} is a subtype of \texttt{\frenchspacing Shape}, meaning that all \texttt{\frenchspacing Point} objects are also \texttt{\frenchspacing Shape} objects (but not vice versa). 

\subsection*{Code Cleanup}
Now that we have a definition for \texttt{\frenchspacing Shape}, let's indicate this relationship for all of our shape structs.
\begin{lstlisting}
public defstruct Point <: Shape :
   x: Double
   y: Double

public defstruct Circle <: Shape :
   x: Double
   y: Double
   radius: Double

public defstruct Rectangle <: Shape :
   x: Double
   y: Double
   width: Double
   height: Double
\end{lstlisting}
Now all of our shape structs are also subtypes of \texttt{\frenchspacing Shape}. This allows us to clean up many of the type signatures, both in the \texttt{\frenchspacing shapes} package and in the \texttt{\frenchspacing shapes/main} package.

The type signature for \texttt{\frenchspacing area} is simplified.
\begin{lstlisting}
public defn area (s:Shape) -> Double :
   match(s) :
      (s:Point) : 0.0
      (s:Circle) : PI * radius(s) * radius(s)
      (s:Rectangle) : width(s) * height(s)
\end{lstlisting}

The type signature for \texttt{\frenchspacing total-area} is simplified.
\begin{lstlisting}
defn total-area (ss:Vector<Shape>) :
   var total = 0.0
   for s in ss do :
      total = total + area(s)
   total   
\end{lstlisting}

And the creation of \texttt{\frenchspacing ss} is simplified.
\begin{lstlisting}
val ss = Vector<Shape>()
\end{lstlisting}

Notice that with these simplifications, items 3, 5, and 6 on our checklist for creating new shapes are no longer necessary.

\section{Multis and Methods}
Our \texttt{\frenchspacing shape} package is architecturally fairly complete at this point. It currently supports points, circles and rectangles, and we can calculate the area of each of them. If we need another shape, e.g. lines, then all we have to do is define a \texttt{\frenchspacing Line} struct and edit \texttt{\frenchspacing area} to support \texttt{\frenchspacing Line} objects. 

\subsection*{The Need for Extensibility}
There remains one limitation to our shapes library however. Suppose that we are the authors and maintainers in charge of the shapes library, and that there are many users who use the \texttt{\frenchspacing shapes} package for their daily work. What should a user do if our library does not support a shape that he needs? This is a likely scenario, because it is implausible for us to have fully considered the shape needs of every user. And often, some user's needs are so specific that we don't {\em want} to support it in the standard shapes library. It will just end up cluttering the library and confusing the rest of the users. For example, it seems inappropriate to support the \texttt{\frenchspacing Salinon} shape in the standard library. 

What we can do however, is to allow users to define their {\em own} shapes. Then typical users can stay content using the standard shapes in the library, and power users can define their own shapes for their own use. 

Users can {\em almost} do this. They can create their own shape struct, and provide custom printing behaviour for it. Let us portray here a user working on greek architecture, and who has started defining his own extensions to the shape library in the file \texttt{\frenchspacing greek-shapes.stanza}.
\begin{lstlisting}
defpackage greek-shapes :
   import core
   import shapes

public defstruct Salinon <: Shape :
   x: Double
   y: Double
   outer-radius: Double
   inner-radius: Double

defmethod print (o:OutputStream, s:Salinon) :
   print(o, "Salinon(%_, %_, outer-radius = %_, inner-radius = %_)" % [
      x(s), y(s), outer-radius(s), inner-radius(s)])
\end{lstlisting}
The problem though is that the user has no way of extending \texttt{\frenchspacing area} to support \texttt{\frenchspacing Salinon} shapes, because that would require editing the code in the \texttt{\frenchspacing shapes} package, which he does not have access to.

\subsection*{defmulti and defmethod}
The solution is to declare \texttt{\frenchspacing area} not as a function but as a {\em multi}.
\begin{lstlisting}
public defmulti area (s:Shape) -> Double
\end{lstlisting}
Note that the definition of a multi does not include a body. It simply says that \texttt{\frenchspacing area} is a multi that when called with a \texttt{\frenchspacing Shape} returns a \texttt{\frenchspacing Double}. 

Here is how to {\em attach} a method to a multi.
\begin{lstlisting}
defmethod area (p:Point) -> Double :
   0.0
\end{lstlisting}
This definition tells Stanza that when the \texttt{\frenchspacing area} multi is called on a \texttt{\frenchspacing Point} then simply return \texttt{\frenchspacing 0.0}. 

Here are the methods for \texttt{\frenchspacing area} for circles and rectangles.
\begin{lstlisting}
defmethod area (c:Circle) :
   PI * radius(c) * radius(c)

defmethod area (r:Rectangle) :
   width(r) * height(r)
\end{lstlisting}
Notice that similar to functions, if the return type is not given, then it is inferred from the method body. 

A multi can have any number of methods, and the methods can be distributed across any number of packages and source files. Thus our greek architect can now define a method for \texttt{\frenchspacing area} for \texttt{\frenchspacing Salinon} shapes in his own \texttt{\frenchspacing greek-shapes} package.
\begin{lstlisting}
defpackage greek-shapes :
   import core
   import shapes
   import math

...

defmethod area (s:Salinon) :
   val r = outer-radius(s) + inner-radius(s)
   PI * r * r / 4.0
\end{lstlisting}
You'll just have to trust me on the area of a salinon.

Let's go back to our main program now and include a couple of salinons in our \texttt{\frenchspacing ss} vector.
\begin{lstlisting}
defpackage shapes/main :
   import core
   import collections
   import shapes
   import greek-shapes

...

defn main () :
   val ss = Vector<Shape>()
   add(ss, Point(1.0, 1.0))
   add(ss, Circle(2.0, 2.0, 3.0))
   add(ss, Circle(3.0, 0.0, 1.0))
   add(ss, Salinon(0.0, 0.0, 10.0, 5.0))
   add(ss, Salinon(5.0, -1.0, 8.0, 7.0))
   println("Shapes:")
   println(ss)
   println("Total area = %_" % [total-area(ss)])

...
\end{lstlisting}

Compile and run the program by typing
\begin{lstlisting}
stanza shapes.stanza greek-shapes.stanza shapes-main.stanza -o shapes
./shapes
\end{lstlisting}

The program should print out
\begin{lstlisting}
Shapes:
[Point(1.000000000000000, 1.000000000000000)
 Circle(2.000000000000000, 2.000000000000000, radius = 3.000000000000000)
 Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)
 Salinon(0.000000000000000, 0.000000000000000,
         outer-radius = 10.000000000000000, inner-radius = 5.000000000000000)
 Salinon(5.000000000000000, -1.000000000000000,
         outer-radius = 8.000000000000000, inner-radius = 7.000000000000000)]
Total area = 384.845100064749658
\end{lstlisting}

The following listing contains the complete program.
\subsection*{Program Listing}
In \texttt{\frenchspacing shapes.stanza}
\begin{lstlisting}
defpackage shapes :
   import core
   import math

public deftype Shape

public defstruct Point <: Shape :
   x: Double
   y: Double

public defstruct Circle <: Shape :
   x: Double
   y: Double
   radius: Double

public defstruct Rectangle <: Shape :
   x: Double
   y: Double
   width: Double
   height: Double

defmethod print (o:OutputStream, p:Point) :
   print(o, "Point(%_, %_)" % [x(p), y(p)])

defmethod print (o:OutputStream, c:Circle) :
   print(o, "Circle(%_, %_, radius = %_)" % [x(c), y(c), radius(c)])

defmethod print (o:OutputStream, r:Rectangle) :
   print(o, "Rectangle(%_, %_, size = %_ x %_)" %
         [x(r), y(r), width(r), height(r)])

public defmulti area (s:Shape) -> Double

defmethod area (p:Point) -> Double :
   0.0

defmethod area (c:Circle) :
   PI * radius(c) * radius(c)

defmethod area (r:Rectangle) :
   width(r) * height(r)
\end{lstlisting}
   
In \texttt{\frenchspacing greek-shapes.stanza}
\begin{lstlisting}
defpackage greek-shapes :
   import core
   import shapes
   import math

public defstruct Salinon <: Shape :
   x: Double
   y: Double
   outer-radius: Double
   inner-radius: Double

defmethod print (o:OutputStream, s:Salinon) :
   print(o, "Salinon(%_, %_, outer-radius = %_, inner-radius = %_)" % [
      x(s), y(s), outer-radius(s), inner-radius(s)])

defmethod area (s:Salinon) :
   val r = outer-radius(s) + inner-radius(s)
   PI * r * r / 4.0
\end{lstlisting}

In \texttt{\frenchspacing shapes-main.stanza}
\begin{lstlisting}
defpackage shapes/main :
   import core
   import collections
   import shapes
   import greek-shapes

defn total-area (ss:Vector<Shape>) :
   var total = 0.0
   for s in ss do :
      total = total + area(s)
   total   

defn main () :
   val ss = Vector<Shape>()
   add(ss, Point(1.0, 1.0))
   add(ss, Circle(2.0, 2.0, 3.0))
   add(ss, Circle(3.0, 0.0, 1.0))
   add(ss, Salinon(0.0, 0.0, 10.0, 5.0))
   add(ss, Salinon(5.0, -1.0, 8.0, 7.0))
   println("Shapes:")
   println(ss)
   println("Total area = %_" % [total-area(ss)])

main()
\end{lstlisting}

\section{Default Methods}
Our current implementation of \texttt{\frenchspacing area} does not have a {\em default} method. This means that if we call \texttt{\frenchspacing area} with a shape that has no appropriate method, then the program will crash. Let's try this by commenting out the method for computing the areas of salinons and try running our program again.
\begin{lstlisting}
;defmethod area (s:Salinon) :
;   val r = outer-radius(s) + inner-radius(s)
;   PI * r * r / 4.0
\end{lstlisting}
It should print out
\begin{lstlisting}
Shapes:
[Point(1.000000000000000, 1.000000000000000)
 Circle(2.000000000000000, 2.000000000000000, radius = 3.000000000000000)
 Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)
 Salinon(0.000000000000000, 0.000000000000000,
         outer-radius = 10.000000000000000, inner-radius = 5.000000000000000)
 Salinon(5.000000000000000, -1.000000000000000,
         outer-radius = 8.000000000000000, inner-radius = 7.000000000000000)]
FATAL ERROR: No matching branch.
   at shapes.stanza:31.16
   at shapes-main.stanza:10.22
   at core/collections.stanza:182.15
   at core/core.stanza:4042.16
   at shapes-main.stanza:9.15
   at shapes-main.stanza:22.32
   at shapes-main.stanza:24.0
\end{lstlisting}

Let's instead provide a {\em default} method that is called when no other method matches. Add the following method to the \texttt{\frenchspacing shapes} package
\begin{lstlisting}
defmethod area (s:Shape) :
   println("No appropriate area method for %_." % [s])
   println("Returning 0.0.")
   0.0
\end{lstlisting}
and run the program again. It should now print out
\begin{lstlisting}
Shapes:
[Point(1.000000000000000, 1.000000000000000)
 Circle(2.000000000000000, 2.000000000000000, radius = 3.000000000000000)
 Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)
 Salinon(0.000000000000000, 0.000000000000000,
         outer-radius = 10.000000000000000, inner-radius = 5.000000000000000)
 Salinon(5.000000000000000, -1.000000000000000,
         outer-radius = 8.000000000000000, inner-radius = 7.000000000000000)]
No appropriate area method for
   Salinon(0.000000000000000, 0.000000000000000,
           outer-radius = 10.000000000000000, inner-radius = 5.000000000000000).
Returning 0.0.
No appropriate area method for
   Salinon(5.000000000000000, -1.000000000000000,
           outer-radius = 8.000000000000000, inner-radius = 7.000000000000000).
Returning 0.0.
Total area = 31.415926535897931
\end{lstlisting}

Default methods are often used to return a default value when no other method is appropriate. Another common use case for default methods is to provide a slow but general implementation of a certain function that works on any type in its domain, and then use methods to provide efficient implementations for specialized types. 

\section{Underneath the Hood}
To help you better understand how the multi and method system works, here is what is happening underneath the hood. When a Stanza program is compiled it searches through all the packages and gathers up all the methods defined for each multi. In our \texttt{\frenchspacing shapes} example, that gives us
\begin{lstlisting}
public defmulti area (s:Shape) -> Double
defmethod area (s:Shape) :
   println("No appropriate area method for %_." % [s])
   println("Returning 0.0.")
   0.0
defmethod area (p:Point) -> Double :
   0.0
defmethod area (c:Circle) :
   PI * radius(c) * radius(c)
defmethod area (r:Rectangle) :
   width(r) * height(r)
defmethod area (s:Salinon) :
   val r = outer-radius(s) + inner-radius(s)
   PI * r * r / 4.0
\end{lstlisting}
These methods are then {\em sorted} from most specific to least specific, and the multi is transformed into a single function with a match expression for selecting which method to call.
\begin{lstlisting}
public defn area (s:Shape) -> Double :
   match(s) :
      (p:Point) :
         0.0
      (c:Circle) :
         PI * radius(c) * radius(c)
      (r:Rectangle) :
         width(r) * height(r)
      (s:Salinon) :
         val r = outer-radius(s) + inner-radius(s)
         PI * r * r / 4.0
      (s:Shape) :
         println("No appropriate area method for %_." % [s])
         println("Returning 0.0.")
         0.0
\end{lstlisting}
Notice how the default method for \texttt{\frenchspacing Shape} is positioned as the last branch in the match expression as it is the least specific method. 

Thus this engine demonstrates that Stanza's multi and method system can simply be thought of as a way of writing match expressions but with its branches distributed across multiple packages.

\section{Intersection Types}

\subsection*{Multiple Parent Types}
Suppose we have a type called \texttt{\frenchspacing Rollable} with the following multi declared.
\begin{lstlisting}
deftype Rollable
defmulti roll-distance (r:Rollable) -> Double
\end{lstlisting}
\texttt{\frenchspacing roll-distance} computes the distance traveled by a \texttt{\frenchspacing Rollable} object in one revolution.

We now wish to make \texttt{\frenchspacing Circle} a subtype of \texttt{\frenchspacing Rollable} and provide it an appropriate method for \texttt{\frenchspacing roll-distance}, but \texttt{\frenchspacing Circle} is already declared to be a subtype of \texttt{\frenchspacing Shape}! The solution is to declare \texttt{\frenchspacing Circle} as both a subtype of \texttt{\frenchspacing Shape} {\em and} \texttt{\frenchspacing Rollable}. 
\begin{lstlisting}
public defstruct Circle <: Shape & Rollable :
   x: Double
   y: Double
   radius: Double
\end{lstlisting}
This is an example of using an {\em intersection type}. Now we can provide a method for \texttt{\frenchspacing roll-distance} on \texttt{\frenchspacing Circle} objects.
\begin{lstlisting}
defmethod roll-distance (c:Circle) :
   2.0 * PI * radius(c)
\end{lstlisting}
A circle rolls exactly the length of its diameter in one revolution.

Let's try it out!
\begin{lstlisting}
defn try-rolling () :
   val c = Circle(0.0, 0.0, 10.0)
   println("The circle %_ rolls %_ units in one revolution." % [c, roll-distance(c)])

try-rolling()
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
The circle Circle(0.000000000000000, 0.000000000000000,
                  radius = 10.000000000000000) 
rolls 62.831853071795862 units in one revolution.
\end{lstlisting}

\subsection*{Intersection Types as Arguments}
Let's suppose that we're about to make a pizza, and we need to choose the shape of its base. Additionally, we're experimenting with new pizza delivery methods, and would also like the pizza to be able to roll.

Here's the function that makes our pizza.
\begin{lstlisting}
defn make-pizza (base:Shape & Rollable) :
   println("Let's make a pizza!")
   println("The base will have shape %_." % [base])
   println("And it will have area %_." % [area(base)])
   println("Plus when we roll it, it travels %_ units!" % [roll-distance(base)])
\end{lstlisting}
Because we call \texttt{\frenchspacing area} on \texttt{\frenchspacing base} we know that the \texttt{\frenchspacing base} needs to be a type of \texttt{\frenchspacing Shape} object. But we also call \texttt{\frenchspacing roll-distance} on \texttt{\frenchspacing base}, and so \texttt{\frenchspacing base} will {\em also} have to be a type of \texttt{\frenchspacing Rollable} object. Thus \texttt{\frenchspacing base} is declared to be both \texttt{\frenchspacing Shape} and \texttt{\frenchspacing Rollable}.

Let's try it out!
\begin{lstlisting}
make-pizza(Circle(0.0, 0.0, 10.0))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
Let's make a pizza!
The base will have shape Circle(0.000000000000000, 0.000000000000000, 
                                radius = 10.000000000000000).
And it will have area 314.159265358979326.
Plus when we roll it, it travels 62.831853071795862 units!
\end{lstlisting}
So circular pizzas will be our first foray into rolling self-delivering pizzas!

The argument that \texttt{\frenchspacing make-pizza} requires needs to be both a \texttt{\frenchspacing Shape} and a \texttt{\frenchspacing Rollable}. We do have other shapes available that are not \texttt{\frenchspacing Rollable}. Here is what happens if we try to make a rectangular pizza for example.
\begin{lstlisting}
make-pizza(Rectangle(0.0, 0.0, 5.0, 3.0))
\end{lstlisting}
Attempting to compile the above gives us the following error.
\begin{lstlisting}
Cannot call function make-pizza of type Rollable&Shape -> False 
with arguments of type (Rectangle).
\end{lstlisting}
Thus Stanza correctly prevents us from attempting to make pizzas out of shapes that don't roll.

\section{The Flexibility of Functions}
In the beginning of the chapter we said that Stanza's class-less object system gives you flexibility you wouldn't have in a typical class based language. Here is a demonstration of that. 

The definition of the \texttt{\frenchspacing Circle} struct in the \texttt{\frenchspacing shapes} package defines circles using their x and y coordinates, and their radius. But what if, as a user, we don't like this convention and instead want to define circles given a \texttt{\frenchspacing Point} to represent their center, and their diameter? Stanza allows us to easily do that.

Here is \texttt{\frenchspacing shape-utils.stanza}, which contains a user defined package with his own utilities for managing shapes. 
\begin{lstlisting}
defpackage shape-utils :
   import core
   import shapes

public defn Circle (center:Point, diameter:Double) :
   Circle(x(center), y(center), diameter / 2.0)

public defn diameter (c:Circle) :
   radius(c) * 2.0

public defn center (c:Circle) :
   Point(x(c), y(c))
\end{lstlisting}
With this package, users can now use circles as if they were defined with a center point and a diameter instead of a pair of x, and y coordinates and a radius. Let's update our \texttt{\frenchspacing main} function to use this new convention.
\begin{lstlisting}
defpackage shapes/main :
   import core
   import collections
   import shapes
   import greek-shapes
   import shape-utils

...
   
defn main () :
   val ss = Vector<Shape>()
   add(ss, Point(1.0, 1.0))
   add(ss, Circle(Point(2.0, 2.0), 6.0))
   add(ss, Circle(Point(3.0, 0.0), 2.0))
   add(ss, Salinon(0.0, 0.0, 10.0, 5.0))
   add(ss, Salinon(5.0, -1.0, 8.0, 7.0))
   println("Shapes:")
   println(ss)
   println("Total area = %_" % [total-area(ss)])
\end{lstlisting}
Run the program to see that it continues to print out the same message as before.
\begin{lstlisting}
Shapes:
[Point(1.000000000000000, 1.000000000000000)
 Circle(2.000000000000000, 2.000000000000000, radius = 3.000000000000000)
 Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)
 Salinon(0.000000000000000, 0.000000000000000,
         outer-radius = 10.000000000000000, inner-radius = 5.000000000000000)
 Salinon(5.000000000000000, -1.000000000000000,
         outer-radius = 8.000000000000000, inner-radius = 7.000000000000000)]
Total area = 384.845100064749658
\end{lstlisting}

Note that the \texttt{\frenchspacing center} and \texttt{\frenchspacing diameter} functions in the \texttt{\frenchspacing shape-utils} package are no less "special" or "fundamental" than the \texttt{\frenchspacing x}, \texttt{\frenchspacing y}, and \texttt{\frenchspacing radius} functions in the \texttt{\frenchspacing shapes} package. Users can use whichever representation they prefer. Most importantly, adding this functionality did not require the user to communicate with the authors of the \texttt{\frenchspacing shapes} package at all. 

We can similarly add support for a new representation of rectangles. Currently, a rectangle is represented using the x, and y coordinates of its bottom-left corner and its width and height. Let's add support for representing rectangles given its bottom-left point and its top-right point.
\begin{lstlisting}
public defn Rectangle (bottom-left:Point, top-right:Point) :
   val w = x(top-right) - x(bottom-left)
   val h = y(top-right) - y(bottom-left)
   if (w < 0.0) or (h < 0.0) : fatal("Illegal Rectangle!")
   Rectangle(x(bottom-left), y(bottom-left), w, h)
   
public defn bottom-left (r:Rectangle) :
   Point(x(r), y(r))

public defn top-right (r:Rectangle) :
   Point(x(r) + width(r), y(r) + height(r))
\end{lstlisting}
Again, the \texttt{\frenchspacing bottom-left} and \texttt{\frenchspacing top-right} functions in the \texttt{\frenchspacing shape-utils} package are no less "fundamental" than the \texttt{\frenchspacing x}, \texttt{\frenchspacing y}, \texttt{\frenchspacing width}, and \texttt{\frenchspacing height} functions in the \texttt{\frenchspacing shapes} package.

\section{Fundamental and Derived Operations}
{\em Things} in your program are modeled using {\em types} in Stanza. Anything than can be {\em done} using a type is implemented as a function (or multi). These operations are further categorized into {\em fundamental} and {\em derived} operations. 

The \texttt{\frenchspacing area} function for \texttt{\frenchspacing Shape} objects is an example of a fundamental operation. At least in our \texttt{\frenchspacing shapes} package, a shape is {\em defined} by its property of having an area. In fact, the {\em only} thing that all shapes have in common is that you can compute their area. And when defining a new type of shape, users {\em must} also define an appropriate method for \texttt{\frenchspacing area}. 

Here is an example of a {\em derived} operation on shapes.
\begin{lstlisting}
public defn sort-by-area (xs:Array<Shape>) :
   var sorted? = false
   while not sorted? :
      sorted? = true
      for i in 0 to (length(xs) - 1) do :
         if area(xs[i + 1]) < area(xs[i]) :
            val a = xs[i]
            val b = xs[i + 1]
            xs[i] = b
            xs[i + 1] = a
            sorted? = false      
\end{lstlisting}
This operation allows you to sort an array of shapes by increasing area. By reading its definition, you can see that it will work on {\em all} shapes, because the only operation it requires is the ability to call \texttt{\frenchspacing area}. A derived operation is a function implemented in terms of a type's fundamental operations. 

When defining a new subtype of an existing type, users must implement a small set of fundamental operations to ensure correct operation of their subtype. In the core library documentation, this set is called the {\em mandatory minimal implementation}. 

The typical architecture of a Stanza program is to define a {\em small} number of fundamental operations for each type, coupled with a {\em large} library of derived operations. Structuring your program in this way gives you the most flexibility and extensibility. Adding new derived operations is as simple as defining a new function and is very easy. Defining new types is also easy as their mandatory minimal implementations are small.

\section{Multiple Dispatch}
The \texttt{\frenchspacing area} multi in the \texttt{\frenchspacing shapes} package accepts only a single argument, and at runtime it {\em dispatches} to the appropriate method depending on the type of the argument. Stanza places no restriction on the number of arguments that a multi can take, so users can write multis that dispatches to the appropriate method depending on the types of {\em multiple} arguments. This feature is called {\em multiple dispatch}. 

We will demonstrate the power of multiple dispatch by writing an {\em overlaps?} function that decides whether two shapes are overlapping. Here is the definition of the multi.
\begin{lstlisting}
public defmulti overlaps? (a:Shape, b:Shape) -> True|False
\end{lstlisting}
It returns \texttt{\frenchspacing true} if the shape \texttt{\frenchspacing a} overlaps with shape \texttt{\frenchspacing b}, or \texttt{\frenchspacing false} otherwise.

Points have zero area, so two points overlap only if they are exactly equal to each other. 
\begin{lstlisting}
defmethod overlaps? (a:Point, b:Point) :
   (x(a) == x(b)) and (y(a) == y(b))
\end{lstlisting}

A circle overlaps with a point if the distance between the point and the center of the circle is less than or equal to the radius of the circle.
\begin{lstlisting}
defmethod overlaps? (a:Point, b:Circle) :
   val dx = x(b) - x(a)
   val dy = y(b) - y(a)
   val r = radius(b)
   dx * dx + dy * dy <= r * r
\end{lstlisting}

Stanza makes no assumption that \texttt{\frenchspacing overlaps?} is commutative. So we explicitly tell Stanza that a circle overlaps with a point if the point overlaps with the circle.
\begin{lstlisting}
defmethod overlaps? (a:Circle, b:Point) :
   overlaps?(b, a)
\end{lstlisting}

Finally, two circles overlap if the center of circle \texttt{\frenchspacing a} overlaps with a circle with the same center as circle \texttt{\frenchspacing b} but with radius equal to the sum of both circles.
\begin{lstlisting}
defmethod overlaps? (a:Circle, b:Circle) :
   overlaps?(Point(x(a), y(a)), Circle(x(b), y(b), radius(b) + radius(a)))
\end{lstlisting}

With these definitions, \texttt{\frenchspacing overlaps?} completely handles points and circles. Let's try it out.
\begin{lstlisting}
defn test-overlap (a:Shape, b:Shape) :
   println(a)
   if overlaps?(a, b) : println("overlaps with")
   else : println("does not overlap with")
   println(b)
   print("\n")
   
defn try-overlaps () :
   val pt-a = Point(0.0, 0.0)
   val pt-b = Point(0.0, 3.0)
   val circ-a = Circle(0.0, 3.0, 1.0)
   val circ-b = Circle(3.0, 0.0, 1.0)
   val circ-c = Circle(0.0, 0.0, 3.0)
   test-overlap(pt-a, pt-b)
   test-overlap(circ-a, circ-b)
   test-overlap(pt-b, circ-b)
   test-overlap(circ-a, pt-b)
   test-overlap(circ-c, circ-a)

try-overlaps()
\end{lstlisting}
The above prints out
\begin{lstlisting}
Point(0.000000000000000, 0.000000000000000)
does not overlap with
Point(0.000000000000000, 3.000000000000000)

Circle(0.000000000000000, 3.000000000000000, radius = 1.000000000000000)
does not overlap with
Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)

Point(0.000000000000000, 3.000000000000000)
does not overlap with
Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)

Circle(0.000000000000000, 3.000000000000000, radius = 1.000000000000000)
overlaps with
Point(0.000000000000000, 3.000000000000000)

Circle(0.000000000000000, 0.000000000000000, radius = 3.000000000000000)
overlaps with
Circle(0.000000000000000, 3.000000000000000, radius = 1.000000000000000)
\end{lstlisting}

As an exercise, you may try to implement the rest of the methods required for \texttt{\frenchspacing overlaps?} to also work on rectangles. The brave and adventurous amongst you can try supporting salinons as well.

\section{Ambiguous Methods}
A multi dispatches to the most {\em specific} method appropriate for the types of the arguments. However, there are sometimes multiple methods that are equally specific, and it is ambiguous which method should be called. 

As an example, consider the very strange shape, the \texttt{\frenchspacing Blob}. The blob has the very strange property that {\em it} overlaps with no shape, but {\em every} shape overlaps with {\em it}. 
\begin{lstlisting}
defstruct Blob <: Shape
defmethod print (o:OutputStream, b:Blob) : print(o, "Amorphous Blob")
defmethod overlaps? (a:Blob, b:Shape) : false
defmethod overlaps? (a:Shape, b:Blob) : true
\end{lstlisting}
Let's try it out.
\begin{lstlisting}
defn try-overlaps () :
   val pt-a = Point(0.0, 0.0)
   val pt-b = Point(0.0, 3.0)
   val circ-a = Circle(0.0, 3.0, 1.0)
   val circ-b = Circle(3.0, 0.0, 1.0)
   val circ-c = Circle(0.0, 0.0, 3.0)
   val blob = Blob()
   test-overlap(pt-a, blob)
   test-overlap(circ-a, blob)
   test-overlap(blob, pt-b)
   test-overlap(blob, circ-b)
\end{lstlisting}
The program prints out
\begin{lstlisting}
Point(0.000000000000000, 0.000000000000000)
overlaps with
Amorphous Blob

Circle(0.000000000000000, 3.000000000000000, radius = 1.000000000000000)
overlaps with
Amorphous Blob

Amorphous Blob
does not overlap with
Point(0.000000000000000, 3.000000000000000)

Amorphous Blob
does not overlap with
Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)
\end{lstlisting}

But the real question is: does a blob overlap with a blob? Let's see.
\begin{lstlisting}
defn try-overlaps () :
   val pt-a = Point(0.0, 0.0)
   val pt-b = Point(0.0, 3.0)
   val circ-a = Circle(0.0, 3.0, 1.0)
   val circ-b = Circle(3.0, 0.0, 1.0)
   val circ-c = Circle(0.0, 0.0, 3.0)
   val blob = Blob()
   test-overlap(pt-a, blob)
   test-overlap(circ-a, blob)
   test-overlap(blob, pt-b)
   test-overlap(blob, circ-b)
   test-overlap(blob, blob)
\end{lstlisting}
prints out
\begin{lstlisting}
Point(0.000000000000000, 0.000000000000000)
overlaps with
Amorphous Blob

Circle(0.000000000000000, 3.000000000000000, radius = 1.000000000000000)
overlaps with
Amorphous Blob

Amorphous Blob
does not overlap with
Point(0.000000000000000, 3.000000000000000)

Amorphous Blob
does not overlap with
Circle(3.000000000000000, 0.000000000000000, radius = 1.000000000000000)

Amorphous Blob
FATAL ERROR: Ambiguous branch.
   at shapes.stanza:47.16
   at shapes.stanza:71.6
   at shapes.stanza:87.3
   at shapes.stanza:89.0
\end{lstlisting}

Stanza is telling us that there are multiple \texttt{\frenchspacing overlaps?} methods that are equally specific for arguments of type \texttt{\frenchspacing Blob} and \texttt{\frenchspacing Blob}, and it does not know which one to call. To resolve this, users would have to define an \texttt{\frenchspacing overlaps?} method specifically comparing \texttt{\frenchspacing Blob} against \texttt{\frenchspacing Blob}.

\section{Revisiting Print}

Now that you've been introduced to multis and methods, we can remove some of the mysteries surrounding the \texttt{\frenchspacing print} function. So far, you've been told to follow a specific pattern to provide custom printing behaviour for your custom structs. For example, here is the print method defined for circles.
\begin{lstlisting}
defmethod print (o:OutputStream, c:Circle) :
   print(o, "Circle(%_, %_, radius = %_)" % [x(c), y(c), radius(c)])
\end{lstlisting}

But now you can see that it is simply attaching a new method to a multi called \texttt{\frenchspacing print}. The \texttt{\frenchspacing print} multi is defined in the \texttt{\frenchspacing core} package
\begin{lstlisting}
defmulti print (o:OutputStream, x) -> False
\end{lstlisting}
and takes two arguments. The first is an \texttt{\frenchspacing OutputStream} object that represents the {\em target} that you're printing to. The most common target is the standard output stream, i.e. the user's terminal. The second argument is the object that you're printing. 

Thus far, you've only provided \texttt{\frenchspacing print} methods for more specific types of \texttt{\frenchspacing x} in order to print different types of objects. But later, you'll see how you can provide \texttt{\frenchspacing print} methods for more specific types of \texttt{\frenchspacing o} in order to print to different targets. And all of this works seamlessly due to the power of multiple dispatch.

\section{The New Expression}
The new expression is Stanza's fundamental construct for creating objects. All objects in Stanza are either literals (e.g. 1, 'x', "Timon"), or are created (directly or indirectly) by the new expression. 

Let's define a type called \texttt{\frenchspacing Stack} that represents a stack into which we can push and pop strings. Start a new file called \texttt{\frenchspacing stack.stanza}. Here's the type definition for \texttt{\frenchspacing Stack} and also two multis for the push and pop operations to which we will later attach methods, and a third multi for checking whether the stack is empty.
\begin{lstlisting}
deftype Stack
defmulti push (s:Stack, x:String) -> False
defmulti pop (s:Stack) -> String
defmulti empty? (s:Stack) -> True|False
\end{lstlisting}

Let's provide it with custom printing behaviour.
\begin{lstlisting}
defmethod print (o:OutputStream, s:Stack) :
   print(o, "Stack")
\end{lstlisting}

Now in our main function we will create a single \texttt{\frenchspacing Stack} object and print it out.
\begin{lstlisting}
defn main () :
   val s = new Stack
   println("s is a %_." % [s])

main()
\end{lstlisting}

Compile the program and run it. It should print out
\begin{lstlisting}
s is a Stack.
\end{lstlisting}

Thus the expression
\begin{lstlisting}
new Stack
\end{lstlisting}
creates a new \texttt{\frenchspacing Stack} object. We say that it creates a new {\em instance} of type \texttt{\frenchspacing Stack}. 

But this stack object thus far isn't terribly useful. The only thing it can do is print itself. Stanza does allow us to call \texttt{\frenchspacing push} and \texttt{\frenchspacing pop} on the stack, but it will just crash because we haven't attached any methods yet. 

\subsection*{Instance Methods}
The new expression allows us to define {\em instance} methods for the object being created. Here is an instance method for the \texttt{\frenchspacing empty?} multi for the stack being created.
\begin{lstlisting}
defn main () :
   val s = new Stack :
      defmethod empty? (this) :
         true
   println("s is a %_." % [s])
   println("stack is empty? %_." % [empty?(s)])

main()
\end{lstlisting}
We haven't defined any methods for pushing strings to the stack yet, so the \texttt{\frenchspacing empty?} method simply returns \texttt{\frenchspacing true} for now. Compile the program and run it. It should print out
\begin{lstlisting}
s is a Stack.
stack is empty? true.
\end{lstlisting}

The instance method declaration looks similar to the standard method declarations that you've already learned except for one major difference. The {\em this} argument is very special. In an instance method declaration, \texttt{\frenchspacing this} refers specifically to the object currently being created by new. In this case, the object being created is \texttt{\frenchspacing s}. So the instance method is saying: if \texttt{\frenchspacing empty?} is called on \texttt{\frenchspacing s} then return \texttt{\frenchspacing true}. Every instance method must have exactly one argument named \texttt{\frenchspacing this}.

In fact, now that we've learned about instance methods, let's redefine the \texttt{\frenchspacing print} method as an instance method for \texttt{\frenchspacing s}. Delete the top-level print method, and add the following.
\begin{lstlisting}
defn main () :
   val s = new Stack :
      defmethod empty? (this) :
         true
      defmethod print (o:OutputStream, this) :
         print(o, "Stack")
   println("s is a %_." % [s])
   println("stack is empty? %_." % [empty?(s)])

main()
\end{lstlisting}
Compile and run the program and verify that it prints the same message as before.

\subsection*{The Push and Pop Methods}
We will now define the methods for \texttt{\frenchspacing push} and \texttt{\frenchspacing pop}. The stack contents will be held in an array, and we'll keep track of how many items are currently in the stack using a \texttt{\frenchspacing size} variable. The array will be of length 10, so the maximum number of strings that the stack can hold is 10. Declare the following {\em within} the \texttt{\frenchspacing main} function.
\begin{lstlisting}
val items = Array<String>(10)
var size = 0
\end{lstlisting}

Next we'll declare the \texttt{\frenchspacing push} method. Declare the following within the new expression.
\begin{lstlisting}
defmethod push (this, x:String) :
   if size == 10 : fatal("Stack is full!")
   items[size] = x
   size = size + 1
\end{lstlisting}
The \texttt{\frenchspacing push} method first ensures that the stack is not full. Then it stores \texttt{\frenchspacing x} in the next slot in the array and increments the stack's size by one.

Here's the corresponding \texttt{\frenchspacing pop} method.
\begin{lstlisting}
defmethod pop (this) :
   if size == 0 : fatal("Stack is empty!")
   size = size - 1
   items[size]
\end{lstlisting}
The \texttt{\frenchspacing pop} method first ensures that the stack is not empty. Then it decrements the stack's size by one, and returns the top item in the stack.

Here's the revised \texttt{\frenchspacing empty?} method.
\begin{lstlisting}
defmethod empty? (this) :
   size == 0
\end{lstlisting}
The stack is empty if its size is zero.

And finally, here's the revised \texttt{\frenchspacing print} method.
\begin{lstlisting}
defmethod print (o:OutputStream, this) :
   print(o, "Stack containing [")
   for i in 0 to size do :
      print(o, items[i])
      if i < size - 1 :
         print(o, " ")
   print(o, "]")   
\end{lstlisting}
It iterates through and prints all the strings currently in the stack.

Putting all the pieces together gives us the following \texttt{\frenchspacing main} function. To test the stack, we try pushing and popping a few strings.
\begin{lstlisting}
defn main () :
   val items = Array<String>(10)
   var size = 0
   val s = new Stack :
      defmethod push (this, x:String) :
         if size == 10 : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         for i in 0 to size do :
            print(o, items[i])
            if i < size - 1 :
               print(o, " ")
         print(o, "]")   

   println("1.")
   println(s)

   println("2.")   
   push(s, "Pumbaa")
   println(s)
   
   println("3.")   
   push(s, "and")
   push(s, "Timon")
   println(s)
   
   println("4.")   
   val x = pop(s)
   println("Popped %_ from stack." % [x])
   println(s)

   println("5.")
   val y = pop(s)
   println("Popped %_ from stack." % [y])
   println(s)

main()   
\end{lstlisting}
Compile and run the program. It should print out
\begin{lstlisting}
1.
Stack containing []
2.
Stack containing [Pumbaa]
3.
Stack containing [Pumbaa and Timon]
4.
Popped Timon from stack.
Stack containing [Pumbaa and]
5.
Popped and from stack.
Stack containing [Pumbaa]
\end{lstlisting}

\section{Constructor Functions}
In the above example, we created a stack called \texttt{\frenchspacing s} directly in the \texttt{\frenchspacing main} function. You may be thinking that this seems like a lot of work to create a single stack! What if we need to create multiple stacks? 

The solution is to simply move the stack construction code into a new function and call it once for each stack we want to create. Here is a function called \texttt{\frenchspacing make-stack} that accepts a \texttt{\frenchspacing capacity} argument for specifying the maximum size supported by the stack.
\begin{lstlisting}
defn make-stack (capacity:Int) -> Stack :
   val items = Array<String>(capacity)
   var size = 0
   new Stack :
      defmethod push (this, x:String) :
         if size == capacity : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         for i in 0 to size do :
            print(o, items[i])
            if i < size - 1 :
               print(o, " ")
         print(o, "]")   
\end{lstlisting}

Let's change our main function to create two stacks and push different strings into them.
\begin{lstlisting}
defn main () :
   val s1 = make-stack(10)
   val s2 = make-stack(10)

   println("1.")
   push(s1, "Timon")
   push(s1, "Pumbaa")
   push(s1, "Nala")
   push(s2, "Ryu")
   push(s2, "Ken")
   push(s2, "Makoto")
   println(s1)
   println(s2)

   println("2.")
   println("Popped %_ from s1." % [pop(s1)])
   println("Popped %_ from s2." % [pop(s2)])
   println(s1)
   println(s2)

   println("3.")
   println("Popped %_ from s1." % [pop(s1)])
   println("Popped %_ from s2." % [pop(s2)])
   println(s1)
   println(s2)

main()   
\end{lstlisting}

Compile and run the program. It should print out
\begin{lstlisting}
1.
Stack containing [Timon Pumbaa Nala]
Stack containing [Ryu Ken Makoto]
2.
Popped Nala from s1.
Popped Makoto from s2.
Stack containing [Timon Pumbaa]
Stack containing [Ryu Ken]
3.
Popped Pumbaa from s1.
Popped Ken from s2.
Stack containing [Timon]
Stack containing [Ryu]
\end{lstlisting}
Notice especially that the two stacks created by the separate calls to \texttt{\frenchspacing make-stack} contain different strings and operate independently of each other. 

We call \texttt{\frenchspacing make-stack} a {\em constructor} function for \texttt{\frenchspacing Stack} objects because it returns newly created \texttt{\frenchspacing Stack} objects. If you are familiar with the object systems in other languages it might surprise you to see that there is nothing particularly special about constructor functions in Stanza. They're just regular functions. This lack of distinction between constructors and functions is another contributing factor to Stanza's flexibility. Constructors in class based languages are typically more "special" than regular functions, and while any user can define functions for a class, only the library's author can define more constructors for a class.

As a note on style, we named the constructor function for \texttt{\frenchspacing Stack} objects \texttt{\frenchspacing make-stack} in order to avoid confusing you. But the idiomatic Stanza style is to give the same name to the constructor function as the type of object it is constructing. So \texttt{\frenchspacing make-stack} would simply be named \texttt{\frenchspacing Stack}, and you will distinguish based on context whether a reference to \texttt{\frenchspacing Stack} refers to the type or the function.

As a reminder, even with the \texttt{\frenchspacing new} expression, you are still encouraged to keep the number of fundamental operations for a type small, and then implement as much functionality as derived operations as possible.

As an exercise, try implementing a function called \texttt{\frenchspacing UnboundedStack} that constructs a \texttt{\frenchspacing Stack} object with no maximum capacity. Then try it in place of \texttt{\frenchspacing Stack}, and observe that there is no behavioural difference (save for capacity limitations) between stacks created with \texttt{\frenchspacing UnboundedStack} and stacks created with \texttt{\frenchspacing Stack}. 

\section{Revisiting Defstruct}
\texttt{\frenchspacing defmulti}, \texttt{\frenchspacing defmethod}, \texttt{\frenchspacing deftype} and \texttt{\frenchspacing new} forms the fundamental constructs of Stanza's class-less object system. The \texttt{\frenchspacing defstruct} construct that you have been using thus far is merely a syntactic shorthand for a specific usage pattern of \texttt{\frenchspacing new}. Let's take a peek at its internals.

Here is a struct definition for a \texttt{\frenchspacing Dog} object with a name field and a mutable breed field. 
\begin{lstlisting}
defstruct Dog <: Animal :
   name: String
   breed: String with: (setter => set-breed)
\end{lstlisting}

The above can be equivalently written as
\begin{lstlisting}
deftype Dog <: Animal
defmulti name (d:Dog) -> String
defmulti breed (d:Dog) -> String
defmulti set-breed (d:Dog, breed:String) -> False

defn Dog (name:String, initial-breed:String) -> Dog :
   var breed = initial-breed
   new Dog :
      defmethod name (this) : name
      defmethod breed (this) : breed
      defmethod set-breed (this, b:String) : breed = b
\end{lstlisting}
Thus, the \texttt{\frenchspacing defstruct} construct expands to
\begin{enumerate}
\item a type definition,
\item getter functions for each of its fields,
\item setter functions for each of its mutable fields, and
\item a constructor function for creating instances of the type.
\end{enumerate}

\chapter{Programming with First-Class Functions}
Stanza fully supports and encourages functional programming, however "Functional Programming" is intentionally not the title of this chapter. In the community, the term functional programming has been used to refer to two different concepts. The first is the concept of programming with {\em first-class} functions, where functions themselves are passed as arguments and stored in datastructures. This is the subject of this chapter. 

The second concept refers to a style of programming revolving around the mathematical definition of functions; so called {\em pure} functions. A pure function is guaranteed to return the same result if called with the same arguments, and also not affect the environment in any way (e.g. by printing to the terminal). This style of programming is largely an exercise in manipulating immutable datastructures. It is also a powerful paradigm and will be the subject of a later chapter. 

\section{Nested Functions}
As a gentle introduction to first-class functions we will start with {\em nested} functions. We hope the concept will seem straightforward, and then later we'll reveal that they are actually quite sophisticated underneath.

Here is a function that sorts an array of integers in increasing order.
\begin{lstlisting}
defn selection-sort (xs:Array<Int>) :
   val n = length(xs)
   for i in 0 to (n - 1) do :
      var min-idx = i
      var min-val = xs[i]
      for j in (i + 1) to n do :
         if xs[j] < min-val :
            min-idx = j
            min-val = xs[j]
      if i != min-idx :
         xs[min-idx] = xs[i]
         xs[i] = min-val
\end{lstlisting}
Let's try it out on an array of random numbers.
\begin{lstlisting}
defn main () :
   val xs = Array<Int>(10)
   xs[0] = 510
   xs[1] = 923
   xs[2] = 671
   xs[3] = 811
   xs[4] = -129
   xs[5] = -581
   xs[6] = 233
   xs[7] = -791
   xs[8] = 899
   xs[9] = 313

   selection-sort(xs)
   println(xs)

main()
\end{lstlisting}
It should print out
\begin{lstlisting}
[-791 -581 -129 233 313 510 671 811 899 923]
\end{lstlisting}

By reading through the algorithm, you can see that the larger problem of sorting the array is actually composed of a number of smaller subproblems. For example, the lines
\begin{lstlisting}
var min-idx = i
var min-val = xs[i]
for j in (i + 1) to n do :
   if xs[j] < min-val :
      min-idx = j
      min-val = xs[j]
\end{lstlisting}
compute the index of the minimum element between index \texttt{\frenchspacing i + 1} and index \texttt{\frenchspacing n}. The lines
\begin{lstlisting}
if i != min-idx :
   xs[min-idx] = xs[i]
   xs[i] = min-val
\end{lstlisting}
swaps the element at index \texttt{\frenchspacing i} with the element at index \texttt{\frenchspacing min-idx}. \texttt{\frenchspacing selection-sort} is short enough that we can still understand the main algorithm even without explicitly dividing the problem into smaller ones. But as programs get larger, the ability to break up a larger problem into smaller ones is very important. Nested functions gives us a lot of power for doing this. 

Let's define a {\em nested} function, \texttt{\frenchspacing index-of-min}, that takes two indices \texttt{\frenchspacing start} and \texttt{\frenchspacing end}, and returns the index of the minimum element between indices \texttt{\frenchspacing start} (inclusive) and \texttt{\frenchspacing end} (exclusive).
\begin{lstlisting}
defn index-of-min (start:Int, end:Int) :
   var min-idx = start
   var min-val = xs[start]
   for i in (start + 1) to end do :
      if xs[i] < min-val :
         min-idx = i
         min-val = xs[i]
   min-idx      
\end{lstlisting}

Let's define another nested function, \texttt{\frenchspacing swap}, that swaps the element in index \texttt{\frenchspacing i} with the element in index \texttt{\frenchspacing j}. 
\begin{lstlisting}
defn swap (i:Int, j:Int) :
   if i != j :
      val xs-i = xs[i]
      val xs-j = xs[j]
      xs[i] = xs-j
      xs[j] = xs-i
\end{lstlisting}

And now let's clean up our \texttt{\frenchspacing selection-sort} function using these nested functions.
\begin{lstlisting}
defn selection-sort (xs:Array<Int>) :
   defn index-of-min (start:Int, end:Int) :
      var min-idx = start
      var min-val = xs[start]
      for i in (start + 1) to end do :
         if xs[i] < min-val :
            min-idx = i
            min-val = xs[i]
      min-idx

   defn swap (i:Int, j:Int) :
      if i != j :
         val xs-i = xs[i]
         val xs-j = xs[j]
         xs[i] = xs-j
         xs[j] = xs-i
   
   val n = length(xs)
   for i in 0 to (n - 1) do :
      swap(i, index-of-min(i, n))
\end{lstlisting}
The code is slightly longer than before, but the {\em overall} algorithm is {\em much} clearer now. 
\begin{lstlisting}
for i in 0 to (n - 1) do :
   swap(i, index-of-min(i, n))
\end{lstlisting}
In English, it says: iterate with index \texttt{\frenchspacing i} starting from 0 and proceeding to the end of the array, and swap the element at \texttt{\frenchspacing i} with the minimum element in the rest of the array. 

Notice that the nested functions \texttt{\frenchspacing index-of-min} and \texttt{\frenchspacing swap} are not merely functions declared within the body of \texttt{\frenchspacing selection-sort}. If you tried to declare them as top-level functions, the program would give you this error when you try to compile it,
\begin{lstlisting}
Could not resolve xs.
\end{lstlisting}
indicating that \texttt{\frenchspacing xs} is not in scope and is not visible to \texttt{\frenchspacing index-of-min} or \texttt{\frenchspacing swap}. Part of the power of nested functions rests in them being able to refer to values defined in the function they're nested in.

\subsection*{Example: Permutations}
Here is another example of using nested functions to greatly simplify code. The \texttt{\frenchspacing permutations} function accepts an array of strings and prints out all possible permutations of its contents. 
\begin{lstlisting}
defn permutations (xs:Array<String>) :
   val n = length(xs)
   
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi
      
   defn permute (i:Int) :
      if i < n - 1 :
         for j in i to n do :
            swap(i, j)
            permute(i + 1)
            swap(i, j)
      else :
         println(xs)

   permute(0)
\end{lstlisting}
It internally relies upon the nested functions \texttt{\frenchspacing swap} and \texttt{\frenchspacing permute}. 

Let's try it out with these strings.
\begin{lstlisting}
defn main () :
   val xs = to-array<String>(["All" "Dogs" "Are" "Awesome"])
   permutations(xs)

main()
\end{lstlisting}

When compiled and ran, it prints out
\begin{lstlisting}
["All" "Dogs" "Are" "Awesome"]
["All" "Dogs" "Awesome" "Are"]
["All" "Are" "Dogs" "Awesome"]
["All" "Are" "Awesome" "Dogs"]
["All" "Awesome" "Are" "Dogs"]
["All" "Awesome" "Dogs" "Are"]
["Dogs" "All" "Are" "Awesome"]
["Dogs" "All" "Awesome" "Are"]
["Dogs" "Are" "All" "Awesome"]
["Dogs" "Are" "Awesome" "All"]
["Dogs" "Awesome" "Are" "All"]
["Dogs" "Awesome" "All" "Are"]
["Are" "Dogs" "All" "Awesome"]
["Are" "Dogs" "Awesome" "All"]
["Are" "All" "Dogs" "Awesome"]
["Are" "All" "Awesome" "Dogs"]
["Are" "Awesome" "All" "Dogs"]
["Are" "Awesome" "Dogs" "All"]
["Awesome" "Dogs" "Are" "All"]
["Awesome" "Dogs" "All" "Are"]
["Awesome" "Are" "Dogs" "All"]
["Awesome" "Are" "All" "Dogs"]
["Awesome" "All" "Are" "Dogs"]
["Awesome" "All" "Dogs" "Are"]
\end{lstlisting}

As an exercise, try writing a function called \texttt{\frenchspacing combinations} that prints out all {\em combinations} of an array of strings instead of all {\em permutations}. 

\section{Functions as Arguments}
The \texttt{\frenchspacing selection-sort} function in the previous example sorted the array in increasing order. But there are many ways to sort an array of integers. The following \texttt{\frenchspacing sort-by-abs} function sorts the array by their {\em absolute} values. 
\begin{lstlisting}
defn sort-by-abs (xs:Array<Int>) :
   defn index-of-min (start:Int, end:Int) :
      var min-idx = start
      var min-val = xs[start]
      for i in (start + 1) to end do :
         if abs(xs[i]) < abs(min-val) :
            min-idx = i
            min-val = xs[i]
      min-idx

   defn swap (i:Int, j:Int) :
      if i != j :
         val xs-i = xs[i]
         val xs-j = xs[j]
         xs[i] = xs-j
         xs[j] = xs-i
   
   val n = length(xs)
   for i in 0 to (n - 1) do :
      swap(i, index-of-min(i, n))
\end{lstlisting}
If you replace the call to \texttt{\frenchspacing selection-sort} in the \texttt{\frenchspacing main} function with \texttt{\frenchspacing sort-by-abs} then it now prints out
\begin{lstlisting}
[-129 233 313 510 -581 671 -791 811 899 923]
\end{lstlisting}

Here is yet another way of sorting an array. The following \texttt{\frenchspacing sort-by-sum-of-digits} function sorts the array by the total sum of their individual digits.
\begin{lstlisting}
defn sum-of-digits (n:Int) :
   if n == 0 : 0
   else if n < 0 : sum-of-digits((- n))
   else : (n % 10) + sum-of-digits(n / 10)

defn sort-by-sum-of-digits (xs:Array<Int>) :
   defn index-of-min (start:Int, end:Int) :
      var min-idx = start
      var min-val = xs[start]
      for i in (start + 1) to end do :
         if sum-of-digits(xs[i]) < sum-of-digits(min-val) :
            min-idx = i
            min-val = xs[i]
      min-idx

   defn swap (i:Int, j:Int) :
      if i != j :
         val xs-i = xs[i]
         val xs-j = xs[j]
         xs[i] = xs-j
         xs[j] = xs-i
   
   val n = length(xs)
   for i in 0 to (n - 1) do :
      swap(i, index-of-min(i, n))
\end{lstlisting}
Replacing the call to \texttt{\frenchspacing selection-sort} with \texttt{\frenchspacing sort-by-sum-of-digits} prints out
\begin{lstlisting}
[510 313 233 811 -129 671 -581 923 -791 899]
\end{lstlisting}

You'll have noticed by now that the implementation of each sorting function is almost entirely identical except for one line. Here are the three different comparison functions.
\begin{lstlisting}
;Compare value directly
xs[i] < min-val

;Compare absolute values
abs(xs[i]) < abs(min-val)

;Compare the sum of their digits
sum-of-digits(xs[i]) < sum-of-digits(min-val)
\end{lstlisting}
Couldn't we somehow write a general sort function and give it a specific way to compare things? We can! And the solution is to accept a {\em key} function that, for each item in the array, computes the value you wish to sort by.

Here is the general sorting function, \texttt{\frenchspacing sort-by}, that accepts a key function \texttt{\frenchspacing key}.
\begin{lstlisting}
defn sort-by (key:Int -> Int, xs:Array<Int>) :
   defn index-of-min (start:Int, end:Int) :
      var min-idx = start
      var min-val = xs[start]
      for i in (start + 1) to end do :
         if key(xs[i]) < key(min-val) :
            min-idx = i
            min-val = xs[i]
      min-idx

   defn swap (i:Int, j:Int) :
      if i != j :
         val xs-i = xs[i]
         val xs-j = xs[j]
         xs[i] = xs-j
         xs[j] = xs-i
   
   val n = length(xs)
   for i in 0 to (n - 1) do :
      swap(i, index-of-min(i, n))
\end{lstlisting}
Notice especially the type of the \texttt{\frenchspacing key} argument.
\begin{lstlisting}
Int -> Int
\end{lstlisting}
This says that \texttt{\frenchspacing key} is a {\em function} that accepts a single argument, an \texttt{\frenchspacing Int}, and returns an \texttt{\frenchspacing Int}.

We can update our \texttt{\frenchspacing main} function to sort the array in three different ways by using three different key functions.
\begin{lstlisting}
defn identity (x:Int) : x
   
defn main () :
   val xs = Array<Int>(10)
   xs[0] = 510
   xs[1] = 923
   xs[2] = 671
   xs[3] = 811
   xs[4] = -129
   xs[5] = -581
   xs[6] = 233
   xs[7] = -791
   xs[8] = 899
   xs[9] = 313

   println("Sort by value directly.")
   sort-by(identity, xs)
   println(xs)

   println("Sort by absolute value.")
   sort-by(abs, xs)
   println(xs)

   println("Sort by sum of digits.")
   sort-by(sum-of-digits, xs)
   println(xs)
   
main()
\end{lstlisting}

Compiling and running the program prints out
\begin{lstlisting}
Sort by value directly.
[-791 -581 -129 233 313 510 671 811 899 923]
Sort by absolute value.
[-129 233 313 510 -581 671 -791 811 899 923]
Sort by sum of digits.
[510 313 233 811 -129 671 -581 923 -791 899]
\end{lstlisting} 

Up until now, we have always referred to a function in {\em function call position}. For example,
\begin{lstlisting}
abs( ... )
sum-of-digits( ... )
\end{lstlisting}
But now you see that you can actually refer to functions directly as values to be passed to other functions!
\begin{lstlisting}
sort-by(abs, xs)
sort-by(sum-of-digits, xs)
\end{lstlisting}

Functions that take functions as arguments are called {\em higher-order functions}. They are an {\em extremely} powerful programming technique, and you'll soon see that you've already been using them everywhere without knowing it. 

\section{Functions as Return Values}
When a language has {\em first-class} functions, it means that functions can be treated as values. In the previous section we saw how to pass functions as arguments. Now we'll see how to use functions as return values.

Here's a function called \texttt{\frenchspacing digit} that accepts a single argument \texttt{\frenchspacing n}, and returns a {\em function}. What the {\em returned} function does is extract and return the \texttt{\frenchspacing n}'th significant digit from its argument.
\begin{lstlisting}
defn digit (n:Int) -> (Int -> Int) :
   defn extract-digit (x:Int, n:Int) :
      if x < 0 : extract-digit((- x), n)
      else if n == 0 : x % 10
      else : extract-digit(x / 10, n - 1)
   defn extract-digit-n (x:Int) :
      extract-digit(x, n)
   extract-digit-n
\end{lstlisting}
Let's try it out on some numbers.
\begin{lstlisting}
defn main () :
   val first-digit = digit(0)
   val third-digit = digit(2)

   defn test-first-digit (x:Int) :
      println("The first digit of %_ is %_." % [x, first-digit(x)])
   test-first-digit(413)
   test-first-digit(-313)
   test-first-digit(41)
   test-first-digit(137)
   test-first-digit(991)

   defn test-third-digit (x:Int) :
      println("The third digit of %_ is %_." % [x, third-digit(x)])
   test-third-digit(413)
   test-third-digit(-313)
   test-third-digit(41)
   test-third-digit(137)
   test-third-digit(991)

main()   
\end{lstlisting}
Compiling and running the program prints out
\begin{lstlisting}
The first digit of 413 is 3.
The first digit of -313 is 3.
The first digit of 41 is 1.
The first digit of 137 is 7.
The first digit of 991 is 1.
The third digit of 413 is 4.
The third digit of -313 is 3.
The third digit of 41 is 0.
The third digit of 137 is 1.
The third digit of 991 is 9.
\end{lstlisting}

The type signature of \texttt{\frenchspacing digit} is daunting at first. 
\begin{lstlisting}
defn digit (n:Int) -> (Int -> Int)
\end{lstlisting}
Let's decipher it piece by piece. \texttt{\frenchspacing digit} is a function that takes a single \texttt{\frenchspacing Int} argument, and returns a \texttt{\frenchspacing (Int -> Int)}. And we learned previously that a \texttt{\frenchspacing (Int -> Int)} is a one argument function that takes an \texttt{\frenchspacing Int} and returns an \texttt{\frenchspacing Int}. The parentheses around \texttt{\frenchspacing Int -> Int} is not strictly necessary as \texttt{\frenchspacing ->} is a right-associative operator. Thus, \texttt{\frenchspacing digit} can also be declared the following way.
\begin{lstlisting}
defn digit (n:Int) -> Int -> Int
\end{lstlisting}
Write it in the way that is most clear to you. As an exercise, think about what the type of \texttt{\frenchspacing digit} is. 

\subsection*{Sorting By Digit}
Now that we have a function for creating functions that are compatible with what is expected by \texttt{\frenchspacing sort-by}, let's use \texttt{\frenchspacing sort-by} to sort by different digits. Update the \texttt{\frenchspacing main} function in our previous example.
\begin{lstlisting}
defn main () :
   val xs = Array<Int>(10)
   xs[0] = 510
   xs[1] = 923
   xs[2] = 671
   xs[3] = 811
   xs[4] = -129
   xs[5] = -581
   xs[6] = 233
   xs[7] = -791
   xs[8] = 899
   xs[9] = 313

   println("Sort by value directly.")
   sort-by(identity, xs)
   println(xs)

   println("Sort by absolute value.")
   sort-by(abs, xs)
   println(xs)

   println("Sort by sum of digits.")
   sort-by(sum-of-digits, xs)
   println(xs)

   println("Sort by first digit.")
   sort-by(digit(0), xs)
   println(xs)

   println("Sort by second digit.")
   sort-by(digit(1), xs)
   println(xs)

   println("Sort by third digit.")
   sort-by(digit(2), xs)
   println(xs)   
\end{lstlisting}
Compile and run the program. It should print out
\begin{lstlisting}
Sort by value directly.
[-791 -581 -129 233 313 510 671 811 899 923]
Sort by absolute value.
[-129 233 313 510 -581 671 -791 811 899 923]
Sort by sum of digits.
[510 313 233 811 -129 671 -581 923 -791 899]
Sort by first digit.
[510 811 671 -581 -791 233 313 923 -129 899]
Sort by second digit.
[510 811 313 923 -129 233 671 -581 -791 899]
Sort by third digit.
[-129 233 313 510 -581 671 -791 811 899 923]
\end{lstlisting}

Isn't that elegant! This is but a small demonstration of the power of first-class functions.  

\section{Core Library Functions}
The \texttt{\frenchspacing sort-by} function is so general and useful that you might wonder whether it's already included in Stanza's core library. And it is, along with many other useful higher order functions. We'll show you a few of them here.

\subsection*{qsort!}
The \texttt{\frenchspacing qsort!} function is Stanza's included sorting function. It implements the quick sort algorithm, and you can use it sort collections in much the same way that you used the \texttt{\frenchspacing sort-by} function. One big difference, though, is that \texttt{\frenchspacing qsort!} works on many different kinds of objects whereas your \texttt{\frenchspacing sort-by} function only worked on \texttt{\frenchspacing Int} objects. 
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "Patrick")
add(xs, "Luca")
add(xs, "Emmy")
add(xs, "Sunny")
add(xs, "Whiskey")
add(xs, "Rummy")
qsort!(xs)
println(xs)
\end{lstlisting}
The above is an example of sorting a vector of strings, and it prints out
\begin{lstlisting}
["Emmy" "Luca" "Patrick" "Rummy" "Sunny" "Whiskey"]
\end{lstlisting}

\texttt{\frenchspacing qsort!} can optionally take a key function as its first argument for computing the item with which to sort. Here's how to sort the \texttt{\frenchspacing xs} vector by the second letter.
\begin{lstlisting}
defn second-letter (s:String) : s[1]
qsort!(second-letter, xs)
println(xs)
\end{lstlisting}
Running the program prints out
\begin{lstlisting}
["Patrick" "Whiskey" "Emmy" "Rummy" "Luca" "Sunny"]
\end{lstlisting}

The third form of \texttt{\frenchspacing qsort!} takes, as its second argument, a {\em comparison} function with which to sort by. The comparison function is given two items from the collection and must return \texttt{\frenchspacing true} if the first argument is less than the second argument, or \texttt{\frenchspacing false} otherwise. 

Here is an example of sorting a vector containing both integers and strings. Integers are less than other integers if their numeric value is smaller. Strings are compared against other strings according to their lexicographic order. And integers are less than strings if the integer is less than the length of the string.
\begin{lstlisting}
val xs = Vector<Int|String>()
add(xs, 1)
add(xs, 3)
add(xs, "A")
add(xs, "B")
add(xs, 4)
add(xs, -10)
add(xs, "Timon")
add(xs, "Pumbaa")
add(xs, 42)

defn compare-items (a:Int|String, b:Int|String) :
   match(a, b) :
      (a:Int, b:Int) : a < b
      (a:Int, b:String) : a < length(b)
      (a:String, b:Int) : length(a) < b
      (a:String, b:String) : a < b
qsort!(xs, compare-items)
println(xs)
\end{lstlisting}
Running the program prints out
\begin{lstlisting}
[-10 1 "A" "B" 3 4 "Pumbaa" "Timon" 42]
\end{lstlisting}

\subsection*{find}
The \texttt{\frenchspacing find} function looks for the first item in a collection that satisfies a condition. The condition is given as a function, and takes a single argument representing an item from the collection. The condition function must return \texttt{\frenchspacing true} if the item satisfies the condition, or \texttt{\frenchspacing false} otherwise. \texttt{\frenchspacing find} returns the item if it is found, or \texttt{\frenchspacing false} otherwise. 

Here is an example of looking for the first capitalized word in a vector of strings.
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "they")
add(xs, "call")
add(xs, "me")
add(xs, "Mr")
add(xs, "Pig")

defn capitalized? (x:String) : upper-case?(x[0])
println(find(capitalized?, xs))
\end{lstlisting}
Running the program prints out
\begin{lstlisting}
Mr
\end{lstlisting}

\subsection*{index-when}
The \texttt{\frenchspacing index-when} function is similar to \texttt{\frenchspacing find}, and looks for the first item in a collection that satisfies a condition. The difference is if the item is found, then \texttt{\frenchspacing index-when} returns its {\em index}. 

Calling \texttt{\frenchspacing index-when} instead of \texttt{\frenchspacing find} on the previous example
\begin{lstlisting}
println(index-when(capitalized?, xs))
\end{lstlisting}
prints out
\begin{lstlisting}
3
\end{lstlisting}

\subsection*{Maybe Objects and first}
A \texttt{\frenchspacing Maybe} is used to indicate the presence or absence of an object. A \texttt{\frenchspacing None} object is a subtype of \texttt{\frenchspacing Maybe} and indicates there is no object. A \texttt{\frenchspacing One} object is a subtype of \texttt{\frenchspacing Maybe} and contains a wrapped object. You can retrieve the wrapped object in a \texttt{\frenchspacing One} object using the \texttt{\frenchspacing value} function.

The \texttt{\frenchspacing first} function takes an argument function, \texttt{\frenchspacing f}, and a collection \texttt{\frenchspacing xs}, and calls \texttt{\frenchspacing f} repeatedly on each item in the collection. \texttt{\frenchspacing f} must return a \texttt{\frenchspacing Maybe} object. \texttt{\frenchspacing first} returns the first \texttt{\frenchspacing One} object that is returned by \texttt{\frenchspacing f}, or a \texttt{\frenchspacing None} object if no call to \texttt{\frenchspacing f} returns a \texttt{\frenchspacing One} object.

Here is an example of using first to find the first even sum of digits in a vector of integers.
\begin{lstlisting}
val xs = Vector<Int>()
add(xs, 14)
add(xs, 78)
add(xs, 232)
add(xs, 787)
add(xs, 49)

defn even-sum? (x:Int) :
   val s = sum-of-digits(x)
   if s % 2 == 0 : One(s)
   else : None()
match(first(even-sum?, xs)) :
   (x:One<Int>) :
      println("The first even sum of digits is %_." % [value(x)])
   (x:None) :
      println("No number in xs has an even sum of digits.")
\end{lstlisting}

\subsection*{map!}
The \texttt{\frenchspacing map!} function takes a function \texttt{\frenchspacing f} and an array (or vector) \texttt{\frenchspacing xs}. It then iterates through the array and replaces each item in the array with a call to \texttt{\frenchspacing f} on the item. 

Here is how to capitalize each entry in a vector of strings using \texttt{\frenchspacing map!}.
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "they")
add(xs, "call")
add(xs, "me")
add(xs, "Mr")
add(xs, "Pig")   

defn capitalize (x:String) :
   append(upper-case(x[0 to 1]), x[1 to false])
map!(capitalize, xs)
println(xs)
\end{lstlisting}
When ran, it prints out
\begin{lstlisting}
["They" "Call" "Me" "Mr" "Pig"]
\end{lstlisting}

\subsection*{all?, any?, none?}
\texttt{\frenchspacing all?} is used to determine whether {\em every} item in a collection satisfies some condition. The \texttt{\frenchspacing all?} function takes a function \texttt{\frenchspacing f} and a collection \texttt{\frenchspacing xs}. It returns \texttt{\frenchspacing true} if calling \texttt{\frenchspacing f} on every item in \texttt{\frenchspacing xs} returns \texttt{\frenchspacing true}. If \texttt{\frenchspacing f} returns \texttt{\frenchspacing false} on any item then \texttt{\frenchspacing all?} immediately returns \texttt{\frenchspacing false}. 

Here is how we can use \texttt{\frenchspacing all?} to test whether all numbers in \texttt{\frenchspacing xs} are positive.
\begin{lstlisting}
val xs = Vector<Int>()
add(xs, 4)
add(xs, 2)
add(xs, 3)
add(xs, -8)
add(xs, 5)

defn positive? (x:Int) : x > 0
all?(positive?, xs)
\end{lstlisting}

The \texttt{\frenchspacing any?} and \texttt{\frenchspacing none?} functions work similarly. \texttt{\frenchspacing any?} determines whether {\em any} item satisfies the condition, and \texttt{\frenchspacing none?} determines whether {\em no} item satisfies the condition.

\subsection*{do}
Finally we get to the {\em most} commonly used higher order function of them all: the \texttt{\frenchspacing do} function. The \texttt{\frenchspacing do} function takes a function \texttt{\frenchspacing f} and a collection \texttt{\frenchspacing xs} and calls \texttt{\frenchspacing f} on each item in the collection.

Here is how to report the lengths of every string in a vector using \texttt{\frenchspacing do}. 
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "they")
add(xs, "call")
add(xs, "me")
add(xs, "Mr")
add(xs, "Pig")

defn report-length (x:String) :
   println("%_ has length %_." % [x, length(x)])
do(report-length, xs)
\end{lstlisting}
When ran, it prints out
\begin{lstlisting}
they has length 4.
call has length 4.
me has length 2.
Mr has length 2.
Pig has length 3.
\end{lstlisting}

At this point, particularly precocious readers might start to suspect that they have already used \texttt{\frenchspacing do} in their programs without knowing it.

\section{Anonymous Functions}
Before the introduction of higher-order functions it was natural for you to give every function in your program a name. After all, if a function has no name, then how would you call it? But after having been exposed to higher-order functions, you might now be wondering if it's possible to {\em avoid} giving functions a name. A lot of functions are now only ever used once, and only as an argument to another higher-order function. 

{\em Anonymous functions} are functions without names. Here is \texttt{\frenchspacing report-length} from the previous example written as an anonymous function.
\begin{lstlisting}
fn (x:String) :
   println("%_ has length %_." % [x, length(x)])
\end{lstlisting}

Here is an example of rewriting the \texttt{\frenchspacing do} example using an anonymous function.
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "they")
add(xs, "call")
add(xs, "me")
add(xs, "Mr")
add(xs, "Pig")
do(fn (x:String) :
      println("%_ has length %_." % [x, length(x)])
   xs)
\end{lstlisting}
Notice how the \texttt{\frenchspacing report-length} function is now directly created using \texttt{\frenchspacing fn} and passed immediately as an argument to \texttt{\frenchspacing do}. The arguments to higher-order functions are often very short and anonymous functions provides a convenient syntax for using them.

\subsection*{Bidirectional Type Inference}
The type inference rules for anonymous functions are different than those for named functions. For a named function, if a type annotation is left off of an argument, then the argument is assumed to have the \texttt{\frenchspacing ?} type, and can accept anything. For an anonymous function, if a type annotation is left off of an argument, then the argument's type is inferred from the context in which the function is used. 

Thus the call to \texttt{\frenchspacing do} in the above example could be more concisely written as
\begin{lstlisting}
do(fn (x) : println("%_ has length %_." % [x, length(x)])
   xs)
\end{lstlisting}
From the context, the type of \texttt{\frenchspacing xs} is \texttt{\frenchspacing Vector<String>}, and since \texttt{\frenchspacing do} calls the function on each item in \texttt{\frenchspacing xs}, it is obvious that \texttt{\frenchspacing x} must be of type \texttt{\frenchspacing String}.

Idiomatic Stanza code rarely contains type annotations for anonymous functions, and instead relies upon type inference. In certain circumstances, Stanza will be unable to infer the argument types, in which case you'll have to provide them explicitly.

\subsection*{Anonymous Function Shorthand}
For {\em extremely} short anonymous functions, Stanza provides a syntactic shorthand. The following function
\begin{lstlisting}
fn (x) : x + 1
\end{lstlisting}
can be written equivalently as
\begin{lstlisting}
{_ + 1}
\end{lstlisting}

As another example, the following function
\begin{lstlisting}
fn (x, y) : x + 2 * y
\end{lstlisting}
can be written equivalently as
\begin{lstlisting}
{_ + 2 * _}
\end{lstlisting}

The shorthand consists of surrounding the function body with the \texttt{\frenchspacing \{\}} brackets, and using underscores to denote arguments. To create anonymous functions with explicit type annotations use the following form.
\begin{lstlisting}
fn (x:Int, y:String) : x + length(y)
\end{lstlisting}
can be written equivalently as
\begin{lstlisting}
{_:Int + 2 * _:String}
\end{lstlisting}

\subsection*{Curried Function Shorthand}
For {\em extremely} short anonymous functions consisting of a single function call, Stanza provides another syntactic shorthand. The following function
\begin{lstlisting}
fn (xs) : qsort!(abs, xs)
\end{lstlisting}
can be written equivalently as
\begin{lstlisting}
qsort!{abs, _}
\end{lstlisting}

Similarly, to create anonymous functions with explicit type annotations use the following form.
\begin{lstlisting}
fn (i:Int) : index-of-min(i, length(xs))
\end{lstlisting}
can be written equivalently as
\begin{lstlisting}
index-of-min{_:Int, length(xs)}
\end{lstlisting}

\subsection*{The Application Operator}
With the introduction of anonymous functions, you'll find that you can implement lots of functionality using single lines of code. To help with this programming style, Stanza provides the \texttt{\frenchspacing \$} operator to help reduce the number of nested expressions. The expression
\begin{lstlisting}
f $ x
\end{lstlisting}
is equivalent to 
\begin{lstlisting}
f(x)
\end{lstlisting}
Thus the \texttt{\frenchspacing \$} operator is just a shorthand for function application. Notice, however, that with the \texttt{\frenchspacing \$} operator, the above expression did not require any parentheses. 

There is a very common usage pattern involving both curried functions and the \texttt{\frenchspacing \$} operator. Here is what it looks like.
\begin{lstlisting}
f{x, _} $ y
\end{lstlisting}
Let's remove the syntactic shorthands incrementally to figure out what the above means. First, we will write out the \texttt{\frenchspacing \$} operator in full.
\begin{lstlisting}
(f{x, _})(y)
\end{lstlisting}
Next, we will write out the curried function in full.
\begin{lstlisting}
(fn (a) : f(x, a))(y)
\end{lstlisting}
So the expression, when written in full, just creates an anonymous function and then immediately calls it with \texttt{\frenchspacing y}. Calling the anonymous function is then equivalent to
\begin{lstlisting}
f(x, y)
\end{lstlisting}

Thus the expression
\begin{lstlisting}
f{x, _} $ y
\end{lstlisting}
is equivalent to
\begin{lstlisting}
f(x, y)
\end{lstlisting}
You can think of the \texttt{\frenchspacing \$} operator as substituting the right hand side expression in for the underscores in the left hand side expression. 

This usage pattern is often used to chain a long sequence of operations together.
\begin{lstlisting}
f{1, _} $
   head $
   g{2, _} $
   xs[2]
\end{lstlisting}
is a shorthand for writing
\begin{lstlisting}
val result1 = xs[2]
val result2 = g(2, result1)
val result3 = head(result2)
f(1, result3)
\end{lstlisting}

Here is a concrete example of an idiomatic usage of the \texttt{\frenchspacing \$} operator. In the demonstration of the \texttt{\frenchspacing qsort!} operator, we explicitly created a \texttt{\frenchspacing compare-items} function to pass into \texttt{\frenchspacing qsort!}.
\begin{lstlisting}
defn compare-items (a:Int|String, b:Int|String) :
   match(a, b) :
      (a:Int, b:Int) : a < b
      (a:Int, b:String) : a < length(b)
      (a:String, b:Int) : length(a) < b
      (a:String, b:String) : a < b
qsort!(xs, compare-items)
\end{lstlisting}
But here is another way it can be (and often is) written.
\begin{lstlisting}
qsort!{xs, _} $ fn (a, b) :
   match(a, b) :
      (a:Int, b:Int) : a < b
      (a:Int, b:String) : a < length(b)
      (a:String, b:Int) : length(a) < b
      (a:String, b:String) : a < b   
\end{lstlisting}
Since the types of the arguments of anonymous functions are inferred, there is also no need to provide explicit type annotations.

\section{The For Construct}
Now that you've been introduced to anonymous functions and higher-order functions, we are now ready to introduce the {\em full} for construct. The expression
\begin{lstlisting}
for x in xs do :
   println(x)
\end{lstlisting}
is equivalent to
\begin{lstlisting}
do(fn (x) :
      println(x)
   xs)   
\end{lstlisting}
As mentioned before, the for construct is not a looping mechanism. It is a syntactic shorthand for calling higher-order functions of a certain form. As explained earlier, the \texttt{\frenchspacing do} function is what's responsible for looping over each element in \texttt{\frenchspacing xs}. 

The for construct can be called with multiple bindings as well.
\begin{lstlisting}
for (x in xs, y in ys) do :
   println(x + y)
\end{lstlisting}
is equivalent to
\begin{lstlisting}
do(fn (x, y) :
      println(x + y)
   xs, ys)   
\end{lstlisting}

Thus, in general, the for construct expands to a call to a higher order function where the first argument is an anonymous function followed by n remaining arguments. The anonymous function must take n arguments, one for each of the remaining arguments.

There are forms of the \texttt{\frenchspacing do} function that accept multiple collections. The collections are iterated over in parallel, and iteration stops when it reaches the end of any one of them. The following example prints every item in a vector coupled with its index. 
\begin{lstlisting}
val xs = Vector<String>()
add(xs, "Patrick")
add(xs, "Luca")
add(xs, "Emmy")

for (x in xs, i in 0 to false) do :
   println("Element %_ is at index %_." % [x, i])
\end{lstlisting}
It prints out 
\begin{lstlisting}
Element Patrick is at index 0.
Element Luca is at index 1.
Element Emmy is at index 2.
\end{lstlisting}

\subsection*{Operating Functions}
\texttt{\frenchspacing find}, \texttt{\frenchspacing all?}, \texttt{\frenchspacing any?}, \texttt{\frenchspacing none?}, and \texttt{\frenchspacing index-when?} also have multiple collection versions that can be used with a for construct with multiple bindings.

Functions like \texttt{\frenchspacing do}, with type signatures compatible with the for construct, are called {\em operating functions}. Stanza's core library includes a large number of commonly used ones. For more details, read the reference documentation. 

Occasionally, it might also be appropriate to implement your own operating function. Here is an operating function that first iterates over each odd integer in a vector and then iterates over each even integer in the vector.
\begin{lstlisting}
defn do-odd-then-even (f: Int -> ?, xs:Vector<Int>) :
   for x in xs do :
      if x % 2 != 0 : f(x)
   for x in xs do :
      if x % 2 == 0 : f(x)
\end{lstlisting}
Here is an example of using it in conjunction with the for construct.
\begin{lstlisting}
val xs = Vector<Int>()
add(xs, 1)
add(xs, 3)
add(xs, 2)
add(xs, 6)
add(xs, 5)
add(xs, 2)
add(xs, 4)
add(xs, 3)

for x in xs do-odd-then-even :
   println(x)
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
1
3
5
3
2
6
2
4
\end{lstlisting}
   
\section{Stanza Idioms}
With our new knowledge of anonymous functions, curried functions, and the for construct, we can now revisit our examples of using the core library and write them using standard Stanza idioms and functions.
\begin{lstlisting}
;A vector of strings
val strs = Vector<String>()
add-all(strs, ["patrick", "luca", "emmy", "Sunny", "whiskey", "Rummy"])

;Sort by the second letter
println("1.")
qsort!({_[1]}, strs)
println(strs)

;A vector of ints and strings
val int-strs = Vector<Int|String>()
add-all(int-strs, [1, 3, "A", "B", 4, -10, "Timon", "Pumbaa", 42])

;Sort using custom comparison function
println("\n2.")
qsort!{int-strs, _} $ fn (a, b) :
   match(a, b) :
      (a:Int, b:Int) : a < b
      (a:Int, b:String) : a < length(b)
      (a:String, b:Int) : length(a) < b
      (a:String, b:String) : a < b
println(xs)

;Find first capitalized word
println("\n3.")
println $ for s in strs find :
   upper-case?(x[0])

;Find index of first capitalized word
println("\n4.")
println $ for s in strs index-when :
   upper-case?(x[0])

;Capitalize every word
println("\n5.")
for s in strs map! :
   append(upper-case(x[0 to 1]), x[1 to false])
println(strs)

;A vector of integers
val ints = Vector<Int>()
add-all(ints, [4, 2, 3, -8, 5])

;Are they all positive?
println("\n6.")
println $ for x in ints all? :
   x > 0

;Report lengths of string along with their index
println("\n7.")
for (s in strs, i in 0 to false) do :
   println("strs[%_] = %_. Length = %_." % [i, strs[i], length(strs[i])])
\end{lstlisting}

Compiling and running all of the above print outs
\begin{lstlisting}
1.
["patrick" "whiskey" "emmy" "Rummy" "luca" "Sunny"]

2.
[-10 1 "A" "B" 3 4 "Pumbaa" "Timon" 42]

3.
Rummy

4.
3

5.
["Patrick" "Whiskey" "Emmy" "Rummy" "Luca" "Sunny"]

6.
false

7.
strs[0] = Patrick. Length = 7.
strs[1] = Whiskey. Length = 7.
strs[2] = Emmy. Length = 4.
strs[3] = Rummy. Length = 5.
strs[4] = Luca. Length = 4.
strs[5] = Sunny. Length = 5.
\end{lstlisting}

\section{Tail Calls}
Consider the following function for computing the sum of all the positive integers less than or equal to \texttt{\frenchspacing n}.
\begin{lstlisting}
defn sum-of (n:Int) :
   if n > 0 : n + sum-of(n - 1)
   else : 0
\end{lstlisting}
Calling \texttt{\frenchspacing sum-of(6)} returns \texttt{\frenchspacing 21}.

Here's a visualization of the {\em execution context} as that operation is being performed.
\begin{lstlisting}
sum-of(6) =
6 + sum-of(5) =
6 + 5 + sum-of(4) =
6 + 5 + 4 + sum-of(3) =
6 + 5 + 4 + 3 + sum-of(2) =
6 + 5 + 4 + 3 + 2 + sum-of(1) =
6 + 5 + 4 + 3 + 2 + 1 + sum-of(0) =
6 + 5 + 4 + 3 + 2 + 1 + 0 =
6 + 5 + 4 + 3 + 2 + 1 =                  
6 + 5 + 4 + 3 + 3 =                  
6 + 5 + 4 + 6 =                  
6 + 5 + 10 =                  
6 + 15 =                  
21
\end{lstlisting}
Observe that the computation of \texttt{\frenchspacing sum-of(6)} requires knowing the result of \texttt{\frenchspacing sum-of(5)}. And so we then recursively compute the result of \texttt{\frenchspacing sum-of(5)} {\em while remembering} that we should add \texttt{\frenchspacing 6} to the result to get the final answer. Similarly, the computation of \texttt{\frenchspacing sum-of(5)} requires the result of \texttt{\frenchspacing sum-of(4)}. Et cetera. 

Each recursive invocation of \texttt{\frenchspacing sum-of} requires us to remember what to do with the result. This is our execution context, and in Stanza, is saved in a stack of {\em activation records}. How big does this stack get? Well, for \texttt{\frenchspacing sum-of}, it grows to contain exactly \texttt{\frenchspacing n} {\em activation records}. 

This can be verified by forcing a program failure when \texttt{\frenchspacing n} is equal to \texttt{\frenchspacing 0} and looking at the {\em stack trace}.
\begin{lstlisting}
defn sum-of (n:Int) :
   if n > 0 : n + sum-of(n - 1)
   else : fatal("n reached zero.")
\end{lstlisting}
When compiled and ran, the above prints out
\begin{lstlisting}
FATAL ERROR: n reached zero.
   at test.stanza:7.10
   at test.stanza:6.18
   at test.stanza:6.18
   at test.stanza:6.18
   at test.stanza:6.18
   at test.stanza:6.18
   at test.stanza:6.18
   at test.stanza:9.0
\end{lstlisting}
Each \texttt{\frenchspacing test.stanza:6.18} entry in the stack trace refers to a recursive call to \texttt{\frenchspacing sum-of(n - 1)}. Thus you can see that there are \texttt{\frenchspacing 6} entries corresponding to calling \texttt{\frenchspacing sum-of(6)}. {\em activation records} take up space. If \texttt{\frenchspacing n} is too large, then eventually the stack of activation records will consume all of your program memory.

\subsection*{An Iterative Algorithm}
Now consider this alternative implementation of \texttt{\frenchspacing sum-of}.
\begin{lstlisting}
defn sum-of (n:Int) :
   x+sum-of(0, n)
   
defn x+sum-of (x:Int, n:Int) :
   if n > 0 : x+sum-of(x + n, n - 1)
   else : x  
\end{lstlisting}

Here's a visualization of the execution context of computing \texttt{\frenchspacing sum-of(6)}.
\begin{lstlisting}
sum-of(6) =
x+sum-of(0, 6) =
x+sum-of(6, 5) =
x+sum-of(11, 4) =
x+sum-of(15, 3) =
x+sum-of(18, 2) =
x+sum-of(20, 1) =
x+sum-of(21, 0) =
21
\end{lstlisting}
Similar to before, the computation of \texttt{\frenchspacing x+sum-of(0, 6)} requires knowing the result of \texttt{\frenchspacing x+sum-of(6, 5)}. And so we then recursively compute the result of \texttt{\frenchspacing x+sum-of(6, 5)}. But this time, we don't have to remember what to do with the result! The result of \texttt{\frenchspacing x+sum-of(6, 5)} {\em is} the result of \texttt{\frenchspacing x+sum-of(0, 6)}, so just return whatever \texttt{\frenchspacing x+sum-of(6, 5)} returns. 

In concrete terms, what this means is that Stanza can discard the activation record for \texttt{\frenchspacing x+sum-of(0, 6)} immediately before calling \texttt{\frenchspacing x+sum-of(6, 5)} since there's no context to remember. If that is done, then the number of activation records does not grow, no matter how large \texttt{\frenchspacing n} is. And thus the program will not run out of memory. This optimization is called {\em tail call optimization}.

\subsection*{Tail Call Optimization}
By default, Stanza does not optimize tail calls in functions. This is done for the purposes of debugging. It is useful to have a complete stack trace, even if not strictly necessary for correct operation of the algorithm. To tell Stanza to optimize tail calls in a function, we have to explicitly declare the function as being tail call optimized.
\begin{lstlisting}
defn sum-of (n:Int) :
   x+sum-of(0, n)
   
defn* x+sum-of (x:Int, n:Int) :
   if n > 0 : x+sum-of(x + n, n - 1)
   else : x
\end{lstlisting}
\texttt{\frenchspacing defn*} is the tail call optimized version of \texttt{\frenchspacing defn}. Similarly, \texttt{\frenchspacing defmethod*} is the tail call optimized version of \texttt{\frenchspacing defmethod}, and \texttt{\frenchspacing fn*} is the tail call optimized version of \texttt{\frenchspacing fn}. 

To verify that the stack frames are properly being discarded, we'll again force the program to fail when \texttt{\frenchspacing n} is equal to \texttt{\frenchspacing 0} and examine the stack trace.
\begin{lstlisting}
defn* x+sum-of (x:Int, n:Int) :
   if n > 0 : x+sum-of(x + n, n - 1)
   else : fatal("n reached zero.")
\end{lstlisting}
Compiling and running the program prints
\begin{lstlisting}
FATAL ERROR: n reached zero.
   at tests/test.stanza:6.3
   at tests/test.stanza:20.10
\end{lstlisting}
There are now {\em no} stack frames corresponding to \texttt{\frenchspacing x+sum-of}. They have all been discarded.

\section{Revisiting While}
With the introduction of tail calls, it is time for us to unveil the internals of the while loop construct. The expression
\begin{lstlisting}
var i = 0
while i < 10 :
   println(i)
   i = i + 1
\end{lstlisting}
is equivalent to
\begin{lstlisting}
var i = 0
defn* loop () :
   if i < 10 :
      println(i)
      i = i + 1
      loop()
loop()
\end{lstlisting}
Thus the while construct simply defines a local tail call optimized function and then calls it.

Directly expressing loops using recursive functions can often be much more natural than using a while loop. A while loop loops by default, and the programmer has to specify when it should {\em stop} looping. In constrast, a recursive function does {\em not} loop by default, and the programmer instead specifies when to perform another iteration.

Here is an example of using a tail call optimized function for finding the index of an integer \texttt{\frenchspacing x} in a {\em sorted} vector \texttt{\frenchspacing xs} using binary search.
\begin{lstlisting}
defn bsearch (x:Int, xs:Vector<Int>) :
   label<Int|False> return :
      defn* loop (start:Int, end:Int) :
         if start < end :
            val mid = start + (end - start) / 2
            if x < xs[mid] : loop(start, mid)
            else if x > xs[mid] : loop(mid + 1, end)
            else : return(mid)
      loop(0, length(xs))            
\end{lstlisting}
\texttt{\frenchspacing loop} finds the index of \texttt{\frenchspacing x}, assuming that it exists between the \texttt{\frenchspacing start} index and \texttt{\frenchspacing end} index (exclusive). It does this by computing a midpoint, \texttt{\frenchspacing mid}, between the two indices. If \texttt{\frenchspacing x} is less than the element at \texttt{\frenchspacing mid} then it looks again in the first half of the range. If \texttt{\frenchspacing x} is greater than the element at \texttt{\frenchspacing mid} then it looks again in the second half of the range. Otherwise it has found \texttt{\frenchspacing x}, and it is at index \texttt{\frenchspacing mid}.

Let's try looking for the numbers \texttt{\frenchspacing 1}, \texttt{\frenchspacing 14}, and \texttt{\frenchspacing 13}. 
\begin{lstlisting}
defn main () :
   val xs = Vector<Int>()
   add-all(xs, [1,3,4,7,8,11,14,18,20,35])
   println(bsearch(1, xs))
   println(bsearch(14, xs))
   println(bsearch(13, xs))

main()
\end{lstlisting}
When compiled and ran, the above prints out
\begin{lstlisting}
0
6
false
\end{lstlisting}

\chapter{Programming with Sequences}
A sequence is a series of objects. At any point, you may ask whether a sequence is empty, and if it is not empty you may retrieve the next object. Many datastructures can represent their items as a sequence. For example, a sequence for representing the items in an array could begin with the item at index \texttt{\frenchspacing 0}. Subsequent items in the sequence would correspond to subsequent items in the array. When it reaches the end of the array then the sequence is empty.

While sequences are not a core language feature, they do play a fundamental part in the design of Stanza's core library. In this chapter we'll see how to fully exploit their power, and by doing so, avoid having to repeatedly reimplement many common programming patterns ourselves. 

\section{Fundamental Operations}
A sequence is represented by the \texttt{\frenchspacing Seq} type in Stanza. Let's first create a sequence containing all the strings in a tuple.
\begin{lstlisting}
val xs = to-seq(["Timon" "and" "Pumbaa" "are" "good" "friends."])
\end{lstlisting}
This creates the sequence \texttt{\frenchspacing xs}, which has type \texttt{\frenchspacing Seq<String>} indicating that it is a sequence of strings.

Fundamentally, a sequence is defined by three operations.
\begin{enumerate}
\item You may ask whether a sequence is empty.
\item You may take a peek at the next item in the sequence.
\item You may take out the next item in the sequence.
\end{enumerate}

Here is how to ask whether our \texttt{\frenchspacing xs} sequence is empty.
\begin{lstlisting}
if empty?(xs) :
   println("xs is empty.")
else :
   println("xs is not empty.")
\end{lstlisting}
which prints out
\begin{lstlisting}
xs is not empty.
\end{lstlisting}
because we haven't taken anything out of the sequence yet. 

If the sequence is not empty, then you can take a peek at the next item in the sequence like this.
\begin{lstlisting}
val x0 = peek(xs)
println("The next item is %_." % [x0])
\end{lstlisting}
which prints out
\begin{lstlisting}
The next item is Timon.
\end{lstlisting}
Peeking at an empty sequence is a fatal error.

Peeking at a sequence does not change the state of a sequence. If you peek again at the same sequence, it returns the same thing.
\begin{lstlisting}
val x1 = peek(xs)
println("The next item is still %_." % [x1])
\end{lstlisting}
which prints out
\begin{lstlisting}
The next item is still Timon.
\end{lstlisting}

Once you've determined that the sequence is not empty, you may take out the next item in the sequence.
\begin{lstlisting}
val y0 = next(xs)
println("Took out item %_ from xs." % [y0])
\end{lstlisting}
which prints out
\begin{lstlisting}
Took out item Timon from xs.
\end{lstlisting}

Calling \texttt{\frenchspacing next} on a sequence {\em does} change the state of a sequence. If you call \texttt{\frenchspacing next} again on the same sequence, it will return the following item in the sequence.
\begin{lstlisting}
val y1 = next(xs)
println("Now took out item %_ from xs." % [y1])
\end{lstlisting}
which prints out
\begin{lstlisting}
Now took out item and from xs.
\end{lstlisting}

Here is the standard pattern for printing out all the items in a sequence. 
\begin{lstlisting}
while not empty?(xs) :
   println("Next item is %_" % [next(xs)])
\end{lstlisting}
which prints out
\begin{lstlisting}
Next item is Timon
Next item is and
Next item is Pumbaa
Next item is are
Next item is good
Next item is friends.
\end{lstlisting}

\section{Writing a Sequence Function}
Let's now write a function that takes a sequence argument. \texttt{\frenchspacing cum-sum} takes a sequence of integers, \texttt{\frenchspacing xs}, and returns a vector containing the cumulative sum of all the numbers in \texttt{\frenchspacing xs}.
\begin{lstlisting}
defn cum-sum (xs:Seq<Int>) :
   val ys = Vector<Int>()
   var accum = 0
   while not empty?(xs) :      
      accum = accum + next(xs)
      add(ys, accum)
   ys
\end{lstlisting}
Let's try it out on some numbers.
\begin{lstlisting}
defn main () :
   val xs = [1, 1, 3, 1, 5, 6, 2, 3, 8]
   println(cum-sum(to-seq(xs)))

main()
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
[1 2 5 6 11 17 19 22 30]
\end{lstlisting}

\subsection*{Seqable}
Notice that in the call to \texttt{\frenchspacing cum-sum} we have to explicitly convert our tuple into a \texttt{\frenchspacing Seq} object using \texttt{\frenchspacing to-seq}. Otherwise Stanza would issue a type error. For convenience, however, it would be better to move the call to \texttt{\frenchspacing to-seq} inside the body of \texttt{\frenchspacing cum-sum} and have \texttt{\frenchspacing cum-sum} accept {\em any} object that supports \texttt{\frenchspacing to-seq}. 

This brings us to the type \texttt{\frenchspacing Seqable}. Values of type \texttt{\frenchspacing Seqable} support only a single operation: calling \texttt{\frenchspacing to-seq} on a \texttt{\frenchspacing Seqable} object returns a \texttt{\frenchspacing Seq}. \texttt{\frenchspacing Seqable} also accepts a {\em type parameter} that indicates the type of element it contains. Thus calling \texttt{\frenchspacing to-seq} on a \texttt{\frenchspacing Seqable<Int>} returns a \texttt{\frenchspacing Seq<Int>}.

Let's change our \texttt{\frenchspacing cum-sum} function to accept an object of type \texttt{\frenchspacing Seqable<Int>}.
\begin{lstlisting}
defn cum-sum (xs:Seqable<Int>) :
   val xs-seq = to-seq(xs)
   val ys = Vector<Int>()
   var accum = 0
   while not empty?(xs-seq) :      
      accum = accum + next(xs-seq)
      add(ys, accum)
   ys
\end{lstlisting}

Now our \texttt{\frenchspacing cum-sum} function is general enough to be called with any \texttt{\frenchspacing Seqable} object. This includes ranges, tuples, arrays, vectors, lists (which we will cover later), and even other sequences. Let's try it out.
\begin{lstlisting}
defn main () :
   val xs = [1, 1, 3, 1, 5, 6, 2, 3, 8]
   val ys = to-array<Int>([1, 1, 3, 1, 5, 6, 2, 3, 8])
   val zs = to-vector<Int>([1, 1, 3, 1, 5, 6, 2, 3, 8])
   val ws = to-list([1, 1, 3, 1, 5, 6, 2, 3, 8])

   println(cum-sum(xs))
   println(cum-sum(ys))
   println(cum-sum(zs))
   println(cum-sum(ws))

main()
\end{lstlisting}
which prints out
\begin{lstlisting}
[1 2 5 6 11 17 19 22 30]
[1 2 5 6 11 17 19 22 30]
[1 2 5 6 11 17 19 22 30]
[1 2 5 6 11 17 19 22 30]
\end{lstlisting}
This is the mechanism that allows the core library functions (such as \texttt{\frenchspacing do}) to operate on all sorts of collections. \texttt{\frenchspacing do} just accepts a \texttt{\frenchspacing Seqable} argument. 

And since \texttt{\frenchspacing do} accepts a \texttt{\frenchspacing Seqable} argument, we can actually rewrite our \texttt{\frenchspacing cum-sum} function more elegantly using \texttt{\frenchspacing do}. 
\begin{lstlisting}
defn cum-sum (xs:Seqable<Int>) :
   val ys = Vector<Int>()
   var accum = 0
   for x in xs do :
      accum = accum + x
      add(ys, accum)
   ys
\end{lstlisting}

\section{Lazy Sequences}
Our \texttt{\frenchspacing cum-sum} function takes a sequence as its argument and returns a vector. This works just fine if we want {\em all} of the cumulative sums, but what if we want only the first four? Then we're spending a lot of time computing results that we don't need. 

To overcome this, we can rewrite \texttt{\frenchspacing cum-sum} to return a \texttt{\frenchspacing Seq<Int>} instead of a \texttt{\frenchspacing Vector<Int>} where the elements in the returned sequence is computed {\em on-demand}. 
\begin{lstlisting}
defn cum-sum (xs:Seqable<Int>) :
   var accum = 0
   val xs-seq = to-seq(xs)
   new Seq<Int> :
      defmethod empty? (this) :
         empty?(xs-seq)
      defmethod peek (this) :
         accum + peek(xs-seq)
      defmethod next (this) :
         accum = peek(this)
         next(xs-seq)
         accum
\end{lstlisting}
Now \texttt{\frenchspacing cum-sum} returns a {\em lazy} sequence where items are computed as they're needed. To demonstrate this, let's call \texttt{\frenchspacing cum-sum} on an {\em infinite} range of numbers, and print out the first 10 elements.
\begin{lstlisting}
defn main () :
   val xs = 1 to false by 3
   val ys = cum-sum(xs)
   for i in 0 to 10 do :
      println("Item %_ is %_." % [i, next(ys)])

main()
\end{lstlisting}
Compiling and running the above gives us
\begin{lstlisting}
Item 0 is 1.
Item 1 is 5.
Item 2 is 12.
Item 3 is 22.
Item 4 is 35.
Item 5 is 51.
Item 6 is 70.
Item 7 is 92.
Item 8 is 117.
Item 9 is 145.
\end{lstlisting}
Thus \texttt{\frenchspacing ys} is an {\em infinite} sequence of integers containing the cumulative sum of another infinite sequence of integers. 

\subsection*{seq}
Creating a sequence by calling a function repeatedly on the items from another sequence is a common operation, so it is included in Stanza's core library as the \texttt{\frenchspacing seq} operating function. The \texttt{\frenchspacing cum-sum} function can be rewritten using \texttt{\frenchspacing seq} like this.
\begin{lstlisting}
defn cum-sum (xs:Seqable<Int>) :
   var accum = 0
   for x in xs seq :
      accum = accum + x
      accum
\end{lstlisting}

\section{Using The Sequence Library}
Now that we've been introduced to sequences, we can unveil the full power of Stanza's core library. As mentioned in an earlier chapter, Stanza encourages users to architect their programs by defining a small set of fundamental operations on each type, and then augment that with a large library of derived operations for those types. Stanza's sequence library is structured in such a way.

The set of fundamental operations for a \texttt{\frenchspacing Seq} is very small, comprised of just \texttt{\frenchspacing empty?}, \texttt{\frenchspacing peek}, and \texttt{\frenchspacing next}. But Stanza includes a large library of useful functions for manipulating sequences. These functions are roughly categorized into three groups: sequence creators, sequence operators, and sequence reducers. Independently of this categorization, a large number of these functions are also {\em operating functions} and can be used with the for construct.

\subsection*{Sequence Creators}
Sequence creators are functions that take non-\texttt{\frenchspacing Seq} arguments and create and return \texttt{\frenchspacing Seq} objects. In typical programming, most sequences you manipulate will have been created with a sequence creator.

\subsection*{to-seq}
The most commonly used sequence creator is the \texttt{\frenchspacing to-seq} function, which works on any \texttt{\frenchspacing Seqable} object. You've already seen usages of it for converting tuples, arrays, vectors, and ranges to sequences.

\subsection*{repeatedly}
\texttt{\frenchspacing repeatedly} takes an argument function, \texttt{\frenchspacing f}, and creates an infinite sequence from the results of calling \texttt{\frenchspacing f} repeatedly. Here is an example of using it to create a sequence containing all the positive powers of 2. 
\begin{lstlisting}
var x = 1L
val xs = repeatedly $ fn () :
   val cur-x = x
   x = x * 2L
   cur-x
\end{lstlisting}
Let's print out the first 10 elements.
\begin{lstlisting}
do(println{next(xs)}, 0 to 10)
\end{lstlisting}
which prints out
\begin{lstlisting}
1
2
4
8
16
32
64
128
256
512
\end{lstlisting}

\subsection*{repeat-while}
\texttt{\frenchspacing repeat-while} takes an argument function, \texttt{\frenchspacing f}, and creates an infinite sequence by calling \texttt{\frenchspacing f} repeatedly. \texttt{\frenchspacing f} must return a \texttt{\frenchspacing Maybe} object. The returned sequence contains all the wrapped objects in all the \texttt{\frenchspacing One} objects returned by \texttt{\frenchspacing f} and ends the first time \texttt{\frenchspacing f} returns a \texttt{\frenchspacing None} object.

Here is an example of using it to create a sequence containing all the positive powers of 2 that are less than 2000.
\begin{lstlisting}
var x = 1L
var xs = repeat-while $ fn () :
   val cur-x = x
   if cur-x < 2000L :
      x = x * 2L
      One(cur-x)
   else :
      None()
\end{lstlisting}
Let's print out all the items in \texttt{\frenchspacing xs}.
\begin{lstlisting}
do(println, xs)
\end{lstlisting}
which prints out
\begin{lstlisting}
1
2
4
8
16
32
64
128
256
512
1024
\end{lstlisting}

\subsection*{Sequence Operators}
Sequence operators are functions that take \texttt{\frenchspacing Seq} (or \texttt{\frenchspacing Seqable}) arguments and create and return \texttt{\frenchspacing Seq} objects. The lazy \texttt{\frenchspacing cum-sum} function that we implemented is an example of a sequence operator. 

\subsection*{cat}
One of the simplest sequence operators is the \texttt{\frenchspacing cat} function which simply concatenates two sequences together to form a longer sequence.
Here is an example.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
val ys = ["Sunny", "Whiskey", "Rummy"]
val zs = cat(xs, ys)
do(println, zs)
\end{lstlisting}
which prints out
\begin{lstlisting}
Patrick
Luca
Emmy
Sunny
Whiskey
Rummy
\end{lstlisting}

\subsection*{join}
\texttt{\frenchspacing join} is another simple sequence operator that takes a sequence, \texttt{\frenchspacing xs}, and a joiner item, \texttt{\frenchspacing x}, and creates a {\em lazy} sequence by inserting \texttt{\frenchspacing x} in between each item in \texttt{\frenchspacing xs}.
Here is an example.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
val zs = join(xs, "and")
do(println, zs)
\end{lstlisting}
which prints out
\begin{lstlisting}
Patrick
and
Luca
and
Emmy
\end{lstlisting}

\subsection*{take-n}
The \texttt{\frenchspacing take-n} function takes an integer, \texttt{\frenchspacing n}, and a sequence, \texttt{\frenchspacing xs}, and returns a {\em lazy} sequence consisting of the first \texttt{\frenchspacing n} elements in \texttt{\frenchspacing xs}. It is a fatal error to call \texttt{\frenchspacing take-n} on a sequence with less than \texttt{\frenchspacing n} items.
Here is an example of using \texttt{\frenchspacing take-n} to print out the first 10 items in an infinite range.
\begin{lstlisting}
val xs = 0 to false by 13
do(println, take-n(10, xs))
\end{lstlisting}
which prints out
\begin{lstlisting}
0
13
26
39
52
65
78
91
104
117
\end{lstlisting}

\subsection*{filter}
The \texttt{\frenchspacing filter} function takes a predicate function, \texttt{\frenchspacing f}, and a sequence, \texttt{\frenchspacing xs}, and returns a {\em lazy} sequence consisting only of the items in \texttt{\frenchspacing xs} for which calling \texttt{\frenchspacing f} on them returns \texttt{\frenchspacing true}. \texttt{\frenchspacing filter} is also an operating function.
Here is an example of using \texttt{\frenchspacing filter} to print out only the positive items in a sequence.
\begin{lstlisting}
val xs = [1, 3, -2, -7, 3, -8, 9, 10, -3]
val ys = filter({_ > 0}, xs)
do(println, ys)   
\end{lstlisting}
which prints out
\begin{lstlisting}
1
3
3
9
10
\end{lstlisting}

\subsection*{seq}
The \texttt{\frenchspacing seq} function is the most commonly used sequence operator. It takes a function, \texttt{\frenchspacing f}, and a sequence, \texttt{\frenchspacing xs}, and returns a {\em lazy} sequence comprised of the results of calling \texttt{\frenchspacing f} on each item in the sequence.
Here is an example of printing out the length of each string in a sequence.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy", "Sunny", "Whiskey", "Rummy"]
val ys = seq(length, xs)
do(println, ys)
\end{lstlisting}
which prints out
\begin{lstlisting}
7
4
4
5
7
5
\end{lstlisting}

\subsection*{Sequence Reducers}
Sequence reducers are functions that take \texttt{\frenchspacing Seq} (or \texttt{\frenchspacing Seqable}) arguments and return non-\texttt{\frenchspacing Seq} objects. 

We have already been introduced to and have been using a number of these, such as \texttt{\frenchspacing do}, \texttt{\frenchspacing find}, \texttt{\frenchspacing first}, \texttt{\frenchspacing index-when}, \texttt{\frenchspacing all?}, \texttt{\frenchspacing none?}, and \texttt{\frenchspacing any?}. We'll take this opportunity to say that they each accept any \texttt{\frenchspacing Seqable} object as their argument. 

We'll show you a handful more useful reducers here, but you are encouraged to read the reference documentation for a listing of all of them. 

\subsection*{contains?}
\texttt{\frenchspacing contains?} takes a sequence, \texttt{\frenchspacing xs}, and an item, \texttt{\frenchspacing y}, and returns \texttt{\frenchspacing true} if \texttt{\frenchspacing xs} contains \texttt{\frenchspacing y}. Otherwise it returns \texttt{\frenchspacing false}.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
println(contains?(xs, "Emmy"))
println(contains?(xs, "Emily"))
\end{lstlisting}
prints out
\begin{lstlisting}
true
false
\end{lstlisting}

\subsection*{index-of}
\texttt{\frenchspacing index-of} takes a sequence, \texttt{\frenchspacing xs}, and an item, \texttt{\frenchspacing y}, and returns the index of the first occurrence of \texttt{\frenchspacing y} in \texttt{\frenchspacing xs}. If \texttt{\frenchspacing y} never appears in \texttt{\frenchspacing xs}, then \texttt{\frenchspacing false} is returned.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
println(index-of(xs, "Emmy"))
println(index-of(xs, "Emily"))
\end{lstlisting}
prints out
\begin{lstlisting}
2
false
\end{lstlisting}

\subsection*{unique}
\texttt{\frenchspacing unique} takes a sequence, \texttt{\frenchspacing xs}, and returns a {\em list} containing all the items in \texttt{\frenchspacing xs} but with duplicates removed. 
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Luca", "Emmy", "Patrick", "Emmy"]
println(unique(xs))
\end{lstlisting}
prints out
\begin{lstlisting}
("Patrick" "Luca" "Emmy")
\end{lstlisting}

\subsection*{to-array}
\texttt{\frenchspacing to-array} creates a new array containing all the items in its given sequence. It takes a single {\em type argument} to indicate the element type of the array. We will discuss type arguments when we introduce parametric polymorphism. 
Here is an example.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
println(to-array<String>(xs))
\end{lstlisting}
prints out
\begin{lstlisting}
["Patrick" "Luca" "Emmy"]
\end{lstlisting}

\subsection*{to-vector}
\texttt{\frenchspacing to-vector} creates a new vector containing all the items in its given sequence. Like \texttt{\frenchspacing to-array}, it also takes a single type argument to indicate the element type of the vector. 
Here is an example.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
println(to-vector<String>(xs))
\end{lstlisting}

\subsection*{to-list}
\texttt{\frenchspacing to-list} creates a new {\em list} containing all the items in its given sequence. Note that unlike \texttt{\frenchspacing to-array} and \texttt{\frenchspacing to-vector}, \texttt{\frenchspacing to-list} does {\em not} take a type argument. We will cover lists in more detail when we talk about programming with immutable datastructures. For now, you can treat them just as another type of collection. And we will explain why \texttt{\frenchspacing to-list} does not require a type argument in the chapter on parametric polymorphism.
Here is an example.
\begin{lstlisting}
val xs = ["Patrick", "Luca", "Emmy"]
println(to-list(xs))
\end{lstlisting}
which prints out
\begin{lstlisting}
("Patrick" "Luca" "Emmy")
\end{lstlisting}

\subsection*{reduce}
\texttt{\frenchspacing reduce} takes a binary operator, \texttt{\frenchspacing f}, an initial item, \texttt{\frenchspacing x0}, and a sequence, \texttt{\frenchspacing xs}. If \texttt{\frenchspacing xs} is empty then \texttt{\frenchspacing reduce} returns \texttt{\frenchspacing x0}. If \texttt{\frenchspacing xs} contains one item, then \texttt{\frenchspacing reduce} returns the result of calling \texttt{\frenchspacing f} on \texttt{\frenchspacing x0} and the item in \texttt{\frenchspacing xs}. If \texttt{\frenchspacing xs} contains two items, then \texttt{\frenchspacing reduce} returns the result of calling \texttt{\frenchspacing f} on \texttt{\frenchspacing x0} and the first item in \texttt{\frenchspacing xs}, and then calling \texttt{\frenchspacing f} again on that result and the second item in \texttt{\frenchspacing xs}. If \texttt{\frenchspacing xs} contains three items, then \texttt{\frenchspacing reduce} returns the result of calling \texttt{\frenchspacing f} on \texttt{\frenchspacing x0} and the first item in \texttt{\frenchspacing xs}, then calling \texttt{\frenchspacing f} again on that result and the second item in \texttt{\frenchspacing xs}, and then calling \texttt{\frenchspacing f} again on that result and the third item in \texttt{\frenchspacing xs}. Et cetera. 

Here is an example of using the \texttt{\frenchspacing bit-or} operator to compute the bitwise or of every integer in a tuple.
\begin{lstlisting}
val xs = [1, 5, 18, 92, 1, 3]
val y = reduce(bit-or, 0, xs)
println(y)
\end{lstlisting}
which prints out
\begin{lstlisting}
95
\end{lstlisting}

\section{Collection versus Seqable}
Consider the following definition of \texttt{\frenchspacing print-odd-then-even}, a function that first prints all the odd integers in a sequence, and then prints all the even integers in the sequence.
\begin{lstlisting}
defn print-odd-then-even (xs:Seqable<Int>) :
   val odd = filter({_ % 2 != 0}, xs)
   val even = filter({_ % 2 == 0}, xs)
   print("Odd integers: ")
   println-all(join(odd, ", "))
   print("Even integers: ")
   println-all(join(even, ", "))
\end{lstlisting}
Because we declared \texttt{\frenchspacing print-odd-then-even} to accept an argument of type \texttt{\frenchspacing Seqable}, we are able to call it on a variety of different types of collections. Let's try a few.
\begin{lstlisting}
defn main () :
   val xs = [1, 2, 3, 4, 5, 6, 7, 8]
   val ys = to-array<Int>([1, 2, 3, 4, 5, 6, 7, 8])
   val zs = to-vector<Int>([1, 2, 3, 4, 5, 6, 7, 8])
   val ws = 1 through 8
   
   println("On tuples")
   print-odd-then-even(xs)

   println("On arrays")
   print-odd-then-even(ys)

   println("On vectors")
   print-odd-then-even(zs)

   println("On ranges")
   print-odd-then-even(ws)

main()   
\end{lstlisting}
It prints out
\begin{lstlisting}
On tuples
Odd integers: 1, 3, 5, 7
Even integers: 2, 4, 6, 8
On arrays
Odd integers: 1, 3, 5, 7
Even integers: 2, 4, 6, 8
On vectors
Odd integers: 1, 3, 5, 7
Even integers: 2, 4, 6, 8
On ranges
Odd integers: 1, 3, 5, 7
Even integers: 2, 4, 6, 8
\end{lstlisting}
demonstrating that it does the same thing regardless of the type of collection. 

But now let's try calling it on a \texttt{\frenchspacing Seq}. All \texttt{\frenchspacing Seq} objects are also trivially instances of \texttt{\frenchspacing Seqable}. Calling \texttt{\frenchspacing to-seq} on a \texttt{\frenchspacing Seq} object simply returns itself. 
\begin{lstlisting}
defn main2 () :
   val xs = to-seq(1 through 8)
   println("On seqs")
   print-odd-then-even(xs)

main2()
\end{lstlisting}
This print outs
\begin{lstlisting}
On seqs
Odd integers: 1, 3, 5, 7
Even integers: 
\end{lstlisting}
What is happening? How come the even integers didn't get printed out? 

The problem lies in the two calls to \texttt{\frenchspacing filter}.
\begin{lstlisting}
val odd = filter({_ % 2 != 0}, xs)
val even = filter({_ % 2 == 0}, xs)
\end{lstlisting}
\texttt{\frenchspacing filter} creates a lazy sequence, so iterating over the result of \texttt{\frenchspacing filter} also requires iterating over the sequence it was constructed from. Thus printing out \texttt{\frenchspacing odd} also requires iterating over \texttt{\frenchspacing xs}, in which case, after printing out all the odd integers, we will have iterated through \texttt{\frenchspacing xs} once completely and it will now be empty. At this point, \texttt{\frenchspacing even} is also empty, as the sequence it was constructed from is now empty.

The fundamental problem is that \texttt{\frenchspacing Seq} is a subtype of \texttt{\frenchspacing Seqable}. Calling \texttt{\frenchspacing to-seq} twice on a \texttt{\frenchspacing Seq} object does {\em not} return two independent sequences. For these purposes, Stanza provides a subtype of \texttt{\frenchspacing Seqable} called \texttt{\frenchspacing Collection}. Identical to \texttt{\frenchspacing Seqable}, \texttt{\frenchspacing to-seq} is the only fundamental operation supported by \texttt{\frenchspacing Collection}. The crucial difference is that \texttt{\frenchspacing Seq} is not a subtype of \texttt{\frenchspacing Collection}. This means that each call to \texttt{\frenchspacing to-seq} on a \texttt{\frenchspacing Collection} returns an independent sequence. 

Let's rewrite our \texttt{\frenchspacing print-odd-then-even} function with the appropriate type annotation.
\begin{lstlisting}
defn print-odd-then-even (xs:Collection<Int>) :
   val odd = filter({_ % 2 != 0}, xs)
   val even = filter({_ % 2 == 0}, xs)
   print("Odd integers: ")
   println-all(join(odd, ", "))
   print("Even integers: ")
   println-all(join(even, ", "))
\end{lstlisting}

You may verify that calling \texttt{\frenchspacing print-odd-then-even} with all the collections in \texttt{\frenchspacing main} still behaves as before. The important point is that attempting to compile \texttt{\frenchspacing main2} now gives this error.
\begin{lstlisting}
Cannot call function print-odd-then-even of type Collection<Int> -> False
with arguments of type (Seq<Int>).
\end{lstlisting}
With the appropriate type annotation, Stanza now prevents us from calling \texttt{\frenchspacing print-odd-then-even} incorrectly.

As a rule of thumb, you should always write your functions to accept \texttt{\frenchspacing Collection} objects by default. If you are sure that you iterate through the sequence only once, then you may change it to accept \texttt{\frenchspacing Seqable} objects in order to be able to pass it a \texttt{\frenchspacing Seq}.

\section{Revisiting Stack}
Let us now revisit our \texttt{\frenchspacing Stack} type from chapter 4. Here is a (slightly cleaned up) listing of its definitions.
\begin{lstlisting}
deftype Stack
defmulti push (s:Stack, x:String) -> False
defmulti pop (s:Stack) -> String
defmulti empty? (s:Stack) -> True|False

defn Stack (capacity:Int) -> Stack :
   val items = Array<String>(capacity)
   var size = 0
   new Stack :
      defmethod push (this, x:String) :
         if size == capacity : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         print-all(o, join(take-n(size, items), " "))
         print(o, "]")
\end{lstlisting}
It's quite a basic definition, allowing us to push and pop items but not much else. We cannot find the index of a specific item, or determine whether it contains any capitalized strings, or get a listing of all of its unique elements. We cannot even iterate through it. The following
\begin{lstlisting}
val s = Stack(10)
push(s, "Timon")
push(s, "and")
push(s, "Pumbaa")

for x in s do :
   println(x)
\end{lstlisting}
gives us this error if we try to compile it.
\begin{lstlisting}
No appropriate function do for arguments
of type (? -> False, Stack). Possibilities are:
   do: <?T> . (T -> ?, Seqable<?T>) -> False
   do: <?T, ?S> . ((T, S) -> ?,
                   Seqable<?T>,
                   Seqable<?S>) -> False
   do: <?T, ?S, ?U> . ((T, S, U) -> ?, Seqable<?T>,
                       Seqable<?S>,
                       Seqable<?U>) -> False
\end{lstlisting}
It says that there are multiple definitions of \texttt{\frenchspacing do} but all of them require a \texttt{\frenchspacing Seqable} argument, and \texttt{\frenchspacing Stack} is not a \texttt{\frenchspacing Seqable}.  

We shall extend the functionality of \texttt{\frenchspacing Stack} by declaring it as a subtype of \texttt{\frenchspacing Collection}. 
\begin{lstlisting}
deftype Stack <: Collection<String>
\end{lstlisting}
The mandatory minimal implementation of \texttt{\frenchspacing Collection} is \texttt{\frenchspacing to-seq}, so we need to now provide a method for it. Here is now our extended \texttt{\frenchspacing Stack} construction function.
\begin{lstlisting}
defn Stack (capacity:Int) -> Stack :
   val items = Array<String>(capacity)
   var size = 0
   new Stack :
      defmethod push (this, x:String) :
         if size == capacity : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         print-all(o, join(this, " "))
         print(o, "]")
      defmethod to-seq (this) :
         take-n(size, items)
\end{lstlisting}
Our implementation of \texttt{\frenchspacing to-seq} simply calls \texttt{\frenchspacing take-n} to retrieve the first \texttt{\frenchspacing size} elements from the backing array \texttt{\frenchspacing items}.

Now let's try exercising the power of our new extended \texttt{\frenchspacing Stack} type. 
\begin{lstlisting}
defn main () :
   val s = Stack(10)
   for x in ["Timon", "Timon", "and", "Pumbaa", "Pumbaa"] do :
      push(s, x)

   println("1. Contents of s")
   println(s)

   println("\n2. Index of Pumbaa")
   println(index-of(s, "Pumbaa"))

   println("\n3. Does it contain any capitalized strings?")
   println(any?(upper-case?{_[0]}, s))

   println("\n4. Are all strings capitalized?")
   println(all?(upper-case?{_[0]}, s))

   println("\n5. What are the capitalized strings?")
   val cap-s = filter(upper-case?{_[0]}, s)
   println-all(join(cap-s, ", "))

   println("\n6. What are its unique elements?")
   println(unique(s))

main()
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
1. Contents of s
Stack containing [Timon Timon and Pumbaa Pumbaa]

2. Index of Pumbaa
3

3. Does it contain any capitalized strings?
true

4. Are all strings capitalized?
false

5. What are the capitalized strings?
Timon, Timon, Pumbaa, Pumbaa

6. What are its unique elements?
("Timon" "and" "Pumbaa")
\end{lstlisting}

This example shows us the full advantage of structuring your programs to contain a large library of derived operations. With a two line change to our definition of the \texttt{\frenchspacing Stack} object, we've provided it the full capabilities of Stanza's sequence library.  

\chapter{Programming with Immutable Datastructures}
An immutable datastructure is one that cannot be {\em changed} after it has been created. Some examples you've already seen are strings, tuples, numbers, and true and false. In constrast, a {\em mutable} datastructure is one that can be changed after it has been created. Some examples are arrays, vectors, and sequences. 

If something is guaranteed not to change, then there are two details that you no longer have to worry about.
\begin{enumerate}
\item You don't have to care about {\em which} object it is. There is no difference between the value \texttt{\frenchspacing 42} and the value \texttt{\frenchspacing 20 + 22}. They are the same value. You can replace every occurrence of \texttt{\frenchspacing 42} in your program with \texttt{\frenchspacing 20 + 22} and it will still behave the same way. Similarly, you can replace every occurrence of 
\begin{lstlisting}
"Timon and Pumbaa"
\end{lstlisting}
in your program with 
\begin{lstlisting}
append("Timon", " and Pumbaa")
\end{lstlisting}
without changing its behaviour. 

In contrast, consider the following call for adding a number to a vector.
\begin{lstlisting}
add(xs, 42)
\end{lstlisting}
Now you {\em do} need to pay very close attention to which vector \texttt{\frenchspacing xs} is referring to. It would be an error to add 42 to the wrong vector.

\item You don't have to think about {\em when} to do something to an object. Consider the following code for popping an item from the vector \texttt{\frenchspacing xs} and then adding two new items to it.
\begin{lstlisting}
pop(xs)
add(xs, 42)
add(xs, 43)
\end{lstlisting}
The ordering of those expressions are critically important. Every possible ordering of those three expressions results in a different behaviour. Notice that this sort of thinking is never done with strings, tuples, or numbers; simply because there's nothing than {\em can} be done to them except to create new objects out of them.
\end{enumerate} 

\section{Lists}
A \texttt{\frenchspacing List} object represents a singly linked list of objects. A list is Stanza's most basic immutable datastructure and cannot be changed once created. Here is how to create an empty list.
\begin{lstlisting}
List()
\end{lstlisting}
Here is how to create a list containing a single item.
\begin{lstlisting}
List(42)
\end{lstlisting}
Here is how to create a list containing two items.
\begin{lstlisting}
List(42, "Timon")
\end{lstlisting}
This works for lists containing up to four items. For creating lists containing more than four items, you may use the \texttt{\frenchspacing to-list} function to convert sequences into lists.
\begin{lstlisting}
to-list([1, 2, 3, 4, 5, "Timon", "and", "Pumbaa"])
\end{lstlisting}

You may also use \texttt{\frenchspacing cons} (short for construct) to create a new list by tacking a new item to the beginning of an existing list.
\begin{lstlisting}
val xs = List(1, 2, 3)
val ys = cons(42, xs)
\end{lstlisting}
\texttt{\frenchspacing cons} allows you to tack on up to three items.
\begin{lstlisting}
val xs = List(1, 2, 3)
val ys0 = cons(42, xs)
val ys1 = cons(42, 43, xs)
val ys2 = cons(42, 43, 44, xs)
\end{lstlisting}

To append more than three items to the beginning of another list, use the \texttt{\frenchspacing append} function.
\begin{lstlisting}
val xs = List(1, 2, 3)
val ys = append([42, 43, 44, 45, 46, 47], xs)
println(ys)
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
(42 43 44 45 46 47 1 2 3)
\end{lstlisting}

\subsection*{Fundamental Operations}
A list is defined by three fundamental operations.
\begin{enumerate}
\item You can check whether the list is empty.
\item You can retrieve the first element in the list.
\item You can retrieve a list containing all the elements after the first one.
\end{enumerate}

Assuming that \texttt{\frenchspacing xs} is a list, here is how to check whether \texttt{\frenchspacing xs} is empty.
\begin{lstlisting}
empty?(xs)
\end{lstlisting}
Here is how to retrieve the first element in \texttt{\frenchspacing xs}.
\begin{lstlisting}
head(xs)
\end{lstlisting}
And here is how to retrieve all the elements after the first one, as another list.
\begin{lstlisting}
tail(xs)
\end{lstlisting}

\section{Example: Coin Counting}
Suppose you have access to pennies, nickels, dimes, quarters, and {\em loonies}, and the poutine you bought costs \$1.17. (Loonies are Canadian coins worth 100 cents each.) How may different combinations of coins are there that total up to \$1.17? 

Here is our algorithm for calculating it. \texttt{\frenchspacing num-coin-combos} takes two arguments: \texttt{\frenchspacing cents}, which represents the amount of money you wish to make represented in cents, and \texttt{\frenchspacing coins}, a list of the cent values of the coins you can use. 
\begin{lstlisting}
defn num-coin-combos (cents:Int, coins:List<Int>) -> Int :
   if cents == 0 :
      1
   else if cents < 0 :
      0
   else if empty?(coins) :
      0
   else :
      val with-first-coin = num-coin-combos(cents - head(coins), coins)
      val without-first-coin = num-coin-combos(cents, tail(coins))
      with-first-coin + without-first-coin
\end{lstlisting}
Let's read through each case of the algorithm one by one. The first case is
\begin{lstlisting}
if cents == 0 :
   1
\end{lstlisting}
There is only one way to make 0 cents, and that is to not use any coins at all. Makes sense.
The second case is
\begin{lstlisting}
else if cents < 0 :
   0
\end{lstlisting}
There is no way to make a negative cent value. Makes sense.
The third case is
\begin{lstlisting}
else if empty?(coins) :
   0
\end{lstlisting}
If we're not allowed to use {\em any} kind of coin, then there's also no way to make our total. Makes sense as well.
The real work of the algorithm is done by the fourth case.
\begin{lstlisting}
val with-first-coin = num-coin-combos(cents - head(coins), coins)
val without-first-coin = num-coin-combos(cents, tail(coins))
with-first-coin + without-first-coin
\end{lstlisting}
Consider the next type of coin in our list. Suppose it's a loonie. There are two choices we can now make. 
\begin{enumerate}
\item We can account for 100 cents by using the loonie, and count the number of ways to make \texttt{\frenchspacing cents - 100}. This is calculated as \texttt{\frenchspacing with-first-coin}.
\item We can choose not to use the loonie, and count the number of ways to make \texttt{\frenchspacing cents} without using loonies. This is calculated as \texttt{\frenchspacing without-first-coin}.
\end{enumerate}
The total number of combinations is the sum of the results of the two possible choices we can make.

Let's now use our \texttt{\frenchspacing num-coin-combos} function to answer the original question.
\begin{lstlisting}
defn main () :
   val coins = [100, 25, 10, 5, 1]
   val num-combos = num-coin-combos(117, to-list(coins))
   println("There are %_ coin combinations that total to 117 cents." %
           [num-combos])

main()
\end{lstlisting}
which prints out
\begin{lstlisting}
There are 349 coin combinations that total to 117 cents.
\end{lstlisting}

\subsection*{Strange Lands}
Suppose we find ourselves in strange lands with a strange currency. The currency is made up of {\em buzzles}, with a value of 57 cents, {\em moozles} (26 cents), {\em foogs} (10 cents), {\em goofs} (5 cents), and {\em tents} (3 cents). Now how many ways are there to make the \$1.17 needed to buy poutine? (Though the currency may be strange, poutine is fairly universal). 

Let's adapt our \texttt{\frenchspacing main} function to calculate with the new currency.
\begin{lstlisting}
defn main () :
   val coins = [57, 26, 10, 5, 3]
   val num-combos = num-coin-combos(117, to-list(coins))
   println("There are %_ coin combinations that total to 117 cents." %
           [num-combos])

main()
\end{lstlisting}
which prints out
\begin{lstlisting}
There are 137 coin combinations that total to 117 cents.
\end{lstlisting}
indicating that buzzles and foogs are a little less flexible than Canadian currency.

\subsection*{SICP}
This exercise is adapted from the best book on computer science ever written, {\em The Structure and Interpretation of Computer Programs} by Abelson and Sussman. I highly recommend it to anyone interested in the deep connections between languages and computation. And since Stanza is a (highly modified) Scheme dialect at heart, all the exercises can easily be done in Stanza as well.

\section{List Library}
\texttt{\frenchspacing List} is a subtype of \texttt{\frenchspacing Collection} and so all of Stanza's sequence library also works on lists. The core library also includes a few functions specifically for managing lists. You've been introduced to a few of them already: \texttt{\frenchspacing head}, \texttt{\frenchspacing tail}, \texttt{\frenchspacing append}, \texttt{\frenchspacing cons}. Here's a few more.

\subsection*{get}
The \texttt{\frenchspacing get} function allows you to retrieve the element at a specific index in a list. 
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
get(xs, 11)
\end{lstlisting}
Using Stanza's built-in operator, the above could also be written as
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
xs[11]
\end{lstlisting}

\subsection*{headn}
\texttt{\frenchspacing headn} returns a list containing the first n items in a list.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
headn(xs, 10)
\end{lstlisting}

\subsection*{tailn}
\texttt{\frenchspacing tailn} returns a new list containing the items following the first n items in a list.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
tailn(xs, 10)
\end{lstlisting}

\subsection*{reverse}
\texttt{\frenchspacing reverse} takes an argument list and returns a new list containing the same items in reversed order.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
reverse(xs)
\end{lstlisting}

\subsection*{last}
\texttt{\frenchspacing last} takes an argument list and returns the last item in it. The list must not be empty.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
last(xs)
\end{lstlisting}

\subsection*{but-last}
\texttt{\frenchspacing but-last} takes an argument list and returns a new list containing all the items from the argument list except the last one.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
but-last(xs)
\end{lstlisting}

\subsection*{map}
\texttt{\frenchspacing map} is the most commonly used function on lists. It takes an argument function, \texttt{\frenchspacing f}, and a list, \texttt{\frenchspacing xs}, and returns a new list containing the results of calling \texttt{\frenchspacing f} on each item.

Here is an example that calculates the lengths of all the strings in the list \texttt{\frenchspacing xs}.
\begin{lstlisting}
val xs = to-list(["Timon" "and" "Pumbaa"])
val lengths = map(length, xs)
\end{lstlisting}

\texttt{\frenchspacing map} is also an operating function, and it can be used together with the for construct. Here is an example of doubling every integer in the list \texttt{\frenchspacing xs}.
\begin{lstlisting}
val xs = to-list(0 to 1000 by 3)
val doubled = for x in xs map :
   x * 2
\end{lstlisting}

\section{Example: More Coin Counting}
One limitation of our previous algorithm for coin counting is that it calculated the number of ways we can make a certain total, but it never told us what these combinations actually were. You may be (as I was) actually quite curious about how to make \$1.17 using buzzles and foogs.

Let's write a function called \texttt{\frenchspacing coin-combos} that does that. Like \texttt{\frenchspacing num-coin-combos}, \texttt{\frenchspacing coin-combos} takes two arguments: \texttt{\frenchspacing cents}, which represents the number of cents you wish to make, and \texttt{\frenchspacing coins}, a list of the cent values of the coins. The difference is that \texttt{\frenchspacing coin-combos} returns a list of {\em combinations}. Each combination is a list containing the number of times each coin is used.
\begin{lstlisting}
defn coin-combos (cents:Int, coins:List<Int>) -> List<List<Int>> :
   if cents == 0 :
      List(map({0}, coins))
   else if cents < 0 :
      List()
   else if empty?(coins) :
      List()
   else :
      defn head+1 (xs:List<Int>) : cons(head(xs) + 1, tail(xs))
      defn cons-0 (xs:List<Int>) : cons(0, xs)
      val with-first-coin = map(head+1, coin-combos(cents - head(coins), coins))
      val without-first-coin = map(cons-0, coin-combos(cents, tail(coins)))
      append(with-first-coin, without-first-coin)
\end{lstlisting}
Let's examine each case separately.
\begin{lstlisting}
if cents == 0 :
   List(map({0}, coins))
\end{lstlisting}
There is only one way to make up 0 cents, and that is by using no coins at all. So return a list with a single combination indicating that each coin is used 0 times. 
\begin{lstlisting}
else if cents < 0 :
   List()
\end{lstlisting}
There is no way to make a negative total so return an empty list.
\begin{lstlisting}
else if empty?(coins) :
   List()
\end{lstlisting}
If we're not allowed to use {\em any} kind of coin, then there's also no way to make our total. Return an empty list.
And finally, we're at the last case again.
\begin{lstlisting}
val with-first-coin = map(head+1, coin-combos(cents - head(coins), coins))
val without-first-coin = map(cons-0, coin-combos(cents, tail(coins)))
append(with-first-coin, without-first-coin)
\end{lstlisting}
All the combinations resulting from choosing to use the first coin are computed in \texttt{\frenchspacing with-first-coin}. And all the combinations resulting from choosing not to use the first coin are computed in \texttt{\frenchspacing without-first-coin}. We then append both lists to get the complete list of combinations.

The fourth case relies upon two helper functions, \texttt{\frenchspacing head+1}, which adds 1 to the head of a list, and \texttt{\frenchspacing cons-0}, which tacks 0 on to the beginning of a list. 
\begin{lstlisting}
defn head+1 (xs:List<Int>) : cons(head(xs) + 1, tail(xs))
defn cons-0 (xs:List<Int>) : cons(0, xs)
\end{lstlisting}

Let's now update our \texttt{\frenchspacing main} function to report all the different ways we can use buzzles and foogs to make \$1.17. Recall that buzzles are worth 57 cents, moozles are 26 cents, foogs are 10 cents, goofs are 5 cents, and tents are 3 cents.
\begin{lstlisting}
defn main () :
   val coins = [57, 26, 10, 5, 3]
   val combos = coin-combos(117, to-list(coins))
   println("There are %_ coin combinations that total to 117 cents." % [
      length(combos)])
   do(println, combos)

main()
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
There are 137 coin combinations that total to 117 cents.
(2 0 0 0 1)
(1 2 0 1 1)
(1 1 2 1 3)
(1 1 1 3 3)
...
(0 0 0 6 29)
(0 0 0 3 34)
(0 0 0 0 39)
\end{lstlisting}
Thus we can pay for our \$1.17 poutine using two buzzles and a foog. Or if we don't mind holding up the line, we can hunt around for thirty nine tents. 

\subsection*{Readable Combos}
For the sake of readability, let's write a printing function for formatting the combinations in a readable way. \texttt{\frenchspacing print-combo} takes as arguments a combination, \texttt{\frenchspacing combo}, and a collection representing the names of the coins, \texttt{\frenchspacing names}. 
\begin{lstlisting}
defn print-combo (combo:List<Int>, names:Collection<String>) :
   val parts = for (c in combo, n in names) seq? :
      if c == 0 : None()
      else if c == 1 : One("%_ %_" % [c, n])
      else : One("%_ %_s" % [c, n])
   println-all(join(parts, ", "))   
\end{lstlisting}
You are encouraged to read the reference documentation for a description of what \texttt{\frenchspacing seq?} does. You should be able to understand it now.

Now update the final call to \texttt{\frenchspacing print} in the \texttt{\frenchspacing main} function.
\begin{lstlisting}
val coin-names = ["buzzle", "moozle", "foog", "goof", "tent"]
do(print-combo{_, coin-names}, combos)
\end{lstlisting}
Compiling and running the program now prints out
\begin{lstlisting}
There are 137 coin combinations that total to 117 cents.
2 buzzles, 1 tent
1 buzzle, 2 moozles, 1 goof, 1 tent
1 buzzle, 1 moozle, 2 foogs, 1 goof, 3 tents
1 buzzle, 1 moozle, 1 foog, 3 goofs, 3 tents
...
15 goofs, 14 tents
12 goofs, 19 tents
9 goofs, 24 tents
6 goofs, 29 tents
3 goofs, 34 tents
39 tents
\end{lstlisting}

\section{Extended Example: Automatic Differentiation}
In your own programming, you are encouraged to define and use immutable datastructures when possible. Uses of mutation and stateful objects should serve a clear purpose. In this example, we define an immutable datastructure for manipulating algebra expressions and write a function for automatically differentiating expressions.

\subsection*{Symbols}
\texttt{\frenchspacing Symbol} objects are used to represent a unique constant object in Stanza. For example, the following creates and assigns symbols to \texttt{\frenchspacing x} and to \texttt{\frenchspacing y}.
\begin{lstlisting}
val x = `Timon
val y = `Pumbaa
\end{lstlisting}
Symbols are created by prefixing an identifier with the backtick (`) operator. Very little can be done with symbols except check whether it is equal to another symbol. The following
\begin{lstlisting}
println(x == `Timon)
println(y == `Timon)
\end{lstlisting}
prints out
\begin{lstlisting}
true
false
\end{lstlisting}
and represents the most common use case for symbols. In this respect they are used in much the same way as enumerated constants in other languages. We will use symbols to represent the name of variables in our algebraic expressions.

\subsection*{The Expression Datastructure}
We will first declare a type, \texttt{\frenchspacing Exp}, to refer to an algebraic expression. 
\begin{lstlisting}
deftype Exp
defstruct Const <: Exp : (value:Int)
defstruct Variable <: Exp : (name:Symbol)
defstruct Add <: Exp : (a:Exp, b:Exp)
defstruct Subtract <: Exp : (a:Exp, b:Exp)
defstruct Multiply <: Exp : (a:Exp, b:Exp)
defstruct Divide <: Exp : (a:Exp, b:Exp)
defstruct Power <: Exp : (a:Exp, b:Exp)
defstruct Log <: Exp : (a:Exp)
\end{lstlisting}
A handful of different types of expressions are supported. \texttt{\frenchspacing Const} represents constant integer literals, \texttt{\frenchspacing Variable} represents a named variable, and the standard arithmetic operators are represented by \texttt{\frenchspacing Add}, \texttt{\frenchspacing Subtract}, \texttt{\frenchspacing Multiply}, and \texttt{\frenchspacing Divide}. \texttt{\frenchspacing Power} represents one expression raised to the power of another, and \texttt{\frenchspacing Log} represents the natural logarithm of an expression. Notice that many of the expressions contain fields that are themselves types of \texttt{\frenchspacing Exp}. So the type \texttt{\frenchspacing Exp} contains fields of type \texttt{\frenchspacing Exp}. We call such a type a {\em recursive} type.

\subsection*{Printing an Expression}
As usual, we will provide a custom \texttt{\frenchspacing print} method for the \texttt{\frenchspacing Exp} type to allow us to print it out.
\begin{lstlisting}
defmethod print (o:OutputStream, e:Exp) :
   defn print-operator (a:Exp, op:String, b:Exp) :
      print(o, a)
      print(o, op)
      print(o, b)
   match(e) :
      (e:Const) : print(o, value(e))
      (e:Variable) : print(o, name(e))
      (e:Log) : print(o, "ln(%_)" % [a(e)])
      (e:Add) : print-operator(a(e), " + ", b(e))
      (e:Subtract) : print-operator(a(e), " - ", b(e))
      (e:Multiply) : print-operator(a(e), " * ", b(e))
      (e:Divide) : print-operator(a(e), " / ", b(e))
      (e:Power) : print-operator(a(e), " ^ ", b(e))
\end{lstlisting}

Let's now create an expression and print it out. The expression we will create is 
\begin{lstlisting}
2 * x ^ 2 + (1 + 3) * x + ln(x + 4)
\end{lstlisting} 
Here is our \texttt{\frenchspacing main} function.
\begin{lstlisting}
defn main () :
   val term1 = Multiply(Const(2), Power(Variable(`x), Const(2)))
   val term2 = Multiply(Add(Const(1), Const(3)), Variable(`x))
   val term3 = Log(Add(Variable(`x), Const(4)))
   val exp = Add(Add(term1, term2), term3)
   println(exp)   

main()
\end{lstlisting}

Compiling and running the above prints out
\begin{lstlisting}
2 * x ^ 2 + 1 + 3 * x + ln(x + 4)
\end{lstlisting}
We're off to a great start! 

\subsection*{Handling Precedence}
Our printing method for expressions is close, but it doesn't handle precedences correctly. The \texttt{\frenchspacing 1 + 3} in the printed expression should be surrounded by parentheses. Otherwise the meaning is different than intended.

Let's add a mechanism to handle precedences properly. Here's the basic algorithm. Every type of expression is associated with a number that represents its precedence. \texttt{\frenchspacing Const}, \texttt{\frenchspacing Log}, and \texttt{\frenchspacing Variable} expressions have the highest precedence 3. \texttt{\frenchspacing Power} has precedence 2. \texttt{\frenchspacing Multiply} and \texttt{\frenchspacing Divide} have precedence 1. And \texttt{\frenchspacing Add} and \texttt{\frenchspacing Subtract} have the lowest precedence 0. 
\begin{lstlisting}
defn precedence (e:Exp) :
   match(e) :
      (e:Add|Subtract) : 0
      (e:Multiply|Divide|Power) : 1
      (e:Power) : 2
      (e:Const|Variable|Log) : 3
\end{lstlisting}

The basic rule is that if a lower precedence expression appears as a child of a higher precedence expression, then the lower precedence expression needs to be surrounded by parentheses when printed out. So we'll define a new nested function within \texttt{\frenchspacing print} to help us print nested expressions in the context of expression \texttt{\frenchspacing e}. 
\begin{lstlisting}
defn print-nested (ne:Exp) :
   if precedence(ne) < precedence(e) :
      print(o, "(%_)" % [ne])
   else :
      print(o, ne)
\end{lstlisting}
If the nested expression \texttt{\frenchspacing ne} has lower precedence than \texttt{\frenchspacing e}, then \texttt{\frenchspacing ne} is printed with surrounding parentheses. Otherwise \texttt{\frenchspacing ne} is just printed directly.

The \texttt{\frenchspacing print-operator} function also needs to be updated to call \texttt{\frenchspacing print-nested}.
\begin{lstlisting}
defn print-operator (a:Exp, op:String, b:Exp) :
   print-nested(a)
   print(o, op)
   print-nested(b)
\end{lstlisting}

Those are all the changes needed to handle precedence. Here is the full \texttt{\frenchspacing print} method. 
\begin{lstlisting}
defmethod print (o:OutputStream, e:Exp) :
   defn print-nested (ne:Exp) :
      if precedence(ne) < precedence(e) :
         print(o, "(%_)" % [ne])
      else :
         print(o, ne)
   defn print-operator (a:Exp, op:String, b:Exp) :
      print-nested(a)
      print(o, op)
      print-nested(b)
   match(e) :
      (e:Const) : print(o, value(e))
      (e:Variable) : print(o, name(e))
      (e:Log) : print(o, "ln(%_)" % [a(e)])
      (e:Add) : print-operator(a(e), " + ", b(e))
      (e:Subtract) : print-operator(a(e), " - ", b(e))
      (e:Multiply) : print-operator(a(e), " * ", b(e))
      (e:Divide) : print-operator(a(e), " / ", b(e))
      (e:Power) : print-operator(a(e), " ^ ", b(e))
\end{lstlisting}

If you compile and run the program again, it should now correctly print out
\begin{lstlisting}
2 * x ^ 2 + (1 + 3) * x + ln(x + 4)
\end{lstlisting}

\subsection*{Operator Overloading}
The code we used to construct the expression
\begin{lstlisting}
val term1 = Multiply(Const(2), Power(Variable(`x), Const(2)))
val term2 = Multiply(Add(Const(1), Const(3)), Variable(`x))
val term3 = Log(Add(Variable(`x), Const(4)))
val exp = Add(Add(term1, term2), term3)
\end{lstlisting}
is quite verbose. Let's overload some operators to help us with that. 

Recall that the operators \texttt{\frenchspacing +}, \texttt{\frenchspacing -}, \texttt{\frenchspacing *}, \texttt{\frenchspacing /}, and \texttt{\frenchspacing \^} are just syntactic shorthands for calling the functions \texttt{\frenchspacing plus}, \texttt{\frenchspacing minus}, \texttt{\frenchspacing times}, \texttt{\frenchspacing divide}, and \texttt{\frenchspacing bit-xor}. Thus all we need to do is define those functions on \texttt{\frenchspacing Exp} objects.
\begin{lstlisting}
defn plus (a:Exp, b:Exp) : Add(a, b)
defn minus (a:Exp, b:Exp) : Subtract(a, b)
defn times (a:Exp, b:Exp) : Multiply(a, b)
defn divide (a:Exp, b:Exp) : Divide(a, b)
defn bit-xor (a:Exp, b:Exp) : Power(a, b)
defn ln (a:Exp) : Log(a)
\end{lstlisting}

Now let's rewrite our \texttt{\frenchspacing main} function using the new operators.
\begin{lstlisting}
defn main () :
   val x = Variable(`x)
   val [c1, c2, c3, c4] = [Const(1), Const(2), Const(3), Const(4)]
   val exp = c2 * x ^ c2 + (c1 + c3) * x + ln(x + c4)
   println(exp)
\end{lstlisting}
Much better! If we overlook the little c's in front of each constant it's essentially identical to our printed expression.

\subsection*{The Differentiation Algorithm}
Now we can implement the differentiation algorithm! The function \texttt{\frenchspacing differentiate} takes two arguments: the expression to differentiate, \texttt{\frenchspacing e}, and the variable with respect to which it will differentiate, \texttt{\frenchspacing x}. 

The actual formulas used to do the differentiation are standard, and we won't explain how to derive them. If you have taken a course on calculus, you can break open your old textbook and copy the formulas here. If you haven't taken a course on calculus, then armed with this program, you'll never have to manually differentiate again. 
\begin{lstlisting}
defn differentiate (e:Exp, x:Symbol) -> Exp :
   defn ddx (e:Exp) : differentiate(e, x)
   
   match(e) :
      (e:Const) :
         Const(0)
      (e:Variable) :
         if name(e) == x : Const(1)
         else : Const(0)
      (e:Add) :
         ddx(a(e)) + ddx(b(e))
      (e:Subtract) :
         ddx(a(e)) - ddx(b(e))
      (e:Multiply) :
         a(e) * ddx(b(e)) + b(e) * ddx(a(e))
      (e:Divide) :
         val num = b(e) * ddx(a(e)) - a(e) * ddx(b(e))
         val den = b(e) ^ Const(2)
         num / den
      (e:Power) :
         e * (b(e) * ddx(a(e)) / a(e) + ln(a(e)) * ddx(b(e)))
      (e:Log) :
         ddx(a(e)) / a(e)
\end{lstlisting}

Let's try differentiating our example expression now. 
\begin{lstlisting}
defn main () :
   val x = Variable(`x)
   val [c1, c2, c3, c4] = [Const(1), Const(2), Const(3), Const(4)]
   val exp = c2 * x ^ c2 + (c1 + c3) * x + ln(x + c4)
   val dexp = differentiate(exp, `x)
   
   println("Original Expression: %_" % [exp])
   println("Differentiated Expression: %_" % [dexp])
\end{lstlisting}
Compiling and running the program prints out
\begin{lstlisting}
Original Expression: 2 * x ^ 2 + (1 + 3) * x + ln(x + 4)
Differentiated Expression: 2 * x ^ 2 * (2 * 1 / x + ln(x) * 0) +
                           x ^ 2 * 0 + (1 + 3) * 1 +
                           x * (0 + 0) + (1 + 0) / (x + 4)
\end{lstlisting}

If you check the result, it {\em does} work! The only problem is that the result contains a lot of expressions that can be trivially simplified. We'll fix that later. But this isn't bad at all for a 22-line algorithm. 

\subsection*{Simplification}
The only thing left to do now is simplify the resulting expression. We will write a {\em very} simple simplifier that simply looks for patterns like adding an expression to zero, or dividing by one, et cetera. But before we introduce the simplification algorithm, we need to first write a very useful helper function. 
\begin{lstlisting}
defn map (f: Exp -> Exp, e:Exp) -> Exp :
   match(e) :
      (e:Add) : Add(f(a(e)), f(b(e)))
      (e:Subtract) : Subtract(f(a(e)), f(b(e)))
      (e:Multiply) : Multiply(f(a(e)), f(b(e)))
      (e:Divide) : Divide(f(a(e)), f(b(e)))
      (e:Power) : Power(f(a(e)), f(b(e)))
      (e:Log) : Log(f(a(e)))
      (e) : e
\end{lstlisting}
\texttt{\frenchspacing map} takes an argument function, \texttt{\frenchspacing f}, and an expression, \texttt{\frenchspacing e}, and returns a new expression resulting from calling \texttt{\frenchspacing f} on every subexpression in \texttt{\frenchspacing e}. Its behaviour is analogous to the \texttt{\frenchspacing map} function for lists. Calling \texttt{\frenchspacing map} on a list {\em maps} \texttt{\frenchspacing f} onto every element in the list. Similarly, calling \texttt{\frenchspacing map} on an expression {\em maps} \texttt{\frenchspacing f} onto every subexpression in the expression.

We're now ready to write the \texttt{\frenchspacing simplify} function. It takes an expression as its argument, and returns a simplified version of the expression by replacing specific patterns with simpler expressions. 
\begin{lstlisting}
defn simplify (e:Exp) :
   defn const? (e:Exp, v:Int) :
      match(e) :
         (e:Const) : value(e) == v
         (e) : false
   defn one? (e:Exp) : const?(e, 1)
   defn zero? (e:Exp) : const?(e, 0)   

   match(map(simplify, e)) :
      (e:Add) :
         if zero?(a(e)) : b(e)
         else if zero?(b(e)) : a(e)
         else : e
      (e:Subtract) :
         if zero?(a(e)) : Const(-1) * b(e)
         else if zero?(b(e)) : a(e)
         else : e         
      (e:Multiply) :
         if one?(a(e)) : b(e)
         else if one?(b(e)) : a(e)
         else if zero?(a(e)) or zero?(b(e)) : Const(0)
         else : e
      (e:Divide) :
         if zero?(a(e)) : Const(0)
         else if one?(b(e)) : a(e)
         else : e
      (e:Power) :
         if one?(a(e)) : Const(1)
         else if zero?(b(e)) : Const(1)
         else : e
      (e:Log) :
         if one?(a(e)) : Const(0)
         else : e
      (e) : e
\end{lstlisting}
Most of the work of the simplifier is done in the branches of the match expression; you can read through them to understand which patterns are being simplified and what they're being simplified to. However, the most magical part of the function is the call to \texttt{\frenchspacing map}. 
\begin{lstlisting}
match(map(simplify, e)) :
   (e:Add) :
   ...
\end{lstlisting}
In English, that pattern says: first simplify all the nested subexpressions in \texttt{\frenchspacing e} {\em and then} look for these patterns and replace them with simpler ones. 

Let's update our \texttt{\frenchspacing main} function now to simplify the differentiated expression.
\begin{lstlisting}
defn main () :
   val x = Variable(`x)
   val [c1, c2, c3, c4] = [Const(1), Const(2), Const(3), Const(4)]
   val exp = c2 * x ^ c2 + (c1 + c3) * x + ln(x + c4)
   val dexp = differentiate(exp, `x)
   val sexp = simplify(dexp)

   println("Original Expression: %_" % [exp])
   println("Differentiated Expression: %_" % [dexp])
   println("Simplified Expression: %_" % [sexp])   
\end{lstlisting}
When compiled and ran it prints out
\begin{lstlisting}
Original Expression: 2 * x ^ 2 + (1 + 3) * x + ln(x + 4)
Differentiated Expression: 2 * x ^ 2 * (2 * 1 / x + ln(x) * 0) +
                           x ^ 2 * 0 + (1 + 3) * 1 +
                           x * (0 + 0) + (1 + 0) / (x + 4)
Simplified Expression: 2 * x ^ 2 * 2 / x + 1 + 3 + 1 / (x + 4)
\end{lstlisting}

The simplified expression is {\em much} cleaner now! This concludes our automatic differentiation example. The simplicity of both the differentiation and the simplification algorithm stems from the fact that \texttt{\frenchspacing Exp} is an immutable datastructure. In fact, the programming language Lisp, which strongly emphasized computation with immutable list structures and also heavily influenced the design of Stanza, was invented in part for writing computer algebra systems. John McCarthy started writing differentiation algorithms in Lisp even before the language was running!

\subsection*{Program Listing}
Here's a full program listing of the example. 

\begin{lstlisting}
defpackage calculus :
   import core

;Expression definition
deftype Exp
defstruct Const <: Exp : (value:Int)
defstruct Variable <: Exp : (name:Symbol)
defstruct Add <: Exp : (a:Exp, b:Exp)
defstruct Subtract <: Exp : (a:Exp, b:Exp)
defstruct Multiply <: Exp : (a:Exp, b:Exp)
defstruct Divide <: Exp : (a:Exp, b:Exp)
defstruct Power <: Exp : (a:Exp, b:Exp)
defstruct Log <: Exp : (a:Exp)

;Precedences
defn precedence (e:Exp) :
   match(e) :
      (e:Add|Subtract) : 0
      (e:Multiply|Divide|Power) : 1
      (e:Power) : 2
      (e:Const|Variable|Log) : 3

;Print behaviour for expressions
defmethod print (o:OutputStream, e:Exp) :
   defn print-nested (ne:Exp) :
      if precedence(ne) < precedence(e) :
         print(o, "(%_)" % [ne])
      else :
         print(o, ne)
   defn print-operator (a:Exp, op:String, b:Exp) :
      print-nested(a)
      print(o, op)
      print-nested(b)
   match(e) :
      (e:Const) : print(o, value(e))
      (e:Variable) : print(o, name(e))
      (e:Log) : print(o, "ln(%_)" % [a(e)])
      (e:Add) : print-operator(a(e), " + ", b(e))
      (e:Subtract) : print-operator(a(e), " - ", b(e))
      (e:Multiply) : print-operator(a(e), " * ", b(e))
      (e:Divide) : print-operator(a(e), " / ", b(e))
      (e:Power) : print-operator(a(e), " ^ ", b(e))

;Overloaded operators
defn plus (a:Exp, b:Exp) : Add(a, b)
defn minus (a:Exp, b:Exp) : Subtract(a, b)
defn times (a:Exp, b:Exp) : Multiply(a, b)
defn divide (a:Exp, b:Exp) : Divide(a, b)
defn bit-xor (a:Exp, b:Exp) : Power(a, b)
defn ln (a:Exp) : Log(a)

;Differentiation algorithm
defn differentiate (e:Exp, x:Symbol) -> Exp :
   defn ddx (e:Exp) : differentiate(e, x)
   
   match(e) :
      (e:Const) :
         Const(0)
      (e:Variable) :
         if name(e) == x : Const(1)
         else : Const(0)
      (e:Add) :
         ddx(a(e)) + ddx(b(e))
      (e:Subtract) :
         ddx(a(e)) - ddx(b(e))
      (e:Multiply) :
         a(e) * ddx(b(e)) + b(e) * ddx(a(e))
      (e:Divide) :
         val num = b(e) * ddx(a(e)) - a(e) * ddx(b(e))
         val den = b(e) ^ Const(2)
         num / den
      (e:Power) :
         e * (b(e) * ddx(a(e)) / a(e) + ln(a(e)) * ddx(b(e)))
      (e:Log) :
         ddx(a(e)) / a(e)

;Map helper
defn map (f: Exp -> Exp, e:Exp) -> Exp :
   match(e) :
      (e:Add) : Add(f(a(e)), f(b(e)))
      (e:Subtract) : Subtract(f(a(e)), f(b(e)))
      (e:Multiply) : Multiply(f(a(e)), f(b(e)))
      (e:Divide) : Divide(f(a(e)), f(b(e)))
      (e:Power) : Power(f(a(e)), f(b(e)))
      (e:Log) : Log(f(a(e)))
      (e) : e

;Simplification algorithm
defn simplify (e:Exp) :
   defn const? (e:Exp, v:Int) :
      match(e) :
         (e:Const) : value(e) == v
         (e) : false
   defn one? (e:Exp) : const?(e, 1)
   defn zero? (e:Exp) : const?(e, 0)   

   match(map(simplify, e)) :
      (e:Add) :
         if zero?(a(e)) : b(e)
         else if zero?(b(e)) : a(e)
         else : e
      (e:Subtract) :
         if zero?(a(e)) : Const(-1) * b(e)
         else if zero?(b(e)) : a(e)
         else : e         
      (e:Multiply) :
         if one?(a(e)) : b(e)
         else if one?(b(e)) : a(e)
         else if zero?(a(e)) or zero?(b(e)) : Const(0)
         else : e
      (e:Divide) :
         if zero?(a(e)) : Const(0)
         else if one?(b(e)) : a(e)
         else : e
      (e:Power) :
         if one?(a(e)) : Const(1)
         else if zero?(b(e)) : Const(1)
         else : e
      (e:Log) :
         if one?(a(e)) : Const(0)
         else : e
      (e) : e

;Main program
defn main () :
   val x = Variable(`x)
   val [c1, c2, c3, c4] = [Const(1), Const(2), Const(3), Const(4)]
   val exp = c2 * x ^ c2 + (c1 + c3) * x + ln(x + c4)
   val dexp = differentiate(exp, `x)
   val sexp = simplify(dexp)

   println("Original Expression: %_" % [exp])
   println("Differentiated Expression: %_" % [dexp])
   println("Simplified Expression: %_" % [sexp])   

;Start!
main()
\end{lstlisting}

\subsection*{Exercises}
\begin{enumerate}
\item Our differentiation algorithm is general enough to always give the right answer (for the types of expressions it supports), but it's often {\em too} general. This is most obvious in the differentiation rule for \texttt{\frenchspacing Power} expressions. The current rule handles the case where both the base and exponent are functions of x, but typically only one of the two is a function of x and the other is a constant expression. Look for these special cases and handle them more intelligently. 

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing 1 + 3} to \texttt{\frenchspacing 4}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing 1 + x + 3} to \texttt{\frenchspacing 4 + x}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing x - x} to \texttt{\frenchspacing 0}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing x + 1 - x} to \texttt{\frenchspacing 1}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing x * x} to \texttt{\frenchspacing x \^ 2}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing x / x} to \texttt{\frenchspacing 1}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing x \^ 2 / x} to \texttt{\frenchspacing x}.

\item Extend the simplifier to be able to simplify \texttt{\frenchspacing (x + 1) \^ 2 / (x + 1)} to \texttt{\frenchspacing x + 1}.
\end{enumerate}

\chapter{Parametric Polymorphism}
This chapter will introduce you to the concept of {\em parametric polymorphism} and show you how to parameterize your functions using {\em type arguments}, and your types using {\em type parameters}. 

\section{The Need for Polymorphism}
Thus far, none of the functions you have written so far have been parameterized by type. Here is an example implementation of a function that reverses a list of integers.
\begin{lstlisting}
defn reverse-list (xs:List<Int>) -> List<Int> :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list(tail(xs))
         List(head(xs)))
\end{lstlisting}
But notice that it only works on integers. Thus the following does not compile.
\begin{lstlisting}
reverse-list(List("Timon", "and", "Pumbaa"))
\end{lstlisting}
It gives this error.
\begin{lstlisting}
Cannot call function reverse-list of type List<Int> -> List<Int> 
with arguments of type (FullList<String>).
\end{lstlisting}

To handle this, we can write an overloaded version of \texttt{\frenchspacing reverse-list} that accepts a list of strings.
\begin{lstlisting}
defn reverse-list (xs:List<String>) -> List<String> :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list(tail(xs))
         List(head(xs)))
\end{lstlisting}
Now \texttt{\frenchspacing reverse-list} will work on both integers and strings. So the following
\begin{lstlisting}
println(reverse-list(List(1, 2, 3)))
println(reverse-list(List("Timon", "and", "Pumbaa")))
\end{lstlisting}
compiles and prints out
\begin{lstlisting}
(3 2 1)
("Pumbaa" "and" "Timon")
\end{lstlisting}
However, the code for the string version of \texttt{\frenchspacing reverse-list} is identical to the integer version, save for its type signature. This is an obvious duplication of effort. Also, this is clearly a subpar solution. What if we next want to reverse a list of characters? It is not practical to define an overloaded version of \texttt{\frenchspacing reverse-list} for every type of list we wish to reverse.

\subsection*{The Limitations of the ? Type}
What we need is the ability to call \texttt{\frenchspacing reverse-list} on lists of {\em any} type. Well, we've already learned about one mechanism that will allow us to do this: the \texttt{\frenchspacing ?} type. So let's replace our two overloaded \texttt{\frenchspacing reverse-list} functions with a single one that accepts a \texttt{\frenchspacing List<?>} as its argument.
\begin{lstlisting}
defn reverse-list (xs:List) -> List :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list(tail(xs))
         List(head(xs)))
\end{lstlisting}
Recall that the default type parameter is \texttt{\frenchspacing ?} for a type without explicit type parameters. Thus \texttt{\frenchspacing List} is equivalent to \texttt{\frenchspacing List<?>}. The above definition of \texttt{\frenchspacing reverse-list} {\em will} allow us to call both lists of integers and strings. Try out the following code again
\begin{lstlisting}
println(reverse-list(List(1, 2, 3)))
println(reverse-list(List("Timon", "and", "Pumbaa")))
\end{lstlisting}
and verify that it still prints out
\begin{lstlisting}
(3 2 1)
("Pumbaa" "and" "Timon")
\end{lstlisting}
It seems to work fine now on these cases. What is the problem? 

The problem is in the type of the result of the \texttt{\frenchspacing reverse-list} function. \texttt{\frenchspacing reverse-list} is annotated to return a \texttt{\frenchspacing List<?>}. Thus the following obviously incorrect code will still compile.
\begin{lstlisting}
val xs = reverse-list(List("Timon", "and", "Pumbaa"))
println(head(xs) + 1)
\end{lstlisting} 
When the compiled program is ran, it crashes with this error.
\begin{lstlisting}
FATAL ERROR: Cannot cast value to type.
   at core/core.stanza:2619.12
   at test.stanza:15.8
\end{lstlisting}
This is disappointing. The reverse of a list of strings is obviously still a list of strings. So \texttt{\frenchspacing head(xs)} should be a \texttt{\frenchspacing String}, and Stanza should have stopped us from trying to add an integer to it. More precisely, what we need is the ability for \texttt{\frenchspacing reverse-list} to accept lists of any type, but have it also return lists of the {\em same} type.

In place of \texttt{\frenchspacing reverse-list}, we'll instead call the \texttt{\frenchspacing reverse} function included in Stanza's core library, and see that it does not suffer from these problems.
\begin{lstlisting}
val xs = reverse(List("Timon", "and", "Pumbaa"))
println(head(xs) + 1)
\end{lstlisting} 
Attempting to compile the above gives this error.
\begin{lstlisting}
No appropriate function plus for arguments of type (String, Int). 
Possibilities are:
   plus: (Byte, Byte) -> Byte at core/core.stanza:2488.21
   plus: (Int, Int) -> Int at core/core.stanza:2619.12
   plus: (Long, Long) -> Long at core/core.stanza:2688.21
   plus: (Float, Float) -> Float at core/core.stanza:2742.21
   plus: (Double, Double) -> Double at core/core.stanza:2792.21
\end{lstlisting}
which is much more reassuring. We'll now see how we can write such functions ourselves. 

\section{Explicit Type Arguments}
Here is how to write a {\em polymorphic} \texttt{\frenchspacing reverse-list} function that takes an explicit type argument.
\begin{lstlisting}
defn reverse-list<ElementType> (xs:List<ElementType>) -> List<ElementType> :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list<ElementType>(tail(xs))
         List(head(xs)))
\end{lstlisting}
\texttt{\frenchspacing reverse-list} takes a single type argument called \texttt{\frenchspacing ElementType} that represents the type of the elements inside the \texttt{\frenchspacing xs} list. Now we need to provide a type argument to \texttt{\frenchspacing reverse-list} when we call it.
\begin{lstlisting}
reverse-list<Int>(List(1, 2, 3))
\end{lstlisting}
What that does is {\em instantiate} a version of \texttt{\frenchspacing reverse-list} by replacing \texttt{\frenchspacing ElementType} with \texttt{\frenchspacing Int} in its type signature. Thus the instantiated function has type
\begin{lstlisting}
List<Int> -> List<Int>
\end{lstlisting}
and we then call it with \texttt{\frenchspacing List(1, 2, 3)}. 
Let's use our polymorphic function to reverse lists of integers and strings.
\begin{lstlisting}
val xs = reverse-list<Int>(List(1, 2, 3))
val ys = reverse-list<String>(List("Timon", "and", "Pumbaa"))
println(xs)
println(ys)
\end{lstlisting}
Compiling and running the above prints out the same message as before.
\begin{lstlisting}
(3 2 1)
("Pumbaa" "and" "Timon")
\end{lstlisting}

Let's also verify that the return type of \texttt{\frenchspacing reverse-list} is of the proper type.
\begin{lstlisting}
val xs = reverse-list<String>(List("Timon", "and", "Pumbaa"))
println(head(xs) + 1)
\end{lstlisting} 
Attempting to compile the above gives this error.
\begin{lstlisting}
No appropriate function plus for arguments of type (String, Int). 
Possibilities are:
   plus: (Byte, Byte) -> Byte at core/core.stanza:2488.21
   plus: (Int, Int) -> Int at core/core.stanza:2619.12
   plus: (Long, Long) -> Long at core/core.stanza:2688.21
   plus: (Float, Float) -> Float at core/core.stanza:2742.21
   plus: (Double, Double) -> Double at core/core.stanza:2792.21
\end{lstlisting}
So the return type is correct, and Stanza properly catches our mistakes.

Note that we are responsible for instantiating a correct version of \texttt{\frenchspacing reverse-list} to call. If we pass in the wrong type arguments, 
\begin{lstlisting}
reverse-list<String>(List(1, 2, 3))
\end{lstlisting}
then the program will fail to compile. The above gives this error when we attempt to compile it.
\begin{lstlisting}
Cannot call function reverse-list of type List<String> -> List<String> 
with arguments of type (FullList<Int>).
\end{lstlisting}

As a comment on programming style, the purpose of each type argument in a polymorphic function is typically quite obvious. Thus programmers do not feel the need to give them descriptive names. Here is how \texttt{\frenchspacing reverse-list} would commonly be written.
\begin{lstlisting}
defn reverse-list<T> (xs:List<T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list<T>(tail(xs))
         List(head(xs)))
\end{lstlisting}
The vast majority of type arguments are simply named \texttt{\frenchspacing T} (short for \texttt{\frenchspacing Type}), or \texttt{\frenchspacing S} (because it's a letter close to \texttt{\frenchspacing T}). 

\section{Captured Type Arguments}
Our polymorphic \texttt{\frenchspacing reverse-list} function can now reverse lists of any type and also correctly returns a list of the same type. It's just a little cumbersome to use because we have to pass in the element type of the list we're reversing each time. This is because \texttt{\frenchspacing T} is declared as an {\em explicit} type argument. We'll see now how to have Stanza automatically infer the type argument by declaring it as a {\em captured} type argument.
Here is a polymorphic \texttt{\frenchspacing reverse-list} written using a {\em captured} type argument.
\begin{lstlisting}
defn reverse-list<?T> (xs:List<?T>) -> List<T> :
   if empty?(xs) :
      xs
   else :
      append(
         reverse-list(tail(xs))
         List(head(xs)))
\end{lstlisting}
A captured type argument is declared with a \texttt{\frenchspacing ?} prefix, which indicates that it is not passed in explicitly. Instead, it is {\em captured} from the types of the arguments it is called with. The type signature above says that \texttt{\frenchspacing reverse-list} requires a list to be passed in for \texttt{\frenchspacing xs}. Capture \texttt{\frenchspacing T} from the element type of \texttt{\frenchspacing xs}. 

Now we can call \texttt{\frenchspacing reverse-list} without passing in an explicit type argument.
\begin{lstlisting}
reverse-list(List(1, 2, 3))
\end{lstlisting}
The argument \texttt{\frenchspacing List(1, 2, 3)} has type \texttt{\frenchspacing List<Int>}, and thus the type argument \texttt{\frenchspacing T} captures the element type \texttt{\frenchspacing Int}. 

In the following call,
\begin{lstlisting}
reverse-list(List("Timon", "and", "Pumbaa"))
\end{lstlisting}
the argument \texttt{\frenchspacing List("Timon", "and", "Pumbaa")} has a type \texttt{\frenchspacing List<String>}, and thus the type argument \texttt{\frenchspacing T} captures the element type \texttt{\frenchspacing String}. 

Let's try our example of reversing both integer lists and string lists again.
\begin{lstlisting}
val xs = reverse-list(List(1, 2, 3))
val ys = reverse-list(List("Timon", "and", "Pumbaa"))
println(xs)
println(ys)
\end{lstlisting}
Notice that we no longer need to pass in type arguments. Compiling and running the above prints out
\begin{lstlisting}
(3 2 1)
("Pumbaa" "and" "Timon")
\end{lstlisting}

We can also verify that the return type is correct.
\begin{lstlisting}
val xs = reverse-list(List("Timon", "and", "Pumbaa"))
println(head(xs) + 1)
\end{lstlisting}
Attempting to compile the above gives this error.
\begin{lstlisting}
No appropriate function plus for arguments of type (String, Int). 
Possibilities are:
   plus: (Byte, Byte) -> Byte at core/core.stanza:2488.21
   plus: (Int, Int) -> Int at core/core.stanza:2619.12
   plus: (Long, Long) -> Long at core/core.stanza:2688.21
   plus: (Float, Float) -> Float at core/core.stanza:2742.21
   plus: (Double, Double) -> Double at core/core.stanza:2792.21
\end{lstlisting}

Thus the \texttt{\frenchspacing reverse-list} function is now polymorphic and it does not require any explicit type arguments. We've finished generalizing \texttt{\frenchspacing reverse-list} at this point, and it actually now has the same type signature as the \texttt{\frenchspacing reverse} function in the core library.

\subsection*{Capture Locations}
Here's another example polymorphic function.
\begin{lstlisting}
defn store-in-odd-slots<?T> (xs:Array<?T>, v:T) -> False :
   for i in 1 to length(xs) by 2 do :
      xs[i] = v
\end{lstlisting}
\texttt{\frenchspacing store-in-odd-slots} is a polymorphic function that accepts an array, \texttt{\frenchspacing xs}, and an item, \texttt{\frenchspacing v}, and stores \texttt{\frenchspacing v} at every odd index in \texttt{\frenchspacing xs}. Let's try it out.
\begin{lstlisting}
val xs = to-array<String>(["Patrick", "Sunny", "Luca", "Whiskey", "Emmy", "Rummy"])
store-in-odd-slots(xs, "and")
println(xs)
\end{lstlisting}
prints out
\begin{lstlisting}
["Patrick" "and" "Luca" "and" "Emmy" "and"]
\end{lstlisting}

Let's now take a closer look at the type signature of \texttt{\frenchspacing store-in-odd-slots}.
\begin{lstlisting}
defn store-in-odd-slots<?T> (xs:Array<?T>, v:T) -> False
\end{lstlisting}
The \texttt{\frenchspacing ?T} following the function name
\begin{lstlisting}
store-in-odd-slots<?T>
\end{lstlisting}
means that the function is polymorphic and accepts a single captured type argument. The argument list
\begin{lstlisting}
(xs:Array<?T>, v:T)
\end{lstlisting}
contains two references to \texttt{\frenchspacing T}, but only one of them is prefixed with a \texttt{\frenchspacing ?}. This means that \texttt{\frenchspacing T} is captured {\em only} from the element type of \texttt{\frenchspacing xs}. 

The capture location for \texttt{\frenchspacing T} was chosen carefully. Consider the following type definitions.
\begin{lstlisting}
deftype Shape
deftype Circle <: Shape
\end{lstlisting}
where all circles are also shapes, but not all shapes are circles. 

The following usage of \texttt{\frenchspacing store-in-odd-slots}
\begin{lstlisting}
val shapes = Array<Shape>(10)
store-in-odd-slots(shapes, new Circle)
\end{lstlisting}
compiles correctly. \texttt{\frenchspacing T} is captured from the element type of \texttt{\frenchspacing Array<Shape>}, and is thus \texttt{\frenchspacing Shape}. The instantiated \texttt{\frenchspacing store-in-odd-slots} therefore has type
\begin{lstlisting}
(Array<Shape>, Shape) -> False
\end{lstlisting}
and can be suitably called with \texttt{\frenchspacing shapes} and \texttt{\frenchspacing new Circle}.

But this next usage
\begin{lstlisting}
val circles = Array<Circle>(10)
store-in-odd-slots(circles, new Shape)
\end{lstlisting}
fails with this error
\begin{lstlisting}
Cannot call function store-in-odd-slots of type (Array<Circle>, Circle) -> False
with arguments of type (Array<Circle>, Shape).
\end{lstlisting}
This is consistent with our intuition. You cannot store an arbitrary shape into an array that can only hold circles. As an exercise, think about what would happen if \texttt{\frenchspacing store-in-odd-slots} was instead declared the following way.
\begin{lstlisting}
defn store-in-odd-slots<?T> (xs:Array<T>, v:?T) -> False
\end{lstlisting}

As a general rule of thumb, the majority of polymorphic functions operate on a collection of some sort. The type argument is {\em almost always} captured from the element type of the collection. 

\subsection*{Multiple Capture Locations}
After reading the previous section, you might be naturally wondering what happens when there are {\em multiple} capture locations. If there are multiple capture locations, then the final captured type is the {\em union} of all the types captured from each location.

Here is an example of a function that makes use of two capture locations.
\begin{lstlisting}
defn append-lists<?T> (xs:List<?T>, ys:List<?T>) -> List<T> :
   if empty?(xs) : ys
   else : cons(head(xs), append-lists(tail(xs), ys))
\end{lstlisting}
The type argument \texttt{\frenchspacing T} is captured from both the element type of \texttt{\frenchspacing xs} {\em and} the element of type \texttt{\frenchspacing ys}. Thus if we call \texttt{\frenchspacing append-lists} on a list of integers and a list of strings,
\begin{lstlisting}
val xs = List(1, 2, 3)
val ys = List("Timon", "and", "Pumbaa")
val zs = append-lists(xs, ys)
\end{lstlisting}
then the resulting type of \texttt{\frenchspacing zs} is \texttt{\frenchspacing List<Int|String>}. 

\subsection*{Example: map-list}
Let's try writing our own polymorphic \texttt{\frenchspacing map} function on lists. We'll call ours \texttt{\frenchspacing map-list}. \texttt{\frenchspacing map-list} accepts a function, \texttt{\frenchspacing f}, and a list, \texttt{\frenchspacing xs}, and returns a new list containing the results of calling \texttt{\frenchspacing f} on each item in \texttt{\frenchspacing xs}. To start off, here's the function definition without any type annotations.
\begin{lstlisting}
defn map-list (f, xs) :
   if empty?(xs) :
      List()
   else :
      val y = f(head(xs))
      val ys = map-list(f, tail(xs))
      cons(y, ys)
\end{lstlisting}
Let's verify that it works as intended.
\begin{lstlisting}
val xs = to-list(["Timon", "and", "Pumbaa" "are", "good", "friends"])
val lengths = map-list(length, xs)
println(lengths)
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
(5 3 6 3 4 7)
\end{lstlisting}

Let's start off with figuring out the type of \texttt{\frenchspacing xs}, because it seems easier. It's a list for sure, and \texttt{\frenchspacing map-list} should be able to work on lists of any type. So \texttt{\frenchspacing xs} is therefore of type
\begin{lstlisting}
xs:List<?T>
\end{lstlisting}
and \texttt{\frenchspacing T} is a captured type argument for \texttt{\frenchspacing map-list}. 

Next, let's figure out the type of \texttt{\frenchspacing f}. It's a function for sure, and it's called with only a single argument. So it's at least
\begin{lstlisting}
f:? -> ?
\end{lstlisting}
Next we know that \texttt{\frenchspacing f} is called with items from \texttt{\frenchspacing xs}, which is a list of \texttt{\frenchspacing T}'s, so \texttt{\frenchspacing f} has to accept \texttt{\frenchspacing T}'s. Now we know it's at least
\begin{lstlisting}
f:T -> ?
\end{lstlisting}
Finally, what is \texttt{\frenchspacing f} allowed to return? Well, \texttt{\frenchspacing f} is allowed to return anything actually. So let's introduce another captured type argument. The final type of \texttt{\frenchspacing f} is
\begin{lstlisting}
f:T -> ?S
\end{lstlisting}

Now that we know the types of its arguments, the last step is to figure out what \texttt{\frenchspacing map-list} returns. We know that it returns a list, and we also know that the list contains the results of calling \texttt{\frenchspacing f}. Since we now know that \texttt{\frenchspacing f} returns \texttt{\frenchspacing S}'s, therefore \texttt{\frenchspacing map-list} returns a list of \texttt{\frenchspacing S}'s. Here is the complete type signature for \texttt{\frenchspacing map-list}.
\begin{lstlisting}
defn map-list<?T,?S> (f:T -> ?S, xs:List<?T>) -> List<S>
\end{lstlisting}

Let's try our test code again with our typed \texttt{\frenchspacing map-list} function and ensure it works as expected.
\begin{lstlisting}
val xs = to-list(["Timon", "and", "Pumbaa" "are", "good", "friends"])
val lengths = map-list(length, xs)
println(lengths)
\end{lstlisting}
Running the above prints out
\begin{lstlisting}
(5 3 6 3 4 7)
\end{lstlisting}
as before. 

To double check the inferred return type of \texttt{\frenchspacing map-list}, let's cast \texttt{\frenchspacing lengths} to an obviously incorrect type, and read what Stanza says about its type. 
\begin{lstlisting}
lengths as False
\end{lstlisting}
Compiling the above gives us the error
\begin{lstlisting}
Cannot cast expression of type List<Int> to type False.
\end{lstlisting}
So Stanza says that \texttt{\frenchspacing lengths} is a list of integers, which is correct. 

\subsection*{Example: map-both}
Here's some more practice on using captured type arguments. Here is the un-annotated definition for the \texttt{\frenchspacing map-both} function.
\begin{lstlisting}
defn map-both (f, g, xs) :
   for x in xs map :
      [f(x), g(x)]
\end{lstlisting}
\texttt{\frenchspacing map-both} accepts two functions, \texttt{\frenchspacing f} and \texttt{\frenchspacing g}, and a list, \texttt{\frenchspacing xs}, and returns a list containing two-element tuples. The first elements in all the tuples are the results of calling \texttt{\frenchspacing f} on each item in \texttt{\frenchspacing xs}, and the second elements in all the tuples are the results of calling \texttt{\frenchspacing g} on each item in \texttt{\frenchspacing xs}.

Similar to before, the list, \texttt{\frenchspacing xs}, is the easiest argument to figure out the type signature for.
\begin{lstlisting}
xs:List<?T>
\end{lstlisting}
\texttt{\frenchspacing f} needs to be a function that can be called with items from \texttt{\frenchspacing xs}, and can return anything.
\begin{lstlisting}
f:T -> ?S
\end{lstlisting}
\texttt{\frenchspacing g} also needs to be a function that can called with items from \texttt{\frenchspacing xs}, and can also return anything. 
\begin{lstlisting}
g:T -> ?R
\end{lstlisting}
\texttt{\frenchspacing map-both} returns a list of tuples. The first elements in the tuples are results of calling \texttt{\frenchspacing f}, and the second elements are results of calling \texttt{\frenchspacing g}.
\begin{lstlisting}
List<[S, R]>
\end{lstlisting}

Thus the complete definition for \texttt{\frenchspacing map-both} is
\begin{lstlisting}
defn map-both<?T,?S,?R> (f:T -> ?S, g:T -> ?R, xs:List<?T>) -> List<[S, R]> :
   for x in xs map :
      [f(x), g(x)]
\end{lstlisting}

Let's try it out on a list of strings.
\begin{lstlisting}
val xs = to-list(["Timon", "and", "Pumbaa", "are", "good", "friends"])
val zs = map-both(
   xs,
   fn (x) : x[2]
   fn (y) : length(y) * 2)
println(zs)
\end{lstlisting}
which prints out
\begin{lstlisting}
(['m' 10] ['d' 6] ['m' 12] ['e' 6] ['o' 8] ['i' 14])
\end{lstlisting}

Let's cast \texttt{\frenchspacing zs} to something silly to see what Stanza says about its type. Attempting to compile the following
\begin{lstlisting}
zs as False
\end{lstlisting}
gives us this error.
\begin{lstlisting}
Cannot cast expression of type List<[Char, Int]> to type False.
\end{lstlisting}
So \texttt{\frenchspacing zs} has type \texttt{\frenchspacing List<[Char, Int]>}, which is what we expect.

\section{Parametric Types}
You have been shown how to define your own types using \texttt{\frenchspacing deftype} and also the shorthand \texttt{\frenchspacing defstruct}. But none of the types you've defined thus far accept {\em type parameters}. This stood out the most in our definition of the \texttt{\frenchspacing Stack} type which was only able to store {\em String} objects. We'll now learn how to declare our own {\em parametric types}.

\subsection*{Declaring a Parametric Type}
Here is an example of a simple type that takes two type parameters. 
\begin{lstlisting}
deftype Either<L,R>
\end{lstlisting}
\texttt{\frenchspacing Either} contains two wrapped objects, a left object of type \texttt{\frenchspacing L}, and a right object of type \texttt{\frenchspacing R}. 

This is all there is to defining a parametric type! The rest of this section covers mechanisms that have already been introduced, but we'll go through them in the context of the \texttt{\frenchspacing Either} type for practice.

\subsection*{Declaring Multis}
Let's define the fundamental operations for an \texttt{\frenchspacing Either} object, which are simply getter functions for retrieving the two wrapped objects.
\begin{lstlisting}
defmulti left<?L> (e:Either<?L,?>) -> L
defmulti right<?R> (e:Either<?,?R>) -> R
\end{lstlisting}
Notice that the \texttt{\frenchspacing left} and \texttt{\frenchspacing right} functions each take only a single type argument. The other type parameter for the \texttt{\frenchspacing Either} object is left as \texttt{\frenchspacing ?} to indicate that it is free to be anything.

\subsection*{Creating Either Objects}
Now let's write a constructor function for creating \texttt{\frenchspacing Either} objects. We'll start with a function that can only create \texttt{\frenchspacing Either<Int,String>} objects.
\begin{lstlisting}
defn Either (l:Int, r:String) :
   new Either<Int,String> :
      defmethod left (this) : l
      defmethod right (this) : r
\end{lstlisting}
Let's try it out.
\begin{lstlisting}
val e = Either(42, "Timon")
println("The left object is %_." % [left(e)])
println("The right object is %_." % [right(e)])
\end{lstlisting}
prints out
\begin{lstlisting}
The left object is 42.
The right object is Timon.
\end{lstlisting}

\subsection*{Polymorphic Constructor Function}
Now that we can successfully create specific \texttt{\frenchspacing Either} objects, let's generalize our constructor function by making it polymorphic using type arguments. The following declares \texttt{\frenchspacing Either} as taking two explicit type arguments, one for each wrapped object.
\begin{lstlisting}
defn Either<L,R> (l:L, r:R) :
   new Either<L,R> :
      defmethod left (this) : l
      defmethod right (this) : r
\end{lstlisting}
Now \texttt{\frenchspacing Either} objects are created in the following way.
\begin{lstlisting}
val e = Either<Int,String>(42, "Timon")
\end{lstlisting}
The way in which \texttt{\frenchspacing Either} objects are created now resembles how we've been creating many of the other types included in the core library, such as arrays and vectors. This is not a coincidence. The construction function for arrays and vectors are also just regular functions that take explicit type arguments and return instances of parametric types.

\subsection*{Parametric Structs}
The \texttt{\frenchspacing defstruct} expression also accepts type parameters for creating parametric structs. As mentioned previously, the \texttt{\frenchspacing defstruct} expression is simply a syntactic shorthand for declaring a new type, getter functions for its fields, and a default construction function. Thus all the code we've written previously to define the \texttt{\frenchspacing Either} type can be neatly expressed as
\begin{lstlisting}
defstruct Either<L,R> :
   left: L
   right: R
\end{lstlisting}

\subsection*{Constructor Function with Captured Arguments}
Specifically for creating \texttt{\frenchspacing Either} objects, it is also not necessary to have the user explicitly specify the types of the left and right objects. Let's make the constructor function more convenient to call by using captured type arguments.
\begin{lstlisting}
defn Either<?L,?R> (l:?L, r:?R) :
   new Either<L,R> :
      defmethod left (this) : l
      defmethod right (this) : r
\end{lstlisting}
Now we can create an \texttt{\frenchspacing Either} object like this
\begin{lstlisting}
val e = Either(42, "Timon")
\end{lstlisting}
and have Stanza automatically infer that \texttt{\frenchspacing e} is an \texttt{\frenchspacing Either<Int,String>} based on the types of \texttt{\frenchspacing 42} and \texttt{\frenchspacing "Timon"}.

\subsection*{When {\em not} to Use Captured Arguments}
We showed above how to write a constructor function using captured arguments that did not require the left and right object types to be passed in explicitly to \texttt{\frenchspacing Either}. This makes the constructor function for \texttt{\frenchspacing Either} objects very similar to the constructor function for \texttt{\frenchspacing List} objects, which also does not require any explicit type arguments. This is {\em not} always an appropriate thing to do.

Let us suppose that \texttt{\frenchspacing Either} is a {\em mutable} datastructure; that we can change the left and right objects after the object has been created. The type definition for \texttt{\frenchspacing Either} would stay the same, but it would gain two more fundamental operations.
\begin{lstlisting}
defmulti left<?L> (e:Either<?L,?>) -> L
defmulti right<?R> (e:Either<?,?R>) -> R
defmulti set-left<?L> (e:Either<?L,?>, v:L) -> False
defmulti set-right<?R> (e:Either<?,?R>, v:R) -> False
\end{lstlisting}
Notice, especially, the capture locations of the type arguments in the setter functions. 

The constructor function would be changed to now accept not the left and right objects, but the {\em initial} left and right objects, since they may change later on.
\begin{lstlisting}
defn Either<?L,?R> (l0:?L, r0:?R) :
   var l = l0
   var r = r0
   new Either<L,R> :
      defmethod left (this) : l
      defmethod right (this) : r
      defmethod set-left (this, v:L) : l = v
      defmethod set-right (this, v:R) : r = v
\end{lstlisting}

For the next part, let us again assume that we have definitions for some basic shapes.
\begin{lstlisting}
deftype Shape
deftype Circle <: Shape
deftype Rectangle <: Shape

defmethod print (o:OutputStream, c:Circle) : print(o, "Circle")
defmethod print (o:OutputStream, r:Rectangle) : print(o, "Rectangle")
\end{lstlisting}

Let's try creating a mutable \texttt{\frenchspacing Either} object now.
\begin{lstlisting}
defn my-favorite-shape () -> Shape :
   new Circle

val e = Either(42, my-favorite-shape())
println("After creation:")
println("The left object is %_" % [left(e)])
println("The right object is %_" % [right(e)])

set-left(e, 256)
set-right(e, new Rectangle)
println("\nAfter mutation:")
println("The left object is %_" % [left(e)])
println("The right object is %_" % [right(e)])
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
After creation:
The left object is 42
The right object is Circle

After mutation:
The left object is 256
The right object is Rectangle
\end{lstlisting}

Everything seems to be working, but pay attention to what happens next. 

The type signature for \texttt{\frenchspacing my-favorite-shape} is not as precise as it could be. It's annotated to return \texttt{\frenchspacing Shape}, but it's more precise to say that it returns \texttt{\frenchspacing Circle}. So let's improve \texttt{\frenchspacing my-favorite-shape}'s type signature.
\begin{lstlisting}
defn my-favorite-shape () -> Circle :
   new Circle
\end{lstlisting}
Now try compiling and running the program again. It will now give this error.
\begin{lstlisting}
Cannot call function set-right of type (Either<?, Circle>, Circle) -> False 
with arguments of type (Either<Int, Circle>, Rectangle).
\end{lstlisting}

What is going on? Why would changing (actually improving) the type signature for \texttt{\frenchspacing my-favorite-shape} affect the later call to \texttt{\frenchspacing set-right}? 

The problem, as is evident in the error message, is that the inferred type for \texttt{\frenchspacing e} is \texttt{\frenchspacing Either<Int, Circle>}. This is not right. Even though the {\em initial} right object was a \texttt{\frenchspacing Circle}, that doesn't mean we want \texttt{\frenchspacing e} to {\em only ever} hold \texttt{\frenchspacing Circle} objects as its right object.

This is one of those cases where using a captured type argument is inappropriate. For a mutable \texttt{\frenchspacing Either} object, the types of the left and right objects should be passed in explicitly.

Here is the constructor function rewritten to use explicit type arguments.
\begin{lstlisting}
defn Either<L,R> (l0:L, r0:R) :
   var l = l0
   var r = r0
   new Either<L,R> :
      defmethod left (this) : l
      defmethod right (this) : r
      defmethod set-left (this, v:L) : l = v
      defmethod set-right (this, v:R) : r = v
\end{lstlisting}
And here is our original test code rewritten to pass in explicit type arguments.
\begin{lstlisting}
defn my-favorite-shape () -> Shape :
   new Circle

val e = Either<Int, Shape>(42, my-favorite-shape())
println("After creation:")
println("The left object is %_" % [left(e)])
println("The right object is %_" % [right(e)])

set-left(e, 256)
set-right(e, new Rectangle)
println("\nAfter mutation:")
println("The left object is %_" % [left(e)])
println("The right object is %_" % [right(e)])
\end{lstlisting}
Verify that it still compiles and runs correctly. 

At this point, we can try making the same change to \texttt{\frenchspacing my-favorite-shape}'s type signature.
\begin{lstlisting}
defn my-favorite-shape () -> Circle :
   new Circle
\end{lstlisting}
This time, however, the program still compiles and continues to run as before. 

Here are the basic rules of thumb for choosing between using explicit or captured type arguments. If you're creating an immutable object then feel free to use captured type arguments. If you're creating a mutable object, then use explicit type arguments. 

These issues surrounding captured type arguments and mutable objects is also why \texttt{\frenchspacing to-array} and \texttt{\frenchspacing to-vector} require explicit type arguments and why \texttt{\frenchspacing to-list} does not.

\section{Match Expressions and Type Erasure}
One subtlety concerning Stanza's parametric type system is a concept called {\em type erasure}. It roughly means that, given a program, if we replace every type argument with the \texttt{\frenchspacing ?} type, it should still run and compute the same result (providing that the original program doesn't fail). Said another way, the setting of a type argument can never change what is computed by a program.

Here is an example of incorrectly attempting to use a type argument to affect which branch is taken in a match expression.
\begin{lstlisting}
defn check-if<T> (x) :
   match(x) :
      (x:T) : true
      (x) : false
\end{lstlisting}
Let's try it out on a \texttt{\frenchspacing String} object.
\begin{lstlisting}
println(check-if<Int>("Timon"))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
FATAL ERROR: Cannot cast value to type.
   at test.stanza:15.8
   at test.stanza:18.8
\end{lstlisting}

Here is what is happening underneath. The {\em dispatch} type in a match branch has all of its type arguments and parametric types erased. Thus the code above is equivalent to the following
\begin{lstlisting}
defn check-if<T> (x) :
   match(x) :
      (y:?) :
         val x = y as T
         true
      (y:?) :
         false
\end{lstlisting}
and the error message arises because \texttt{\frenchspacing y} cannot be cast to a \texttt{\frenchspacing T} object. We intentionally designed Stanza so that there is no possible way to write a function such as \texttt{\frenchspacing check-if}.

\section{Revisiting Stack}
At this point, we have all the requisite knowledge for writing a parametric version of our \texttt{\frenchspacing Stack} class from chapter 6. Here are our old definitions for the \texttt{\frenchspacing Stack} type and its fundamental operations.
\begin{lstlisting}
deftype Stack <: Collection<String>
defmulti push (s:Stack, x:String) -> False
defmulti pop (s:Stack) -> String
defmulti empty? (s:Stack) -> True|False
\end{lstlisting}
A \texttt{\frenchspacing Stack} is declared to be a collection of strings, and its fundamental operations allow us to push and pop strings from it.

Here is the original constructor function.
\begin{lstlisting}
defn Stack (capacity:Int) -> Stack :
   val items = Array<String>(capacity)
   var size = 0
   new Stack :
      defmethod push (this, x:String) :
         if size == capacity : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         print-all(o, join(this, " "))
         print(o, "]")
      defmethod to-seq (this) :
         take-n(size, items)
\end{lstlisting}

\subsection*{Parametric Type Declaration}
The first step is to declare \texttt{\frenchspacing Stack} as a parametric type. 
\begin{lstlisting}
deftype Stack<T> <: Collection<T>
\end{lstlisting}
Thus, \texttt{\frenchspacing Stack} now takes a type parameter, \texttt{\frenchspacing T}, that indicates what types of objects the stack may hold, and is also no longer a collection of strings. It is now a collection of \texttt{\frenchspacing T}'s. 

\subsection*{Polymorphic Fundamental Operations}
The second step is to declare its fundamental operations as polymorphic functions.
\begin{lstlisting}
defmulti push<?T> (s:Stack<?T>, x:T) -> False
defmulti pop<?T> (s:Stack<?T>) -> T
defmulti empty? (s:Stack) -> True|False
\end{lstlisting}
both \texttt{\frenchspacing push} and \texttt{\frenchspacing pop} now accept a captured type argument, \texttt{\frenchspacing T}, that indicates the element type of the stack object. Here are some points to take note of. Notice that the \texttt{\frenchspacing x} argument for \texttt{\frenchspacing push} is not a capture location for \texttt{\frenchspacing T}. This is consistent with our earlier discussion in the section on capture locations. Also notice that the \texttt{\frenchspacing empty?} multi is unchanged, as the types of the objects in a stack are not needed to check whether the stack is empty.

\subsection*{Polymorphic Constructor Function}
The last step is to make its constructor function polymorphic.
\begin{lstlisting}
defn Stack<T> (capacity:Int) -> Stack<T> :
   val items = Array<T>(capacity)
   var size = 0
   new Stack :
      defmethod push (this, x:T) :
         if size == capacity : fatal("Stack is full!")
         items[size] = x
         size = size + 1
      defmethod pop (this) :
         if size == 0 : fatal("Stack is empty!")
         size = size - 1
         items[size]
      defmethod empty? (this) :
         size == 0
      defmethod print (o:OutputStream, this) :
         print(o, "Stack containing [")
         print-all(o, join(this, " "))
         print(o, "]")
      defmethod to-seq (this) :
         take-n(size, items)
\end{lstlisting}
The constructor function now takes an explicit type argument, \texttt{\frenchspacing T}, indicating the element type of the stack object, and returns a \texttt{\frenchspacing Stack<T>}. Notice that the backing array, \texttt{\frenchspacing items}, is no longer an \texttt{\frenchspacing Array<String>}. It is now declared as an \texttt{\frenchspacing Array<T>} in order to hold the items in the stack. \texttt{\frenchspacing push} now also accepts a \texttt{\frenchspacing T} value instead of a \texttt{\frenchspacing String} value. The rest of the function is unchanged. 

\subsection*{Trying It Out}
Let's try out our parametric \texttt{\frenchspacing Stack} type using a variation of our original test code.
\begin{lstlisting}
defn main () :
   val s = Stack<Int>(10)
   for x in [1, 5, 2, 42, -11, 2, 5, 10, -42] do :
      push(s, x)

   println("1. Contents of s")
   println(s)

   println("\n2. Index of 42")
   println(index-of(s, 42))

   println("\n3. Does it contain any negative numbers?")
   println(any?({_ < 0}, s))

   println("\n4. Are all numbers negative?")
   println(all?({_ < 0}, s))

   println("\n5. What are the negative numbers?")
   val cap-s = filter({_ < 0}, s)
   println-all(join(cap-s, ", "))

   println("\n6. What are its unique elements?")
   println(unique(s))

main()
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
1. Contents of s
Stack containing [1 5 2 42 -11 2 5 10 -42]

2. Index of 42
3

3. Does it contain any negative numbers?
true

4. Are all numbers negative?
false

5. What are the negative numbers?
-11, -42

6. What are its unique elements?
(1 5 2 42 -11 10 -42)
\end{lstlisting}

Our parametric stack type is now quite general. It can hold items of different types, and it supports all the operations in the core sequence library. Actually, the \texttt{\frenchspacing Array} and \texttt{\frenchspacing Vector} types in the core library are defined in much the same way as \texttt{\frenchspacing Stack}.



\chapter{Advanced Control Flow}
Thus far, the only control flow mechanism you've been shown was the \texttt{\frenchspacing label} construct for creating labeled scopes. But this one construct was powerful enough to express early returns from functions, early breaks from loops, and also (though we haven't shown it) early jumps to the next loop iteration. Each of the above functionality has traditionally been a separate keyword and language feature in other languages, but they're all expressible with just the \texttt{\frenchspacing label} construct in Stanza. It is a powerful and general mechanism.

In actuality, Stanza only has a single control flow mechanism, called {\em targetable coroutines}. The \texttt{\frenchspacing label} construct is just a common usage pattern for them. In this chapter we'll learn about the other common usage pattern of coroutines: attempts and failures, exception handlers, and generators. At the very end, we'll show you the general coroutine construct, along with some examples demonstrating their use.

\section{First Class Labeled Scopes}
Here is a function that finds the smallest power of two that is greater or equal to the given argument, \texttt{\frenchspacing n}.
\begin{lstlisting}
defn min-pow-2 (n:Int) :
   label<Int> return :
      var x = 1
      while true :
         if x >= n : return(x)
         x = x * 2
      fatal("Unreachable")   
\end{lstlisting}

Let's try it out.
\begin{lstlisting}
defn main () :
   defn test (n:Int) :
      println("The minimum power of 2 greater or equal to %_ is %_." %
              [n, min-pow-2(n)])
   test(10)
   test(100)
   test(1000)
   test(10000)
   test(100000)
   test(1000000)

main()
\end{lstlisting}

Compiling and running the above prints out
\begin{lstlisting}
The minimum power of 2 greater or equal to 10 is 16.
The minimum power of 2 greater or equal to 100 is 128.
The minimum power of 2 greater or equal to 1000 is 1024.
The minimum power of 2 greater or equal to 10000 is 16384.
The minimum power of 2 greater or equal to 100000 is 131072.
The minimum power of 2 greater or equal to 1000000 is 1048576.
\end{lstlisting}

\subsection*{Pulling Out the Body}
That's fairly standard so far. But now let's pull out the body of the while loop into a separate function, called \texttt{\frenchspacing pow-2?}. It accepts an argument, \texttt{\frenchspacing x}, that is the current number being tested, an argument, \texttt{\frenchspacing n}, as the limit we're trying to reach, and also a function called \texttt{\frenchspacing return}, which we'll explain later.
\begin{lstlisting}
defn pow-2? (x:Int, n:Int, return:Int -> Void) -> Int :
   if x >= n : return(x)
   else : x * 2
\end{lstlisting}
\texttt{\frenchspacing pow-2?} first checks whether \texttt{\frenchspacing x} is greater or equal to \texttt{\frenchspacing n}, and calls \texttt{\frenchspacing return} with \texttt{\frenchspacing x} if it is. Otherwise it returns the next value of \texttt{\frenchspacing x} to \texttt{\frenchspacing test}, which is \texttt{\frenchspacing x * 2}.

We now update the \texttt{\frenchspacing min-pow-2} function to call \texttt{\frenchspacing pow-2?}.
\begin{lstlisting}
defn min-pow-2 (n:Int) :
   label<Int> return :
      var x = 1
      while true :
         x = pow-2?(x, n, return)
      fatal("Unreachable")
\end{lstlisting}
Compile and run the program to verify that it still works.

What is happening here!? We've somehow passed the exit function out of \texttt{\frenchspacing min-pow-2} and into \texttt{\frenchspacing pow-2?}. Then when \texttt{\frenchspacing pow-2?} called \texttt{\frenchspacing return}, it returned not from \texttt{\frenchspacing pow-2?}, but from \texttt{\frenchspacing min-pow-2}!.

Let's review the definition of the \texttt{\frenchspacing label} construct. Here is its general form.
\begin{lstlisting}
label<T> exit :
   body
\end{lstlisting}
The \texttt{\frenchspacing label} construct requires the type it returns, \texttt{\frenchspacing T}, the name of the exit function, \texttt{\frenchspacing exit}, and the body to execute, \texttt{\frenchspacing body}. \texttt{\frenchspacing label} creates an exit function of type \texttt{\frenchspacing T -> Void} with the name \texttt{\frenchspacing exit}, and then executes \texttt{\frenchspacing body}. If \texttt{\frenchspacing body} never calls the exit function then the result of \texttt{\frenchspacing body} is returned by \texttt{\frenchspacing label}. If \texttt{\frenchspacing body} calls the exit function then \texttt{\frenchspacing label} {\em immediately} returns the argument passed to the exit function. The return type \texttt{\frenchspacing Void} for the exit function indicates that it {\em doesn't return} to its caller.

There is nothing in the description of \texttt{\frenchspacing label} preventing us from passing out the exit function, so the call to \texttt{\frenchspacing return} in \texttt{\frenchspacing pow-2?} is simply causing the \texttt{\frenchspacing label} construct to return \texttt{\frenchspacing x}, which is then returned by \texttt{\frenchspacing min-pow-2}.

\subsection*{Storing the Exit Function}
We can even store the exit function in a variable if we like. Here's a global variable
\begin{lstlisting}
var RETURN: Int -> Void
\end{lstlisting}
into which we will store the exit function. Thus the exit function will no longer be passed in to \texttt{\frenchspacing pow-2?} as an argument.
\begin{lstlisting}
defn pow-2? (x:Int, n:Int) -> Int :
   if x >= n : RETURN(x)
   else : x * 2
\end{lstlisting}
It will instead be stored in the global variable before \texttt{\frenchspacing pow-2?} is called.
\begin{lstlisting}
defn min-pow-2 (n:Int) :
   label<Int> return :
      RETURN = return
      var x = 1
      while true :         
         x = pow-2?(x, n)
      fatal("Unreachable")
\end{lstlisting}
Compile and verify that the program still works as before.

Here you're starting to see just how flexible the \texttt{\frenchspacing label} construct really is. Storing the exit function seems like a strange thing to want to do but keep it in the back of your mind as we talk about the other constructs.

\section{Dynamic Wind}
One of the issues that accompanies having a powerful control flow mechanism is that in a sequence of expressions, evaluating the first expression does not guarantee that the last one will be evaluated.
\begin{lstlisting}
f()
g()
h()
\end{lstlisting}
For example, in the above sequence, even after \texttt{\frenchspacing f} returns, there is no guarantee that \texttt{\frenchspacing h} will be called. If \texttt{\frenchspacing g} calls an exit function then \texttt{\frenchspacing h} will be skipped entirely.

Let us suppose that we do not want to pass in the limit, \texttt{\frenchspacing n}, as an argument to \texttt{\frenchspacing pow-2?}. We would like to keep it stored in a global variable called \texttt{\frenchspacing LIMIT} and set it to the appropriate value {\em only during the call} to \texttt{\frenchspacing pow-2?}. At all other times, \texttt{\frenchspacing LIMIT} should retain its initial value of \texttt{\frenchspacing 0}. Here is an initial attempt.
\begin{lstlisting}
var LIMIT: Int = 0
var RETURN: Int -> Void

defn pow-2? (x:Int) -> Int :
   if x >= LIMIT : RETURN(x)
   else : x * 2

defn min-pow-2 (n:Int) :
   label<Int> return :
      RETURN = return      
      var x = 1
      while true :
         val old-limit = LIMIT
         LIMIT = n
         x = pow-2?(x)
         LIMIT = old-limit
      fatal("Unreachable")

defn main () :
   defn test (n:Int) :
      println("The minimum power of 2 greater or equal to %_ is %_." %
              [n, min-pow-2(n)])
   test(10)
   test(100)
   test(1000)
   test(10000)
   test(100000)
   test(1000000)

main()
println("After main, LIMIT is %_." % [LIMIT])
\end{lstlisting}
Printing and compiling the above prints out
\begin{lstlisting}
The minimum power of 2 greater or equal to 10 is 16.
The minimum power of 2 greater or equal to 100 is 128.
The minimum power of 2 greater or equal to 1000 is 1024.
The minimum power of 2 greater or equal to 10000 is 16384.
The minimum power of 2 greater or equal to 100000 is 131072.
The minimum power of 2 greater or equal to 1000000 is 1048576.
After main, LIMIT is 1000000.
\end{lstlisting}
So \texttt{\frenchspacing min-pow-2} is working correctly, but \texttt{\frenchspacing LIMIT} is not being restored back to its original value. What is happening? Well the call to \texttt{\frenchspacing pow-2?} in
\begin{lstlisting}
LIMIT = n
x = pow-2?(x)
LIMIT = old-limit
\end{lstlisting}
may call the exit function, \texttt{\frenchspacing return}. If that happens, then the \texttt{\frenchspacing label} construct immediately returns and the last \texttt{\frenchspacing LIMIT = old-limit} expression is never evaluated. 

Stanza provides the special function \texttt{\frenchspacing dynamic-wind} to handle these situations. It allows you to surround a body of code between some {\em wind in} and {\em wind out} code. The wind in code is {\em guaranteed} to execute whenever the control flow enters the body, and the wind out code is {\em guaranteed} to execute whenever the control flow exits the body. Here is how it's used.
\begin{lstlisting}
defn min-pow-2 (n:Int) :
   label<Int> return :
      RETURN = return      
      var x = 1
      while true :
         val old-limit = LIMIT
         dynamic-wind(
            fn () :
               LIMIT = n
            fn () :   
               x = pow-2?(x)
            fn (final) :            
               LIMIT = old-limit)
      fatal("Unreachable")
\end{lstlisting}
The wind in, body, and wind out code is given to \texttt{\frenchspacing dynamic-wind} as three anonymous functions. The \texttt{\frenchspacing final} argument for the wind out code is a boolean value that indicates whether it is guaranteed to be the last time the wind out code is called. In this example, \texttt{\frenchspacing final} will always be \texttt{\frenchspacing true}. 

Now compiling and running the program again prints out
\begin{lstlisting}
The minimum power of 2 greater or equal to 10 is 16.
The minimum power of 2 greater or equal to 100 is 128.
The minimum power of 2 greater or equal to 1000 is 1024.
The minimum power of 2 greater or equal to 10000 is 16384.
The minimum power of 2 greater or equal to 100000 is 131072.
The minimum power of 2 greater or equal to 1000000 is 1048576.
After main, LIMIT is 0.
\end{lstlisting}
indicating the \texttt{\frenchspacing LIMIT} is properly being reset to its original value.

\section{Dynamically Scoped Variables}
In the above example, we say that \texttt{\frenchspacing LIMIT} is being used as a {\em dynamically scoped} variable. This is a common pattern and Stanza provides a syntactic shorthand for our call to \texttt{\frenchspacing dynamic-wind}.

Here is the \texttt{\frenchspacing min-pow-2} function written using the \texttt{\frenchspacing let-var} shorthand.
\begin{lstlisting}
defn min-pow-2 (n:Int) :
   label<Int> return :
      RETURN = return      
      var x = 1
      while true :
         let-var LIMIT = n :
            x = pow-2?(x)
      fatal("Unreachable")
\end{lstlisting}

The general form of \texttt{\frenchspacing let-var} is
\begin{lstlisting}
let-var x = v :
   body
\end{lstlisting}
It temporarily sets the \texttt{\frenchspacing x} variable to the value \texttt{\frenchspacing v} before executing \texttt{\frenchspacing body}. \texttt{\frenchspacing x} is restored to its previous value after \texttt{\frenchspacing body} is finished executing.

\section{Attempts and Failures}
Attempts and failures are syntactic sugar for another use case of targetable coroutines that operate very similarly to labeled scopes. Here is an example.
\begin{lstlisting}
defn read-letter (xs:Seq<Char>) -> Char :
   if not letter?(peek(xs)) : fail()
   next(xs)

defn read-digit (xs:Seq<Char>) -> Char :
   if not digit?(peek(xs)) : fail()
   next(xs)

defn read-all (xs:Collection<Char>) :
   val xs-seq = to-seq(xs)
   while not empty?(xs-seq) :
      attempt : 
         println("Read letter: %_" % [read-letter(xs-seq)])
      else attempt :
         println("Read digit: %_" % [read-digit(xs-seq)])
      else :
         println("Read something else: %~" % [next(xs-seq)])

read-all("42 is the answer.")         
\end{lstlisting}
Compiling the above prints out
\begin{lstlisting}
Read digit: 4
Read digit: 2
Read something else: ' '
Read letter: i
Read letter: s
Read something else: ' '
Read letter: t
Read letter: h
Read letter: e
Read something else: ' '
Read letter: a
Read letter: n
Read letter: s
Read letter: w
Read letter: e
Read letter: r
Read something else: '.'
\end{lstlisting}
The function \texttt{\frenchspacing read-all} calls \texttt{\frenchspacing read-letter} and \texttt{\frenchspacing read-digit} in an \texttt{\frenchspacing attempt} block. If the block evaluates without ever calling \texttt{\frenchspacing fail} then the result of the block is returned by \texttt{\frenchspacing attempt}. If the block calls \texttt{\frenchspacing fail}, then \texttt{\frenchspacing attempt} {\em immediately} returns the result of evaluating the code in the \texttt{\frenchspacing else} branch.

\section{Example: S-Expression Parser}
Here is an example of using \texttt{\frenchspacing attempt} and \texttt{\frenchspacing fail} to program a simple s-expression parser. An s-expression, in this case, will be defined as either
\begin{enumerate}
\item a positive integer,
\item a symbol consisting of letters,
\item or a list containing more s-expressions.
\end{enumerate}

\subsection*{Overall Structure}
Here is the basic structure of the parser.
\begin{lstlisting}
defn parse-sexp (sexp:String) -> List :
   val chars = to-seq(sexp)

   defn eat-while (pred?: Char -> True|False) -> String :
      ...

   defn eat-whitespace () -> False :
      ... calls eat-while ...
   
   defn parse-symbol () -> Symbol :
      ... calls eat-while ...
         
   defn parse-number () -> Int :
      ... calls eat-while ...

   defn parse-sequence () -> List :
      ... calls eat-whitespace, parse-symbol, parse-number, and parse-list
      
   defn parse-list () -> List :
      ... calls parse-list ...

   parse-sequence()
   ...
\end{lstlisting}

parse-sexp is given a string, and returns a list of s-expressions. Upon entering the function, we ask to view the string as a sequence of characters, \texttt{\frenchspacing chars}. \texttt{\frenchspacing eat-while} and \texttt{\frenchspacing eat-whitespace} are helper functions. \texttt{\frenchspacing parse-symbol}, \texttt{\frenchspacing parse-number}, \texttt{\frenchspacing parse-sequence}, and \texttt{\frenchspacing parse-list} are mutually recursive functions that parse symbols, numbers, sequences of s-expressions, and lists of s-expressions.

\subsection*{Helper Functions}
The \texttt{\frenchspacing eat-while}, and \texttt{\frenchspacing eat-whitespace} functions are helper functions for reading from \texttt{\frenchspacing chars}. \texttt{\frenchspacing eat-while} takes a predicate function, \texttt{\frenchspacing pred?}, and eats characters from \texttt{\frenchspacing chars} as long as \texttt{\frenchspacing pred?} returns \texttt{\frenchspacing true}. It returns a string containing the eaten characters. \texttt{\frenchspacing eat-whitespace} eats all leading spaces in \texttt{\frenchspacing chars}. Here are their definitions.

\begin{lstlisting}
defn eat-while (pred?: Char -> True|False) -> String :
   string-join(take-while(pred?, chars))

defn eat-whitespace () -> False :
   eat-while({_ == ' '})
   false
\end{lstlisting}

\subsection*{Parsing Symbols}
The \texttt{\frenchspacing parse-symbol} function eats and returns the next symbol from \texttt{\frenchspacing chars}. If the next character in \texttt{\frenchspacing chars} is not a letter, then \texttt{\frenchspacing parse-symbol} fails.
\begin{lstlisting}
defn parse-symbol () -> Symbol :
   if not letter?(peek(chars)) : fail()
   to-symbol(eat-while(letter?))
\end{lstlisting}

\subsection*{Parsing Numbers}
The \texttt{\frenchspacing parse-number} function eats and returns the next positive integer from \texttt{\frenchspacing chars}. If the next character in \texttt{\frenchspacing chars} is not a digit, or if the number cannot be represented in 32 bits, then \texttt{\frenchspacing parse-number} fails. 
\begin{lstlisting}
defn parse-number () -> Int :
   if not digit?(peek(chars)) : fail()
   val x = to-int(eat-while(digit?))
   if x is-not Int : fail()
   x as Int
\end{lstlisting}

\subsection*{Parsing Sequences}
The \texttt{\frenchspacing parse-sequence} function reads as many s-expressions as possible by calling \texttt{\frenchspacing parse-symbol}, \texttt{\frenchspacing parse-number}, and \texttt{\frenchspacing parse-list} repeatedly.
\begin{lstlisting}
defn parse-sequence () -> List :
   eat-whitespace()
   if empty?(chars) :
      List()
   else :
      attempt : cons(parse-symbol(), parse-sequence())
      else attempt : cons(parse-number(), parse-sequence())
      else attempt : cons(parse-list(), parse-sequence())
      else : List()
\end{lstlisting}
Notice the use of \texttt{\frenchspacing attempt} to first try parsing a symbol, and then if that fails to then try parsing a number, followed by trying to parse a list. 

\subsection*{Parsing Lists}
The \texttt{\frenchspacing parse-list} function eats and returns the next list from \texttt{\frenchspacing chars}. A list is simply a sequence of s-expressions surrounded by \texttt{\frenchspacing ()} characters. If the next character is not an opening parenthesis then \texttt{\frenchspacing parse-list} fails.
\begin{lstlisting}
defn parse-list () -> List :   
   if peek(chars) != '(' : fail()
   next(chars)
   val items = parse-sequence()
   if empty?(chars) : fatal("Unclosed opening parenthesis.")
   else if peek(chars) == ')' : (next(chars), items)
   else : fatal("Expected closing parenthesis but got %~." % [next(chars)])
\end{lstlisting}

\subsection*{Driver}
Finally, to start off the function, we attempt to read as many s-expressions as possible from \texttt{\frenchspacing chars} using \texttt{\frenchspacing parse-sequence}. 
\begin{lstlisting}
val items = parse-sequence()
if empty?(chars) : items
else : fatal("Unexpected character: %~." % [next(chars)])
\end{lstlisting}

\subsection*{Listing}
Here is the complete definition of \texttt{\frenchspacing parse-sexp}.
\begin{lstlisting}
defn parse-sexp (sexp:String) :
   val chars = to-seq(sexp)

   defn eat-while (pred?: Char -> True|False) -> String :
      string-join(take-while(pred?, chars))

   defn eat-whitespace () -> False :
      eat-while({_ == ' '})
      false
   
   defn parse-symbol () -> Symbol :
      if not letter?(peek(chars)) : fail()
      to-symbol(eat-while(letter?))
         
   defn parse-number () -> Int :
      if not digit?(peek(chars)) : fail()
      val x = to-int(eat-while(digit?))
      if x is-not Int : fail()
      x as Int

   defn parse-sequence () -> List :
      eat-whitespace()
      if empty?(chars) :
         List()
      else :
         attempt : cons(parse-symbol(), parse-sequence())
         else attempt : cons(parse-number(), parse-sequence())
         else attempt : cons(parse-list(), parse-sequence())
         else : List()
      
   defn parse-list () -> List :   
      if peek(chars) != '(' : fail()
      next(chars)
      val items = parse-sequence()
      if empty?(chars) : fatal("Unclosed opening parenthesis.")
      else if peek(chars) == ')' : (next(chars), items)
      else : fatal("Expected closing parenthesis but got %~." % [next(chars)])

   val items = parse-sequence()
   if empty?(chars) : items
   else : fatal("Unexpected character: %~." % [next(chars)])
\end{lstlisting}

\subsection*{Trying it Out}
Let's try it out on the following string.
\begin{lstlisting}
do(println, parse-sexp("This (is) (commonly (called an (S) (Expression)))"))
\end{lstlisting}
When compiled and ran it prints out
\begin{lstlisting}
This
(is)
(commonly (called an (S) (Expression)))
\end{lstlisting}

\subsection*{Unveiling The Internals}
The \texttt{\frenchspacing attempt} construct is just syntactic sugar for a function call.
\begin{lstlisting}
attempt : conseq
else : alt
\end{lstlisting}
is equivalent to
\begin{lstlisting}
with-attempt(
   fn () : conseq
   fn () : alt)
\end{lstlisting}

As an exercise, try and implement your own \texttt{\frenchspacing with-attempt} function by using the \texttt{\frenchspacing label} construct.

\section{Exception Handling}
Our s-expression parser from the previous example fails when called with invalid input (though with very nice error messages). Here is what happens if we forget a closing parenthesis at the end.
\begin{lstlisting}
do(println, parse-sexp("This (is) (commonly (called an (S) (Expression))"))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
FATAL ERROR: Unclosed opening parenthesis.
   at test.stanza:39.25
   at test.stanza:32.29
   at core/core.stanza:3725.13
   at core/core.stanza:847.16
   at core/core.stanza:3724.14
   ...
\end{lstlisting}

But what if we cannot guarantee that the input is correct? Suppose we want users to type an arbitrary string into the terminal and print the parsed s-expression if it's well formed, or else ask them to try again if it's not.

A potential solution would be to write another function called \texttt{\frenchspacing sexp?} that returns \texttt{\frenchspacing true} or \texttt{\frenchspacing false} depending on whether its argument is a well formed string. But checking whether an s-expression is well formed is almost as much work as parsing it, so that's an inefficient solution.

Stanza provides us a mechanism for handling this called {\em exceptions}.

\subsection*{Exception Objects}
The first step is to declare our own \texttt{\frenchspacing Exception} types, one for each type of error the parser can encounter.
\begin{lstlisting}
defstruct UnclosedParenthesis <: Exception
defmethod print (o:OutputStream, e:UnclosedParenthesis) :
   print(o, "Unclosed opening parenthesis.")
   
defstruct UnmatchedParenthesis <: Exception : (char:Char)
defmethod print (o:OutputStream, e:UnmatchedParenthesis) :
   print(o, "Expected closing parenthesis but got %~." % [char(e)])
   
defstruct UnexpectedCharacter <: Exception : (char:Char)
defmethod print (o:OutputStream, e:UnexpectedCharacter) :
   print(o, "Unexpected character: %~." % [char(e)])
\end{lstlisting}

There are three different errors that are detected by our parser. 
\begin{enumerate}
\item The string is missing a closing parenthesis at the end.
\item We are currently reading a list and encountered a strange character.
\item We've read as many s-expressions as possible and there is a strange character left over.
\end{enumerate}

\subsection*{Throwing Exceptions}
The next step is to change the calls to \texttt{\frenchspacing fatal} to calls to \texttt{\frenchspacing throw} with our newly defined \texttt{\frenchspacing Exception} objects.
\begin{lstlisting}
defn parse-sexp (sexp:String) :

   ...
      
   defn parse-list () -> List :   
      ...
      if empty?(chars) : throw(UnclosedParenthesis())
      else if peek(chars) == ')' : (next(chars), items)
      else : throw(UnmatchedParenthesis(next(chars)))

   val items = parse-sequence()
   if empty?(chars) : items
   else : throw(UnexpectedCharacter(next(chars)))
\end{lstlisting}

\subsection*{Catching Exceptions}
The final step is to {\em catch} the thrown exceptions. We can decide which types of exceptions to catch, and which not to. In this example, we'll assume that the string doesn't contain any strange characters and catch only the unclosed parenthesis error.
\begin{lstlisting}
try :
   do(println, parse-sexp("This (is) (commonly (called an (S) (Expression))"))
catch (e:UnclosedParenthesis) :
   println("You forgot to close an opening parenthesis. Please try again.")
\end{lstlisting}
Compiling and running the program now prints out
\begin{lstlisting}
You forgot to close an opening parenthesis. Please try again.
\end{lstlisting}

Here is the general form of the \texttt{\frenchspacing try} construct.
\begin{lstlisting}
try :
   body
catch (e:ExceptionA) :
   a-handler
catch (e:ExceptionB) :
   b-handler
...   
\end{lstlisting}
The \texttt{\frenchspacing try} construct evaluates the given \texttt{\frenchspacing body} after installing the given exception handlers. If \texttt{\frenchspacing body} is evaluated without ever calling \texttt{\frenchspacing throw} then its result is returned by \texttt{\frenchspacing try}. If \texttt{\frenchspacing body} calls \texttt{\frenchspacing throw} with some \texttt{\frenchspacing Exception} object, then \texttt{\frenchspacing try} immediately searches for the first exception handler that can accept the \texttt{\frenchspacing Exception} object and returns the result of evaluating that handler. 

\section{Generators}
The control flow constructs you've been introduced to so far, labeled scopes, attempts and failures, and exceptions, have all served the purpose of {\em leaving} a block of code. Generators are the first control flow construct you will learn capable of {\em resuming} a block of code. 

Here is a generator that {\em yields} the first three positive integers.
\begin{lstlisting}
val xs:Seq<Int> = generate<Int> :
   println("Yielding One")
   yield(1)
   println("Yielding Two")
   yield(2)
   println("Yielding Three")
   yield(3)
\end{lstlisting}
Notice that the \texttt{\frenchspacing generate} construct returns a \texttt{\frenchspacing Seq}. Let's try printing out the items in the sequence.
\begin{lstlisting}
println("The first item in xs is")
println(next(xs))
println("The second item in xs is")
println(next(xs))
println("The third item in xs is")
println(next(xs))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
The first item in xs is
Yielding One
1
The second item in xs is
Yielding Two
2
The third item in xs is
Yielding Three
3
\end{lstlisting}

\subsection*{The Ability to Resume}
It's worth paying attention to the order in which the messages are printed out. The snippet
\begin{lstlisting}
println("The first item in xs is")
println(next(xs))
\end{lstlisting}
by itself, prints out
\begin{lstlisting}
The first item in xs is
Yielding One
1
\end{lstlisting}
Thus the call to \texttt{\frenchspacing next(xs)} causes control to enter the block of code in the \texttt{\frenchspacing generate} construct. The message \texttt{\frenchspacing "Yielding One"} is printed out, and then the call to \texttt{\frenchspacing yield(1)} leaves the \texttt{\frenchspacing generate} construct and \texttt{\frenchspacing 1} is the return value of \texttt{\frenchspacing next(xs)}.

The next snippet
\begin{lstlisting}
println("The second item in xs is")
println(next(xs))
\end{lstlisting}
prints out
\begin{lstlisting}
The second item in xs is
Yielding Two
2
\end{lstlisting}
Thus the call to \texttt{\frenchspacing next(xs)} causes control to {\em re-enter} the block \texttt{\frenchspacing generate} construct, resuming from just after the first call to \texttt{\frenchspacing yield}. The message \texttt{\frenchspacing "Yielding Two"} is printed out, and then the call to \texttt{\frenchspacing yield(2)} leaves the \texttt{\frenchspacing generate} construct once again and \texttt{\frenchspacing 2} is the return value of the second call to \texttt{\frenchspacing next(xs)}.

The last snippet
\begin{lstlisting}
println("The third item in xs is")
println(next(xs))
\end{lstlisting}
prints out
\begin{lstlisting}
The third item in xs is
Yielding Three
3
\end{lstlisting}
Similarly, the call to \texttt{\frenchspacing next(xs)} resumes the block in the \texttt{\frenchspacing generate} construct from just after the second call to \texttt{\frenchspacing yield}. The message \texttt{\frenchspacing "Yielding Three"} is printed out, and then the call to \texttt{\frenchspacing yield(3)} leaves the \texttt{\frenchspacing generate} construct once again and \texttt{\frenchspacing 3} is the return value of the third call to \texttt{\frenchspacing next(xs)}.

Thus the \texttt{\frenchspacing generate} construct provides a very convenient way of creating a lazily constructed sequence. 

\subsection*{General Form}
Here is the general form of the \texttt{\frenchspacing generate} construct.
\begin{lstlisting}
generate<T> :
   body
\end{lstlisting}
\texttt{\frenchspacing generate} returns a \texttt{\frenchspacing Seq<T>} by lazily executing the given \texttt{\frenchspacing body} in a scope containing the generation functions, \texttt{\frenchspacing yield} and \texttt{\frenchspacing break}. 

\texttt{\frenchspacing yield} is of type \texttt{\frenchspacing T -> False} and its argument becomes an element in the generated \texttt{\frenchspacing Seq}. Execution of the generate block pauses at \texttt{\frenchspacing yield}, and is resumed on the next call to \texttt{\frenchspacing next} on the sequence.

\texttt{\frenchspacing break} is both of type \texttt{\frenchspacing () -> Void} and \texttt{\frenchspacing T -> Void}. If no argument is given to \texttt{\frenchspacing break}, then execution of the generate block ends here and marks the end of the generated sequence. If an argument is given to \texttt{\frenchspacing break}, then that element is first yielded before the generate block is ended.

If the generated type, \texttt{\frenchspacing T}, is not explicitly provided, then it is assumed to be \texttt{\frenchspacing ?} by default.


\subsection*{Example: Flattening a Tuple}
In this example, we'll determine whether two tuples contain the same elements as each other if we lay out their elements in depth-first order. For example, the tuple
\begin{lstlisting}
[[1] [2 [3]] [[4 5] 6]]
\end{lstlisting}
contains the elements \texttt{\frenchspacing 1}, \texttt{\frenchspacing 2}, \texttt{\frenchspacing 3}, \texttt{\frenchspacing 4}, \texttt{\frenchspacing 5}, \texttt{\frenchspacing 6} once laid out in depth-first order.

Here's the most straightforward way of doing this. We'll write a function called \texttt{\frenchspacing flatten} that returns a \texttt{\frenchspacing Vector} containing a tuple's elements in depth-first order.
\begin{lstlisting}
defn flatten (x:Tuple) -> Vector :
   val v = Vector<?>()
   defn loop (x) :
      match(x) :
         (x:Tuple) : do(loop, x)
         (x) : add(v, x)
   loop(x)         
   v      
\end{lstlisting}
Let's try it out.
\begin{lstlisting}
println(flatten([[1] [2 [3]] [[4 5] 6]]))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
[1 2 3 4 5 6]
\end{lstlisting}

To check whether two tuples contain the same elements, we can just flatten each of them and then compare the elements.
\begin{lstlisting}
defn same-elements? (a:Tuple, b:Tuple) :
   if all?(equal?, flatten(a), flatten(b)) :
      println("%_ and %_ have the same elements." % [a, b])
   else :
      println("%_ and %_ have different elements." % [a, b])
\end{lstlisting}

Let's test it out on the following tuples.
\begin{lstlisting}
same-elements?(
   [[1] [2 [3]] [[4 5] 6]]
   [1 [[2 3 4] [5]] [6]])

same-elements?(
   [[1] [2 [3]] [[4 5] 6]]
   [[[0] 2] [3 [4 5]] 6])
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
[[1] [2 [3]] [[4 5] 6]] and [1 [[2 3 4] [5]] [6]] have the same elements.
[[1] [2 [3]] [[4 5] 6]] and [[[0] 2] [3 [4 5]] 6] have different elements.
\end{lstlisting}

Notice though, that in both cases, we computed a full flattening of both tuples before checking to see whether they are equal. This is obviously inefficient in the second case since we can tell they are clearly different just by examining their first element. How do we avoid computing the full flattening?

The solution is to {\em lazily} compute the flattening. Let's change \texttt{\frenchspacing flatten} to use the \texttt{\frenchspacing generate} construct to lazily compute the flattened tuples. To track how much of the tuples are being flattened let's also add a print statement.
\begin{lstlisting}
defn flatten (x:Tuple) -> Seq :
   val index = to-seq(0 to false)
   generate :
      defn loop (x) :
         match(x) :
            (x:Tuple) :
               do(loop, x)
            (x) :
               println("Yielding Item %_" % [next(index)])
               yield(x)
      loop(x)         
\end{lstlisting}
Compiling and running the program again prints out
\begin{lstlisting}
Yielding Item 0
Yielding Item 0
Yielding Item 1
Yielding Item 1
Yielding Item 2
Yielding Item 2
Yielding Item 3
Yielding Item 3
Yielding Item 4
Yielding Item 4
Yielding Item 5
Yielding Item 5
[[1] [2 [3]] [[4 5] 6]] and [1 [[2 3 4] [5]] [6]] have the same elements.
Yielding Item 0
Yielding Item 0
[[1] [2 [3]] [[4 5] 6]] and [[[0] 2] [3 [4 5]] 6] have different elements.
\end{lstlisting}
Thus the results are the same as before, and you can see that, for the second comparison, both generators (one for each tuple) are only computing up to the first element.


\section{Coroutines}
The \texttt{\frenchspacing label}, \texttt{\frenchspacing attempt}, \texttt{\frenchspacing try}, and \texttt{\frenchspacing generate} constructs are all specific usage patterns of Stanza's {\em targetable coroutine} system. Here we'll show you how to use the coroutine system in its full generality. It is rare in daily programming to encounter a problem that requires a use of coroutines that isn't already handled by one of the special case constructs. But for implementing libraries and frameworks that make heavy use of concurrency and non-standard control flow, coroutines may be indispensable. 

\subsection*{Sending Things Out}
Here is the function that will represent our coroutine body.
\begin{lstlisting}
defn my-process (co:Coroutine<Int,String>, a:Int) -> String :
   println("Passing out Timon")
   suspend(co, "Timon")
   println("Passing out and")
   suspend(co, "and")
   println("Passing out Pumbaa")
   suspend(co, "Pumbaa")
   println("Coroutine is done")
   "Done"
\end{lstlisting}
The type \texttt{\frenchspacing Coroutine<Int,String>} represents a coroutine for which integers are sent into the coroutine, and for which strings are sent back from the coroutine. The function for sending values out of the coroutine is \texttt{\frenchspacing suspend}. 

Let's now create our coroutine object and resume it a few times.
\begin{lstlisting}
println("Create coroutine")
val co = Coroutine<Int,String>(my-process)

println("\nResume with 42")
val x = resume(co, 42)
println("Got back x = %_" % [x])

println("\nResume with 43")
val y = resume(co, 43)
println("Got back y = %_" % [y])

println("\nResume with 44")
val z = resume(co, 44)
println("Got back z = %_" % [z])

println("\nResume with 45")
val w = resume(co, 45)
println("Got back w = %_" % [w])
\end{lstlisting}
Notice that \texttt{\frenchspacing resume} is called with integers. When the above is compiled and ran it prints out
\begin{lstlisting}
Create coroutine

Resume with 42
Passing out Timon
Got back x = Timon

Resume with 43
Passing out and
Got back y = and

Resume with 44
Passing out Pumbaa
Got back z = Pumbaa

Resume with 45
Coroutine is done
Got back w = Done
\end{lstlisting}
Thus \texttt{\frenchspacing suspend} acts much like \texttt{\frenchspacing yield} did for the \texttt{\frenchspacing generate} construct, and \texttt{\frenchspacing resume} acts much like \texttt{\frenchspacing next} did. This is no accident of course. The \texttt{\frenchspacing generate} construct is implemented in terms of \texttt{\frenchspacing suspend} and \texttt{\frenchspacing resume} underneath.

\subsection*{Breaking Things Off}
In addition to \texttt{\frenchspacing suspend}, a function called \texttt{\frenchspacing break} can also be used to send values out of a coroutine. The difference is that a call to \texttt{\frenchspacing break} cannot later be resumed.

Let's change our \texttt{\frenchspacing my-process} function to send out \texttt{\frenchspacing "Pumbaa"} with \texttt{\frenchspacing break} instead of \texttt{\frenchspacing suspend}.
\begin{lstlisting}
defn my-process (co:Coroutine<Int,String>, a:Int) -> String :
   println("Passing out Timon")
   suspend(co, "Timon")
   println("Passing out and")
   suspend(co, "and")
   println("Passing out Pumbaa")
   break(co, "Pumbaa")
   println("Coroutine is done")
   "Done"
\end{lstlisting}

Compiling and running the program again prints out
\begin{lstlisting}
Create coroutine

Resume with 42
Passing out Timon
Got back x = Timon

Resume with 43
Passing out and
Got back y = and

Resume with 44
Passing out Pumbaa
Got back z = Pumbaa

Resume with 45
FATAL ERROR: Cannot resume coroutine. Coroutine is already closed.
   at core/core.stanza:984.13
   at core/core.stanza:862.16
   at core/core.stanza:897.40
   at core/core.stanza:862.16
   at test.stanza:31.8
\end{lstlisting}
The coroutine is {\em closed} after the call to \texttt{\frenchspacing break}, and thus our call to \texttt{\frenchspacing resume} fails.

\subsection*{Sending Things In}
The obvious unanswered question now is: what is happening with the \texttt{\frenchspacing 42}, \texttt{\frenchspacing 43}, \texttt{\frenchspacing 44}, and \texttt{\frenchspacing 45} values that \texttt{\frenchspacing resume} is being called with? To answer that, let's update our \texttt{\frenchspacing my-process} function to print out the return values of \texttt{\frenchspacing suspend} (and change the call to \texttt{\frenchspacing break} back into \texttt{\frenchspacing suspend}). 
\begin{lstlisting}
defn my-process (co:Coroutine<Int,String>, a:Int) -> String :
   println("Came in a = %_" % [a])
   println("Passing out Timon")
   val b = suspend(co, "Timon")

   println("Came in b = %_" % [b])
   println("Passing out and")
   val c = suspend(co, "and")

   println("Came in c = %_" % [c])
   println("Passing out Pumbaa")
   val d = suspend(co, "Pumbaa")

   println("Came in d = %_" % [d])
   println("Coroutine is done")
   "Done"

println("Create coroutine")
val co = Coroutine<Int,String>(my-process)

println("\nResume with 42")
val x = resume(co, 42)
println("Got back x = %_" % [x])

println("\nResume with 43")
val y = resume(co, 43)
println("Got back y = %_" % [y])

println("\nResume with 44")
val z = resume(co, 44)
println("Got back z = %_" % [z])

println("\nResume with 45")
val w = resume(co, 45)
println("Got back w = %_" % [w])
\end{lstlisting}
Compiling and running the program again prints out
\begin{lstlisting}
Create coroutine

Resume with 42
Came in a = 42
Passing out Timon
Got back x = Timon

Resume with 43
Came in b = 43
Passing out and
Got back y = and

Resume with 44
Came in c = 44
Passing out Pumbaa
Got back z = Pumbaa

Resume with 45
Came in d = 45
Coroutine is done
Got back w = Done
\end{lstlisting}

Thus, \texttt{\frenchspacing suspend} sends its argument out from the coroutine, and returns the value sent into the coroutine. \texttt{\frenchspacing resume} sends its argument into the coroutine, and returns the value sent out from the coroutine.

\subsection*{Closing Things Off}
From outside the coroutine body, we may also choose to {\em close} a coroutine when we're finished with it. Let's try closing our coroutine after getting back \texttt{\frenchspacing "Pumbaa"}.

\begin{lstlisting}
println("Create coroutine")
val co = Coroutine<Int,String>(my-process)

println("\nResume with 42")
val x = resume(co, 42)
println("Got back x = %_" % [x])

println("\nResume with 43")
val y = resume(co, 43)
println("Got back y = %_" % [y])

println("\nResume with 44")
val z = resume(co, 44)
println("Got back z = %_" % [z])

close(co)

println("\nResume with 45")
val w = resume(co, 45)
println("Got back w = %_" % [w])
\end{lstlisting}

Compiling and running the above prints out
\begin{lstlisting}
Create coroutine

Resume with 42
Came in a = 42
Passing out Timon
Got back x = Timon

Resume with 43
Came in b = 43
Passing out and
Got back y = and

Resume with 44
Came in c = 44
Passing out Pumbaa
Got back z = Pumbaa

Resume with 45
FATAL ERROR: Cannot resume coroutine. Coroutine is already closed.
   at core/core.stanza:984.13
   at core/core.stanza:862.16
   at core/core.stanza:897.40
   at core/core.stanza:862.16
   at test.stanza:40.8
\end{lstlisting}

\subsection*{Checking a Coroutine's Status}
There are two functions for checking on the status of a coroutine, \texttt{\frenchspacing active?} and \texttt{\frenchspacing open?}. 

Calling \texttt{\frenchspacing active?} on a coroutine will return \texttt{\frenchspacing true} if the coroutine's body is currently running, and \texttt{\frenchspacing false} otherwise. Only active coroutines can be suspended or broken from.

Calling \texttt{\frenchspacing open?} on a coroutine will return \texttt{\frenchspacing true} if the coroutine's body is not currently running and open to be resumed. Only open coroutines can be resumed.


\subsection*{Nested Coroutines}
A coroutine may also launch more coroutines. Notice that unlike \texttt{\frenchspacing yield}, the calls to \texttt{\frenchspacing suspend}, \texttt{\frenchspacing break}, and \texttt{\frenchspacing resume} explicitly requires, as its first argument, the target coroutine. Being able to explicitly designate the target of the \texttt{\frenchspacing suspend}, \texttt{\frenchspacing break}, and \texttt{\frenchspacing resume} operations are key to allowing nested coroutines to work properly.

Consider the following code, where the coroutine, \texttt{\frenchspacing co1}, launches a second coroutine, \texttt{\frenchspacing co2}, within its body. Then within \texttt{\frenchspacing co2}'s body, there are \texttt{\frenchspacing suspend} and \texttt{\frenchspacing break} calls on both \texttt{\frenchspacing co1} and \texttt{\frenchspacing co2}. Pay attention to how this interacts.
\begin{lstlisting}
val co1 = Coroutine<False,Int> $ fn (co1, x0) :
   val co2 = Coroutine<False,False> $ fn (co2, y0) :
      for i in 0 to false do :
         suspend(co1, i)
         if i == 5 :
            println("Breaking from coroutine 2!")
            break(co2, false)
   resume(co2, false)
   -1

while open?(co1) :
   println(resume(co1, false))
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
0
1
2
3
4
5
Breaking from coroutine 2!
-1
\end{lstlisting}

The two nested coroutines are quite confusing. To get a better sense of what's happening, let's rewrite the second coroutine using the special case \texttt{\frenchspacing label} construct.
\begin{lstlisting}
val co1 = Coroutine<False,Int> $ fn (co1, x0) :
   label<False> break :
      for i in 0 to false do :
         suspend(co1, i)
         if i == 5 :
            println("Breaking from coroutine 2!")
            break(false)
   -1

while open?(co1) :
   println(resume(co1, false))
\end{lstlisting}
Compiling and running the above prints out the same message as before.

It is highly unlikely that you will feel the desire to directly launch new coroutines from within other coroutines, as we did here. But this example shows that they nest appropriately and generally {\em do the right thing}. Thus, for whatever abstractions you build on top of Stanza's targetable coroutine system, you can rest assured that they will recurse and compose correctly. 

\section{Example: Key Listener}
The following example demonstrates using coroutines to easily implement a key listener that translates individual key presses into events on strings.

Let us define a \texttt{\frenchspacing KeyListener} type, and its fundamental operation.
\begin{lstlisting}
deftype KeyListener
defmulti key-pressed (c:Char) -> False
\end{lstlisting}
A \texttt{\frenchspacing KeyListener} object listens to individual key presses from a keyboard and translates them into higher level events. Here is the definition of the constructor function for a \texttt{\frenchspacing KeyListener}.
\begin{lstlisting}
defn KeyListener (entered: String -> False) -> KeyListener
\end{lstlisting}
\texttt{\frenchspacing KeyListener} takes a callback function called \texttt{\frenchspacing entered} that accepts \texttt{\frenchspacing String} objects. Our \texttt{\frenchspacing KeyListener} translates key presses into calls to \texttt{\frenchspacing entered} on space-separated words. It also supports deleting characters with the backspace key, entering of double-quoted strings, and escaped double-quotes within a double-quoted string. Here is specifically what it has to do.
\begin{enumerate}
\item A \texttt{\frenchspacing KeyListener} has an internal buffer for storing characters. When keys corresponding to letters are pressed, they are stored into the internal buffer.
\item When the backspace key is pressed, the last character is deleted from the internal buffer.
\item Once a full word is completed (indicated by the spacebar being pressed), the \texttt{\frenchspacing entered} function should be called with the contents of the internal buffer.
\item If the double quote key is pressed, then this indicates that a string is being started, and all subsequent characters until the next double quote should be stored in the internal buffer. Upon completion of the string, the \texttt{\frenchspacing entered} function should be called with the entire contents of the internal buffer.
\item During entering of a string, if a backslash character followed by a double quote character is entered, then the double quote character is stored in the internal buffer, and entering of the string continues. If the backslash character is not followed by a double quote then both characters are ignored.
\end{enumerate}

\subsection*{Coroutine Framework}
Here is the basic framework that we will use to ease programming the \texttt{\frenchspacing KeyListener}.
\begin{lstlisting}
defn KeyListener (entered: String -> False) -> KeyListener :
   val co = Coroutine<Char,False> $ fn (co, c0) :
      ;Retrieve the next character
      defn next-char () :
         suspend(co, false)

      ...

   new KeyListener :
      defmethod key-pressed (this, c:Char) :
         resume(co, c)
\end{lstlisting}
We immediately create a coroutine that accepts characters and sends back dummy values of type \texttt{\frenchspacing False}. Within the coroutine body, the helper function \texttt{\frenchspacing next-char} requests the next character by suspending the coroutine and returning the next character sent back into the coroutine. A new \texttt{\frenchspacing KeyListener} object is returned that calls \texttt{\frenchspacing resume} on the coroutine whenever a key is pressed.

\subsection*{Buffer Managing Routines}
The following definitions within the coroutine body help us manage the \texttt{\frenchspacing KeyListener}'s internal buffer.
\begin{lstlisting}
;Buffer commands
val buffer = Vector<Char>()
defn pop-char () :
   if not empty?(buffer) :
      pop(buffer)
defn add-char (c:Char) :
   add(buffer, c)
defn empty-buffer () :
   entered(string-join(buffer))
   clear(buffer)
\end{lstlisting}
The buffer is represented as a vector of characters. \texttt{\frenchspacing pop-char} removes the last character in the buffer if possible. \texttt{\frenchspacing add-char} adds the given character to the end of the buffer. \texttt{\frenchspacing empty-buffer} calls the \texttt{\frenchspacing entered} callback with the contents of the buffer, and then clears the buffer.

\subsection*{Dispatch Mode}
The key press parser operates in a number of different modes. The default mode is the dispatch mode, which determines which mode to next enter based on the previously pressed key. 
\begin{lstlisting}
;Dispatch mode
defn* parse (c:Char) :
   if letter?(c) :
      parse-word(c)
   else if c == '\"' :
      parse-string(next-char())
   else :
      parse(next-char())
\end{lstlisting}
If a letter key was pressed, then we start parsing a word event. If the double-quote key is pressed, then we start parsing a string event. Otherwise, the key press is ignored.

\subsection*{Word Mode}
The word parsing mode accepts key presses until one word is completed.
\begin{lstlisting}
;Word parsing mode
defn* parse-word (c:Char) :
   if letter?(c) :
      add-char(c)
      parse-word(next-char())
   else if c == '\b' :
      pop-char()
      parse-word(next-char())
   else if (c == ' ') or (c == '\"') :
      empty-buffer()
      parse(c)
   else :
      parse-word(next-char())
\end{lstlisting}
If the last key pressed was a letter, then that letter is added to the buffer. If the last key was a backspace, then we delete a character from the buffer. If the last key was the spacebar or the double-quote key, then the word is completed. We empty the buffer and then go back to the dispatch mode. All other keys are ignored.

\subsection*{String Mode}
The string parsing mode accepts key presses until another (un-escaped) double-quote key finishes the string.
\begin{lstlisting}
;String parsing mode
defn* parse-string (c:Char) :
   if c == '\"' :
      empty-buffer()
      parse(next-char())
   else if c == '\b' :
      pop-char()
      parse-string(next-char())
   else if c == '\\' :
      if next-char() == '\"' : add-char('\"')
      parse-string(next-char())
   else :
      add-char(c)
      parse-string(next-char())
\end{lstlisting}
If the last key pressed was the double-quote key then the string is completed. We empty the buffer and then go back to the dispatch mode. If the last key was a backspace, then we delete a character from the buffer. If the last key was the backslash key, then we add a double-quote to the buffer if the following key is a double-quote. Otherwise both keys are ignored. Finally, all other characters are added to the buffer.

\subsection*{Testing the KeyListener}
Here is the entire \texttt{\frenchspacing KeyListener} constructor function.
\begin{lstlisting}
defn KeyListener (entered: String -> False) -> KeyListener :
   val co = Coroutine<Char,False> $ fn (co, c0) :
      ;Retrieve the next character
      defn next-char () :
         suspend(co, false)
         
      ;Buffer commands
      val buffer = Vector<Char>()
      defn pop-char () :
         if not empty?(buffer) :
            pop(buffer)
      defn add-char (c:Char) :
         add(buffer, c)
      defn empty-buffer () :
         entered(string-join(buffer))
         clear(buffer)

      ;Dispatch mode
      defn* parse (c:Char) :
         if letter?(c) :
            parse-word(c)
         else if c == '\"' :
            parse-string(next-char())
         else :
            parse(next-char())

      ;Word parsing mode
      defn* parse-word (c:Char) :
         if letter?(c) :
            add-char(c)
            parse-word(next-char())
         else if c == '\b' :
            pop-char()
            parse-word(next-char())
         else if (c == ' ') or (c == '\"') :
            empty-buffer()
            parse(c)
         else :
            parse-word(next-char())

      ;String parsing mode
      defn* parse-string (c:Char) :
         if c == '\"' :
            empty-buffer()
            parse(next-char())
         else if c == '\b' :
            pop-char()
            parse-string(next-char())
         else if c == '\\' :
            if next-char() == '\"' : add-char('\"')
            parse-string(next-char())
         else :
            add-char(c)
            parse-string(next-char())
            
      ;Launch!
      parse(c0)

   new KeyListener :
      defmethod key-pressed (this, c:Char) :
         resume(co, c)
\end{lstlisting}

Let's try it out on some simulated key presses.
\begin{lstlisting}
defn keys-pressed (kl:KeyListener, cs:Seqable<Char>) :
   do(key-pressed{kl, _}, cs)

defn main () :
   val kl = KeyListener $ fn (s) :
      println("String entered: %_" % [s])
      
   ;Test backspace   
   keys-pressed(kl, "Timom\bn ")
   
   ;Test simple word
   keys-pressed(kl, "and ")

   ;Test backspace against empty buffer
   keys-pressed(kl, "P\b\b\b\bPumbaa")
   
   ;Test unrecognized characters
   keys-pressed(kl, " a#$!re")
   
   ;Test strings with escaped quotes
   keys-pressed(kl, \<S>"\"good\" friends!!"<S>)

main()
\end{lstlisting}

Note that 
\begin{lstlisting}
\<S>literal !@#$%\|" characters<S>
\end{lstlisting}
is Stanza's syntax for a literal un-escaped string. All characters between the starting \texttt{\frenchspacing <S>} tag and the ending \texttt{\frenchspacing <S>} tag are part of the string. Any tag may be used in place of \texttt{\frenchspacing S}.

Compiling and running the above prints out
\begin{lstlisting}
String entered: Timon
String entered: and
String entered: Pumbaa
String entered: are
String entered: "good" friends!!
\end{lstlisting}

Our \texttt{\frenchspacing KeyListener} calls the callback function at the correct times and with the correct input! 

The coroutine mechanism allowed us to keep the code fairly straightforward and modular, even though the logic behind the \texttt{\frenchspacing KeyListener} itself is actually quite sophisticated. As an exercise, you may try to implement an equivalent \texttt{\frenchspacing KeyListener} function {\em without} using the coroutine mechanism to fully appreciate how tedious and error-prone it is.

\chapter{Stanza's Type System}
Types are the basis for how Stanza decides whether expressions are legal or not, and how to select the appropriate version of an overloaded function. This chapter will explain the different kinds of types in Stanza, what values each type represents, and the subtype relation.

\section{Kinds of Types}
There are only a handful of basic kinds of types in Stanza. Here is a listing of them all.
\begin{enumerate}
\item Ground Types (e.g. \texttt{\frenchspacing Int}, \texttt{\frenchspacing String}, \texttt{\frenchspacing True})
\item Parametric Types (e.g. \texttt{\frenchspacing Array<Int>}, \texttt{\frenchspacing List<String>})
\item Tuple Types (e.g. \texttt{\frenchspacing [Int]}, \texttt{\frenchspacing [Int, String]}, \texttt{\frenchspacing [Int, True, String]})
\item Function Types (e.g. \texttt{\frenchspacing Int -> String}, \texttt{\frenchspacing (Int, Int) -> Int})
\item Union Types (e.g. \texttt{\frenchspacing Int|String}, \texttt{\frenchspacing True|False}, \texttt{\frenchspacing Circle|Rectangle|Point})
\item Intersection Types (e.g. \texttt{\frenchspacing Collection<Int>\&Lengthable})
\item Void Type (\texttt{\frenchspacing Void})
\item Unknown Type (\texttt{\frenchspacing ?})
\end{enumerate}

Each kind of type will be described in detail in this chapter. The only type that has not been introduced yet is the void type. Most importantly, we'll cover the {\em subtyping} rules for each kind of type, which are the rules that Stanza uses to determine whether a program is legal.

\section{The Subtype Relation}
Stanza's type system is built upon the {\em subtyping} relation. The most important operation on types is determining whether one type is a {\em subtype} of another.  We use the following notation
\begin{lstlisting}
A <: B
\end{lstlisting}
to indicate that the type \texttt{\frenchspacing A} is a subtype of the type \texttt{\frenchspacing B}. Intuitively, what this means is that Stanza will allow you to pass a value of type \texttt{\frenchspacing A} to any place that is expecting a value of type \texttt{\frenchspacing B}.

In previous chapters, we have demonstrated examples using the types
\begin{lstlisting}
deftype Shape
deftype Circle <: Shape
\end{lstlisting}
According to these definitions, the \texttt{\frenchspacing Circle} type is a subtype of \texttt{\frenchspacing Shape}.
\begin{lstlisting}
Circle <: Shape
\end{lstlisting}
This means that we may pass a \texttt{\frenchspacing Circle} to any place that is expecting a \texttt{\frenchspacing Shape}. For example, we can call functions that accept \texttt{\frenchspacing Shape} arguments with \texttt{\frenchspacing Circle} objects. We can initialize values and variables of type \texttt{\frenchspacing Shape} with \texttt{\frenchspacing Circle} objects. And we can return \texttt{\frenchspacing Circle} objects from functions annotated to return \texttt{\frenchspacing Shape} objects.

Whether one type is a subtype of another is calculated from a set of {\em subtyping rules}. There is a small set for handling each kind of type, and we'll introduce them to you gradually.

\section{Ground Types}
Ground types are the most basic types in Stanza and are simply types that don't take any type parameters. The majority of types used in daily programming are simple ground types. \texttt{\frenchspacing Int}, \texttt{\frenchspacing String}, \texttt{\frenchspacing True}, \texttt{\frenchspacing False}, and \texttt{\frenchspacing Char} are a few examples of ground types that you've used.

\subsection*{Reflexivity Rule}
There are two subtyping rules for ground types. The first is that a ground type is a subtype of itself.
\begin{lstlisting}
T <: T
\end{lstlisting}
This rule is almost trivial. For example, here are some relations derivable from this rule.
\begin{lstlisting}
Int <: Int
String <: String
True <: True
\end{lstlisting}
meaning that you can call a function that accepts \texttt{\frenchspacing String} with an \texttt{\frenchspacing String} object.

\subsection*{Parent Rule}
Users may define their own ground types using \texttt{\frenchspacing deftype}. For example, here is the type declaration for \texttt{\frenchspacing Circle} again.
\begin{lstlisting}
deftype Circle <: Shape
\end{lstlisting}

The general form for \texttt{\frenchspacing deftype} is
\begin{lstlisting}
deftype T <: P
\end{lstlisting}

Here is the second subtyping rule for ground types. The type \texttt{\frenchspacing T} is a subtype of \texttt{\frenchspacing X} if it can be proven that its parent type \texttt{\frenchspacing P} is a subtype of \texttt{\frenchspacing X}.
\begin{lstlisting}
Assuming deftype T <: P
T <: X if P <: X
\end{lstlisting}

Thus we can derive
\begin{lstlisting}
Circle <: Shape
\end{lstlisting}
from
\begin{lstlisting}
Assuming deftype Circle <: Shape
Circle <: Shape because Shape <: Shape
\end{lstlisting}

This rule is what allows us to pass \texttt{\frenchspacing Circle} objects to functions that accept \texttt{\frenchspacing Shape} objects.

\section{Parametric Types}
Parametric types are types that take one or more {\em type parameters}. \texttt{\frenchspacing Array<Int>}, \texttt{\frenchspacing List<String>}, and our own type, \texttt{\frenchspacing Stack<String>}, are examples of parametric types.

\subsection*{Covariance Rule}
First consider the case where a base type, \texttt{\frenchspacing A}, takes only a single type parameter. This rule says that a parametric type \texttt{\frenchspacing A<T>} is a subtype of another parametric type \texttt{\frenchspacing A<S>} if it can be proven that its type parameter, \texttt{\frenchspacing T}, is a subtype of the other's type parameter, \texttt{\frenchspacing S}.
\begin{lstlisting}
A<T> <: A<S> if T <: S
\end{lstlisting}

In general, for arbitrary numbers of type parameters, the parametric type \texttt{\frenchspacing A<T1,T2, ..., Tn>} is a subtype of another parametric type \texttt{\frenchspacing A<S1, S2, ..., Sn>} if its type parameters, \texttt{\frenchspacing T1}, \texttt{\frenchspacing T2}, ..., \texttt{\frenchspacing Tn} are respectively subtypes of the other's type parameters, \texttt{\frenchspacing S1}, \texttt{\frenchspacing S2}, ..., \texttt{\frenchspacing Sn}.
\begin{lstlisting}
A<T1, T2, ..., Tn> <: A<S1, S2, ..., Sn> if
   T1 <: S1 and
   T2 <: S2 and
   ...
   Tn <: Sn
\end{lstlisting}

For example, we can derive
\begin{lstlisting}
List<Circle> <: List<Shape>
\end{lstlisting}
from
\begin{lstlisting}
List<Circle> <: List<Shape> because
   Circle <: Shape
\end{lstlisting}
This rule is what allows us to pass a list of circles to a function expecting a list of shapes.

\subsection*{Parent Rule}
Consider again the simple case where a base type, \texttt{\frenchspacing A}, takes a single type parameter. Assume that \texttt{\frenchspacing A} is defined the following way.
\begin{lstlisting}
deftype A<S> <: P
\end{lstlisting}
The parent rule for parametric types says that the parametric type \texttt{\frenchspacing A<T>} is a subtype of \texttt{\frenchspacing X} if it can be proven that the result of replacing every occurrence of \texttt{\frenchspacing S} in \texttt{\frenchspacing P} with \texttt{\frenchspacing T} is a subtype of \texttt{\frenchspacing X}.
\begin{lstlisting}
Assuming deftype A<S> <: P
A<T> <: X if P[S := T] <: X
\end{lstlisting}
where the notation \texttt{\frenchspacing P[S := T]} stands for the result of replacing every occurrence of \texttt{\frenchspacing S} in \texttt{\frenchspacing P} with \texttt{\frenchspacing T}.

Our parametric \texttt{\frenchspacing Stack} type, for example, is declared
\begin{lstlisting}
deftype Stack<T> <: Collection<T>
\end{lstlisting}
We can derive
\begin{lstlisting}
Stack<Circle> <: Collection<Shape>
\end{lstlisting}
from
\begin{lstlisting}
Stack<Circle> <: Collection<Shape> because
   Collection<Circle> <: Collection<Shape> because
      Circle <: Shape
\end{lstlisting}

Here is the general form of the rule for arbitrary numbers of type parameters.
\begin{lstlisting}
Assuming deftype A<S1, S2, ..., Sn> <: P
A<T1, T2, ..., Tn> <: X if
   P[S1 := T1, S2 := T2, ..., Sn := Tn] <: X
\end{lstlisting}
It says that the parametric type \texttt{\frenchspacing A<T1, T2, ..., Tn>} is a subtype of \texttt{\frenchspacing X} if it can be proven that the result of replacing every occurrence of \texttt{\frenchspacing S1}, \texttt{\frenchspacing S2}, ..., \texttt{\frenchspacing Sn} in \texttt{\frenchspacing P} respectively with \texttt{\frenchspacing T1}, \texttt{\frenchspacing T2}, ..., \texttt{\frenchspacing Tn} is a subtype of \texttt{\frenchspacing X}.

\section{Tuple Types}
Tuple types are used for representing the types of tuple objects. They're special in that they take a {\em variable} number of type parameters. Here is an example of a tuple type. The type
\begin{lstlisting}
[Int, String]
\end{lstlisting}
represents a two-element tuple, where the first element is an \texttt{\frenchspacing Int} and the second element is a \texttt{\frenchspacing String}.

\subsection*{Covariance Rule}
This rule says that the tuple type \texttt{\frenchspacing [T1, T2, ..., Tn]} is a subtype of the tuple type \texttt{\frenchspacing [S1, S2, ..., Sn]} if the types of the elements \texttt{\frenchspacing T1}, \texttt{\frenchspacing T2}, ..., \texttt{\frenchspacing Tn} are respectively subtypes of the types of the other's elements \texttt{\frenchspacing S1}, \texttt{\frenchspacing S2}, ..., \texttt{\frenchspacing Sn}.
\begin{lstlisting}
[T1, T2, ..., Tn] <: [S1, S2, ..., Sn] if
   T1 <: S1 and
   T2 <: S2 and
   ...
   Tn <: Sn
\end{lstlisting}
For example, we can derive
\begin{lstlisting}
[Circle, Rectangle] <: [Shape, Shape]
\end{lstlisting}
from
\begin{lstlisting}
[Circle, Rectangle] <: [Shape, Shape] because
   Circle <: Shape and
   Rectangle <: Shape
\end{lstlisting}

\subsection*{Collapsed Tuple Rule}
The type \texttt{\frenchspacing Tuple} is used to represent a tuple of {\em unknown} arity. This rule allows us to pass tuples with known arity to places expecting tuples with unknown arity.
\begin{lstlisting}
[T1, T2, ..., Tn] <: X if Tuple<T1|T2|...|Tn> <: X
\end{lstlisting}
It says that a tuple of known arity containing elements of type \texttt{\frenchspacing T1}, \texttt{\frenchspacing T2}, ..., \texttt{\frenchspacing Tn} is a subtype of \texttt{\frenchspacing X} if it can be proven that the tuple of unknown arity \texttt{\frenchspacing Tuple<T1|T2|...|Tn>} is a subtype of \texttt{\frenchspacing X}.

The type \texttt{\frenchspacing Tuple<T>} is defined to be a subtype of \texttt{\frenchspacing Collection<T>} in the core library, so this rule is what allows us to pass in tuples to functions that expect collections. For example, we can derive
\begin{lstlisting}
[Int, Int, Int] <: Collection<Int>
\end{lstlisting}
from
\begin{lstlisting}
[Int, Int, Int] <: Collection<Int> because
   Tuple<Int|Int|Int> <: Collection<Int> because
      Int|Int|Int <: Int
\end{lstlisting}

\section{Function Types}
Function types are used to represent the type of function objects. We've used them in the previous chapters to write functions that accept other functions as arguments.

Let us first consider just functions that take a single argument.
\begin{lstlisting}
T1 -> S1 <: T2 -> S2 if
   S1 <: S2 and
   T2 <: T1
\end{lstlisting}
The rule says that a function type \texttt{\frenchspacing T1 -> S1} is a subtype of another function type \texttt{\frenchspacing T2 -> S2} if it can be proven that the return type of the first, \texttt{\frenchspacing S1}, is a subtype of the return type of the second, \texttt{\frenchspacing S2}, and if the argument type of the second, \texttt{\frenchspacing T2}, is a subtype of the argument type of the first, \texttt{\frenchspacing T1}.

\subsection*{Covariance}
This rule is a little confusing at first, so let's go it carefully. First, the following relation
\begin{lstlisting}
Int -> Circle <: Int -> Shape
\end{lstlisting}
can be derived from
\begin{lstlisting}
Int -> Circle <: Int -> Shape because
   Circle <: Shape and
   Int <: Int
\end{lstlisting}
Suppose we are calling a function, \texttt{\frenchspacing f}, that requires a function argument. What this rule means is that if \texttt{\frenchspacing f} requires its argument to return \texttt{\frenchspacing Shape} objects, then we are allowed to pass it a function that returns \texttt{\frenchspacing Circle} objects. This makes sense as all circles are shapes. So assuming that \texttt{\frenchspacing f} calls its argument function, then whatever \texttt{\frenchspacing f} will do with the resultant \texttt{\frenchspacing Shape} objects, \texttt{\frenchspacing f} can also do with \texttt{\frenchspacing Circle} objects.

\subsection*{Contravariance}
Next, the following relation
\begin{lstlisting}
Shape -> Int <: Circle -> Int
\end{lstlisting}
can be derived from
\begin{lstlisting}
Shape -> Int <: Circle -> Int because
   Int <: Int and
   Circle <: Shape
\end{lstlisting}
Suppose we are again calling a function, \texttt{\frenchspacing f}, that requires a function argument. What this rule means is that if \texttt{\frenchspacing f} requires its argument to accept \texttt{\frenchspacing Circle} objects, then we are allowed to pass it a function that accepts \texttt{\frenchspacing Shape} objects. This makes sense as all functions that can accept \texttt{\frenchspacing Shape} objects, can also accept \texttt{\frenchspacing Circle} objects.

The general rule for function types results from the combination of functions being {\em covariant} in its return type and \texttt{\frenchspacing contravariant} in its argument types.

\subsection*{General Form}
Here is the general form of the function subtyping rule for arbitrary numbers of arguments.
\begin{lstlisting}
(T1, T2, ..., Tn) -> R1 <: (S1, S2, ..., Sn) -> R2 if
   R1 <: R2 and
   S1 <: T1 and
   S2 <: T2 and
   ...
   Sn <: Tn
\end{lstlisting}
Thus a function type \texttt{\frenchspacing (T1, T2, ..., Tn) -> R1} is a subtype of another function type \texttt{\frenchspacing (S1, S2, ..., Sn) -> R2} if it can be proven that the return type of the first, \texttt{\frenchspacing R1}, is a subtype of the return type of the second, \texttt{\frenchspacing R2}, and the argument types of the second, \texttt{\frenchspacing S1}, \texttt{\frenchspacing S2}, ..., \texttt{\frenchspacing Sn}, are respectively subtypes of the argument types of the first, \texttt{\frenchspacing T1}, \texttt{\frenchspacing T2}, ..., \texttt{\frenchspacing Tn}.

\section{Union Types}
Union types are used to represent a value who could either be of one type or another. The type \texttt{\frenchspacing Int|String}, for example, represents a value that could either be an \texttt{\frenchspacing Int} or a \texttt{\frenchspacing String}.

\subsection*{Expecting a Union Type}
The following rule says that a type, \texttt{\frenchspacing X}, is a subtype of a union type, \texttt{\frenchspacing A|B}, if it can be proven that \texttt{\frenchspacing X} is either a subtype of \texttt{\frenchspacing A} or a subtype of \texttt{\frenchspacing B}.
\begin{lstlisting}
X <: A|B if X <: A or X <: B
\end{lstlisting}

For example, we can derive
\begin{lstlisting}
Int <: Int|String
\end{lstlisting}
from
\begin{lstlisting}
Int <: Int|String because Int <: Int
\end{lstlisting}

This rule allows us to write functions that accept a variety of types, and be allowed to pass it a specific one.

\subsection*{Passing a Union Type}
The following rule says that a union type, \texttt{\frenchspacing A|B}, is a subtype of \texttt{\frenchspacing X}, if it can be proven that both \texttt{\frenchspacing A} is a subtype of \texttt{\frenchspacing X} and \texttt{\frenchspacing B} is a subtype of \texttt{\frenchspacing X}.
\begin{lstlisting}
A|B <: X if A <: X and B <: X
\end{lstlisting}

For example, we can derive
\begin{lstlisting}
Circle|Rectangle|Point <: Shape
\end{lstlisting}
from
\begin{lstlisting}
Circle | (Rectangle|Point) <: Shape because
   Circle <: Shape and
   Rectangle|Point <: Shape because
      Rectangle <: Shape and
      Point <: Shape
\end{lstlisting}

This rule is what causes Stanza to error if you attempt to pass a \texttt{\frenchspacing Int|String} object to a function that requires an \texttt{\frenchspacing Int} object.

\section{Intersection Types}
Intersection types are the dual of union types, and are used to indicate that a value is both of one type and also of another. The type \texttt{\frenchspacing Collection<Int> \& Lengthable}, for example, represents an object that is simultaneously both a collection of integers and also a \texttt{\frenchspacing Lengthable} object.

\subsection*{Expecting an Intersection Type}
The following rule says that a type, \texttt{\frenchspacing X}, is a subtype of an intersection type, \texttt{\frenchspacing A\&B}, if it can be proven that \texttt{\frenchspacing X} is both a subtype of \texttt{\frenchspacing A} and also a subtype of \texttt{\frenchspacing B}.
\begin{lstlisting}
X <: A&B if X <: A and X <: B
\end{lstlisting}

For example, we can derive
\begin{lstlisting}
Stack<Int> <: Collection<Int> & Lengthable
\end{lstlisting}
from
\begin{lstlisting}
Stack<Int> <: Collection<Int> & Lengthable because
   Stack<Int> <: Collection<Int> and
   Stack<Int> <: Lengthable
\end{lstlisting}

\subsection*{Passing an Intersection Type}
The following rule says that an intersection type \texttt{\frenchspacing A\&B} is a subtype of \texttt{\frenchspacing X} if it can be proven that either \texttt{\frenchspacing A} is a subtype of \texttt{\frenchspacing X} or \texttt{\frenchspacing B} is a subtype of \texttt{\frenchspacing X}.
\begin{lstlisting}
A&B <: X if A <: X or B <: X
\end{lstlisting}

For example, we can derive
\begin{lstlisting}
Stack<Int> <: Lengthable
\end{lstlisting}
from
\begin{lstlisting}
Stack<Int> <: Lengthable because
   Collection<Int> & Lengthable <: Lengthable because
      Lengthable <: Lengthable
\end{lstlisting}

\section{The Void Type}
The void type is a special type in Stanza that represents {\em no value}.

It is used, for example, as the return type of the \texttt{\frenchspacing fatal} function, which simply prints an error message and then immediately quits the program. \texttt{\frenchspacing fatal} never returns, so it's inappropriate to say that it returns {\em any} type. \texttt{\frenchspacing throw} is another function that returns \texttt{\frenchspacing Void}, as it also never returns to its caller.

It is occasionally also used as a type parameter for collection types. For example, the following call
\begin{lstlisting}
val xs = List()
\end{lstlisting}
creates an object of type \texttt{\frenchspacing List<Void>} and assigns it to \texttt{\frenchspacing xs}. Recall that calling \texttt{\frenchspacing head} on a value of type \texttt{\frenchspacing List<T>} returns \texttt{\frenchspacing T}. Similarly, calling \texttt{\frenchspacing head} on a value of type \texttt{\frenchspacing List<Void>} returns \texttt{\frenchspacing Void}, indicating that such a call would not return.

The only subtyping rule for \texttt{\frenchspacing Void} is that it is a subtype of any type, \texttt{\frenchspacing T}.
\begin{lstlisting}
Void <: T
\end{lstlisting}

For programmers familiar with the \texttt{\frenchspacing void} type in the C and Java programming language, note that this is not the same concept. A C function that returns \texttt{\frenchspacing void} still returns. It simply returns a meaningless value, so you're forbidden from using it for anything. In contrast, a Stanza function that returns \texttt{\frenchspacing Void} {\em does not return}.

\section{The Unknown Type}
The unknown type is a very important type and forms the basis of Stanza's optional typing system. There are two subtyping rules that defines its behaviour.

 \subsection*{Expecting an Unknown Type}
 The following rule says that {\em any} type, \texttt{\frenchspacing T}, is a subtype of \texttt{\frenchspacing ?}.
\begin{lstlisting}
T <: ?
\end{lstlisting}

When we declare a function that accepts arguments of type \texttt{\frenchspacing ?}, it is this rule that allows us to pass any object to the function.

\subsection*{Passing an Unknown Type}
The following rule says that the unknown type, \texttt{\frenchspacing ?}, is a subtype of {\em any} type, \texttt{\frenchspacing T}.
\begin{lstlisting}
? <: T
\end{lstlisting}

Given a value or argument declared with the \texttt{\frenchspacing ?} type, it is this rule that allows us to pass this value anywhere, regardless of what type is actually expected.

These two rules together allows Stanza to model the behaviour of dynamically-typed scripting languages in a principled manner. The behaviour of the Python programming language, for example, can be mimicked by declaring every argument and value as having the unknown type.

\chapter{Calling Foreign Functions}

One of the most important features that a practical programming language must support is the ability to call functions written in other languages. There are too many useful libraries written in the established languages to consider rewriting them in another programming language. Stanza provides support for calling any function using the calling convention for the C programming language. This means that you can use any library written in C, or that provides a C interface, in Stanza. Since the dominant consumer operating systems today use a C calling convention, this means that the vast majority of libraries can be called from Stanza. This chapter will show you how.

\section{Writing a C Function}

Here is a fibonacci function written in C. Create a \texttt{\frenchspacing fibonacci.c} file with the following contents.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>

int generate_fib (int n) {
   int a = 0;
   int b = 1;
   while(n > 0){
      printf("%d\n", b);
      int c = a + b;
      a = b;
      b = c;
      n = n - 1;
   }
   return 0;
}

int main (int nargs, char** argvs) {
   generate_fib(10);
   return 0;
}
\end{lstlisting} 

Compile and run the above program by typing
\begin{lstlisting}
cc fibonacci.c -o fibonacci
./fibonacci
\end{lstlisting}
in the terminal. It should print out
\begin{lstlisting}
1
1
2
3
5
8
13
21
34
55
\end{lstlisting}

In the next step, we will call the \texttt{\frenchspacing generate\_fib} function from Stanza.

\section{Calling our C Function}
The first step is just to remove the \texttt{\frenchspacing main} function in \texttt{\frenchspacing fibonacci.c} since the program is now being initialized and driven by Stanza.

Next create a file named \texttt{\frenchspacing fib.stanza} with the following contents.
\begin{lstlisting}
defpackage fib :
   import core
   import collections

extern generate_fib: int -> int

lostanza defn call-fib () -> ref<False> :
   call-c generate_fib(10)
   return false

println("Calling fibonacci")
call-fib()
println("Done calling fibonacci")
\end{lstlisting}

To compile both the \texttt{\frenchspacing fib.stanza} and \texttt{\frenchspacing fibonacci.c} files together, and run the program, type the following into the terminal.
\begin{lstlisting}
stanza fib.stanza -ccfiles fibonacci.c -o fib
./fib
\end{lstlisting}
It should print out
\begin{lstlisting}
Calling fibonacci
1
1
2
3
5
8
13
21
34
55
Done calling fibonacci
\end{lstlisting}

Thus our Stanza program successfully calls and returns from the \texttt{\frenchspacing generate\_fib} function written in C. Let's go through the program step by step.

\subsection*{Declaring an External Function}
The line 
\begin{lstlisting}
extern generate_fib: int -> int
\end{lstlisting}
declares that there is a function defined externally called \texttt{\frenchspacing generate\_fib} that takes a single integer argument and returns a single integer argument.

Notice that \texttt{\frenchspacing int} is not capitalized. This is important. \texttt{\frenchspacing int} refers to the {\em LoStanza} integer type, and is different from the {\em Stanza} type \texttt{\frenchspacing Int}. We'll go over what this means later. 

Let us suppose that \texttt{\frenchspacing generate\_fib} took two arguments instead of one. Make the following change to the \texttt{\frenchspacing generate\_fib} function, where it now accepts an argument, \texttt{\frenchspacing b0}, to indicate the initial value of \texttt{\frenchspacing b}.
\begin{lstlisting}
int generate_fib (int b0, int n) {
   int a = 0;
   int b = b0;
   ...
}   
\end{lstlisting}

Then the \texttt{\frenchspacing extern} statement, and the call to \texttt{\frenchspacing generate\_fib} would have to be updated accordingly.
\begin{lstlisting}
extern generate_fib: (int, int) -> int

lostanza defn call-fib () -> ref<False> :
   call-c generate_fib(2, 10)
   return false
\end{lstlisting}
Compiling and running the new program now prints out
\begin{lstlisting}
Calling fibonacci
2
2
4
6
10
16
26
42
68
110
Done calling fibonacci
\end{lstlisting}

\subsection*{Declaring a LoStanza Function}
LoStanza is a small sub-language within Stanza that allows users to precisely specify data layouts and perform low-level hardware operations. LoStanza can be used for writing high performance code, communicating with external peripherals, and implementing system level functions. Stanza's garbage collector, for example, is written in LoStanza. In this chapter, we are using it to interface with externally defined functions. 

The line
\begin{lstlisting}
lostanza defn call-fib () -> ref<False>
\end{lstlisting}
declares a LoStanza function called \texttt{\frenchspacing call-fib}. Its return type, \texttt{\frenchspacing ref<False>}, indicates that it returns a reference to the Stanza type, \texttt{\frenchspacing False}. 

The line
\begin{lstlisting}
call-c generate_fib(10)
\end{lstlisting}
calls the \texttt{\frenchspacing generate\_fib} function with the argument \texttt{\frenchspacing 10}. The \texttt{\frenchspacing call-c} tells Stanza to call \texttt{\frenchspacing generate\_fib} with the {\em C calling convention}. By default, Stanza uses the {\em Stanza calling convention} to call other functions, and if you forget the \texttt{\frenchspacing call-c} it will seriously confuse \texttt{\frenchspacing generate\_fib} and crash the program. 

Finally, the line
\begin{lstlisting}
return false
\end{lstlisting}
simply returns \texttt{\frenchspacing false} to whomever called \texttt{\frenchspacing call-fib}.

\subsection*{C Functions that Return void}
When a C function is declared to return a value of type \texttt{\frenchspacing void}, it means that the function is called for its side effects only, and returns an arbitrary value. Let's change \texttt{\frenchspacing generate\_fib} to return \texttt{\frenchspacing void}.
\begin{lstlisting}
void generate_fib (int b0, int n) {
   int a = 0;
   int b = b0;
   while(n > 0){
      int c = a + b;
      printf("%d\n", c);
      a = b;
      b = c;
      n = n - 1;
   }
}
\end{lstlisting}

Stanza does not provide any explicit support for modeling arbitrary values, so the \texttt{\frenchspacing extern} statement would remain as
\begin{lstlisting}
extern generate_fib: (int, int) -> int
\end{lstlisting}
and, as the programmer, you would have to remember (or document) that \texttt{\frenchspacing generate\_fib} returns some random integer that should not be used.

\section{Calling LoStanza from Stanza}
The arguments to \texttt{\frenchspacing generate\_fib} are currently hardcoded into the \texttt{\frenchspacing call-fib} function. Let's change that to allow both \texttt{\frenchspacing b0} and \texttt{\frenchspacing n} to be passed as arguments to \texttt{\frenchspacing call-fib}.
\begin{lstlisting}
extern generate_fib: (int, int) -> int

lostanza defn call-fib (b0:int, n:int) -> ref<False> :
   call-c generate_fib(b0, n)
   return false
\end{lstlisting}
And our test code will now call \texttt{\frenchspacing call-fib} with different arguments.
\begin{lstlisting}
println("Calling fibonacci(1, 10)")
call-fib(1, 10)
println("Calling fibonacci(2, 10)")
call-fib(2, 10)
println("Done calling fibonacci")
\end{lstlisting}

However, attempting to compile the above gives us the following error.
\begin{lstlisting}
LoStanza function call-fib of type (int, int) -> ref<False> 
can only be referred to from LoStanza.
\end{lstlisting}
As mentioned, \texttt{\frenchspacing int} is a {\em LoStanza} type, and you're not allowed to call it directly from Stanza with {\em Stanza} objects.

\subsection*{Convert Stanza Objects to LoStanza Values}
The type \texttt{\frenchspacing Int} is declared like this.
\begin{lstlisting}
lostanza deftype Int :
   value: int
\end{lstlisting}
We will explain what that means in more detail later, but for now, notice that it contains a field called \texttt{\frenchspacing value} that is of type \texttt{\frenchspacing int}. Thus, we will modify our \texttt{\frenchspacing call-fib} function to accept references to \texttt{\frenchspacing Int} objects, and then pass their \texttt{\frenchspacing value} fields to \texttt{\frenchspacing generate\_fib}.
\begin{lstlisting}
lostanza defn call-fib (b0:ref<Int>, n:ref<Int>) -> ref<False> :
   call-c generate_fib(b0.value, n.value)
   return false
\end{lstlisting}

With this change, the program now compiles correctly, and prints out
\begin{lstlisting}
Calling fibonacci(1, 10)
1
1
2
3
5
8
13
21
34
55
Calling fibonacci(2, 10)
2
2
4
6
10
16
26
42
68
110
Done calling fibonacci
\end{lstlisting}

A LoStanza function can be called from Stanza if and only if all of its argument types and return type are \texttt{\frenchspacing ref<T>}, indicating that it accepts and returns a reference to a Stanza object. LoStanza functions that can be suitably called from Stanza are indistinguishable from regular Stanza functions. So in addition to being called directly, they can also be passed as arguments, and stored in datastructures.

\subsection*{Convert LoStanza Values to Stanza Objects}
Let us now change \texttt{\frenchspacing generate\_fib} to return the \texttt{\frenchspacing n}'th fibonacci number, instead of printing all of them. 
\begin{lstlisting}
int generate_fib (int b0, int n) {
   int a = 0;
   int b = b0;
   while(n > 0){
      int c = a + b;
      a = b;
      b = c;
      n = n - 1;
   }
   return b;
}
\end{lstlisting}

We'll also update our \texttt{\frenchspacing call-fib} function to return the result of \texttt{\frenchspacing generate\_fib}.
\begin{lstlisting}
lostanza defn call-fib (b0:ref<Int>, n:ref<Int>) -> int :
   val result = call-c generate_fib(b0.value, n.value)
   return result
\end{lstlisting}

Here's the updated test code that prints out the result of calling \texttt{\frenchspacing call-fib}.
\begin{lstlisting}
println("fibonacci(1, 10) =")
println(call-fib(1, 10))
println("fibonacci(2, 10) =")
println(call-fib(2, 10))
println("Done calling fibonacci")
\end{lstlisting}

However, attempting to compile the above gives us this familiar error.
\begin{lstlisting}
LoStanza function call-fib of type (ref<Int>, ref<Int>) -> int 
can only be referred to from LoStanza.
\end{lstlisting}

As mentioned already, a LoStanza function can be called from Stanza if and only if all of its argument types {\em and return type} are \texttt{\frenchspacing ref<T>}. We learned how to convert Stanza \texttt{\frenchspacing Int} objects into LoStanza \texttt{\frenchspacing int} values in the previous section. Now we'll learn how to convert LoStanza \texttt{\frenchspacing int} values back into Stanza \texttt{\frenchspacing Int} objects.

To create a Stanza \texttt{\frenchspacing Int} object, we use the LoStanza \texttt{\frenchspacing new} operator.
\begin{lstlisting}
lostanza defn call-fib (b0:ref<Int>, n:ref<Int>) -> ref<Int> :
   val result = call-c generate_fib(b0.value, n.value)
   return new Int{result}
\end{lstlisting}

Our test code now compiles and runs, and prints out
\begin{lstlisting}
fibonacci(1, 10) =
89
fibonacci(2, 10) =
178
Done calling fibonacci
\end{lstlisting}

Note that the LoStanza \texttt{\frenchspacing new} operator is completely different than the Stanza \texttt{\frenchspacing new} operator. It is best to consider LoStanza as a completely separate language from Stanza. It has its own syntax, operators, and behaviour. The thing that makes LoStanza unique is that there is a well-defined and flexible interface between it and Stanza.

\section{LoStanza Types}
There are a handful of additional LoStanza types in addition to the \texttt{\frenchspacing int} type that we used in the declaration of the \texttt{\frenchspacing generate\_fib} function. 

\subsection*{Primitive Types}
Here is a listing of the rest of the LoStanza primitive types, along with an example of their values.
\begin{lstlisting}
val x:byte = 42Y
val x:int = 42
val x:long = 42L
val x:float = 42.0f
val x:double = 42.0
\end{lstlisting}

A \texttt{\frenchspacing byte} is an 8-bit unsigned integer. An \texttt{\frenchspacing int} is a 32-bit signed integer. A \texttt{\frenchspacing long} is a 64-bit signed integer. A \texttt{\frenchspacing float} is a 32-bit single precision floating point number. And a \texttt{\frenchspacing double} is a 64-bit double precision floating point number.

The above primitive types have an associated Stanza type, each declared to contain a single \texttt{\frenchspacing value} field containing the LoStanza representation of its value. The associated Stanza types for \texttt{\frenchspacing byte}, \texttt{\frenchspacing int}, \texttt{\frenchspacing long}, \texttt{\frenchspacing float}, and \texttt{\frenchspacing double}, are \texttt{\frenchspacing Byte}, \texttt{\frenchspacing Int}, \texttt{\frenchspacing Long}, \texttt{\frenchspacing Float}, and \texttt{\frenchspacing Double}, respectively. In addition to \texttt{\frenchspacing Byte}, the Stanza type \texttt{\frenchspacing Char} is also declared to contain a single \texttt{\frenchspacing value} field of type \texttt{\frenchspacing byte}.

As an example, let us write a version of \texttt{\frenchspacing generate\_fib} that works on double precision floating point numbers.
\begin{lstlisting}
double generate_fib_d (double b0, int n) {
   double a = 0.0;
   double b = b0;
   while(n > 0){
      double c = a + b;
      a = b;
      b = c;
      n = n - 1;
   }
   return b;
}
\end{lstlisting}

Here is the LoStanza code needed to be able to call \texttt{\frenchspacing generate\_fib\_d} from Stanza.
\begin{lstlisting}
extern generate_fib_d: (double, int) -> double

lostanza defn call-fib (b0:ref<Double>, n:ref<Int>) -> ref<Double> :
   val result = call-c generate_fib_d(b0.value, n.value)
   return new Double{result}
\end{lstlisting}

Now armed with double precision floating point, let's calculate the 100'th fibonacci number.
\begin{lstlisting}
println("fibonacci(1.0, 100) = ")
println(call-fib(1.0, 100))
println("fibonacci(2.0, 100) = ")
println(call-fib(2.0, 100))
println("Done calling fibonacci")
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
fibonacci(1.0, 100) = 
573147844013817200640.000000000000000
fibonacci(2.0, 100) = 
1146295688027634401280.000000000000000
Done calling fibonacci
\end{lstlisting}

Notice that the \texttt{\frenchspacing call-fib} function is overloaded to accept both \texttt{\frenchspacing Int} and \texttt{\frenchspacing Double} arguments. LoStanza functions have all the same features as Stanza functions, and this includes their ability to be overloaded.

\subsection*{Pointer Types}
Pointers are represented in LoStanza with the \texttt{\frenchspacing ptr<t>} type. The little \texttt{\frenchspacing t} represents any LoStanza type. For example, here is the type representing a pointer to an \texttt{\frenchspacing int},
\begin{lstlisting}
ptr<int>
\end{lstlisting}
and here is the type representing a {\em pointer to} a pointer to an \texttt{\frenchspacing int},
\begin{lstlisting}
ptr<ptr<int>>
\end{lstlisting}

The type
\begin{lstlisting}
ptr<?>
\end{lstlisting}
represents a generic pointer to anything.

As an example of their use, let's call the C \texttt{\frenchspacing malloc} and \texttt{\frenchspacing free} functions to allocate and delete space for three integers.
\begin{lstlisting}
extern malloc: long -> ptr<?>
extern free: ptr<?> -> int

lostanza defn try-pointers () -> ref<False> :
   val ints:ptr<int> = call-c malloc(3 * sizeof(int))
   call-c free(ints)
   return false
\end{lstlisting}

The \texttt{\frenchspacing []} operator in LoStanza is the dereference operator and retrieves the value stored at the given pointer address. Here is an example of storing and retrieving values into and from the \texttt{\frenchspacing ints} pointer.
\begin{lstlisting}
lostanza defn try-pointers () -> ref<False> :
   val ints:ptr<int> = call-c malloc(3 * sizeof(int))
   [ints] = 42
   [ints + 4] = 43
   [ints + 8] = 44
   val x = [ints]
   val y = [ints + 4]
   val z = [ints + 8]
   call-c free(ints)
   return false
\end{lstlisting}
Programmers familiar with C should note that arithmetic on pointers {\em do not} automatically operate in terms of the size of the pointer's data type. To retrieve the \texttt{\frenchspacing i}'th element from a pointer, assuming that its elements are stored contiguously, we use the following syntax.
\begin{lstlisting}
lostanza defn try-pointers () -> ref<False> :
   val ints:ptr<int> = call-c malloc(3 * sizeof(int))
   ints[0] = 42
   ints[1] = 43
   ints[2] = 44
   val x = ints[0]
   val y = ints[1]
   val z = ints[2]
   call-c free(ints)
   return false
\end{lstlisting}
This is equivalent to the previous example.

\subsection*{Declaring a LoStanza Type}
Consider the following definition of the C type \texttt{\frenchspacing Point3D} and function \texttt{\frenchspacing get\_origin}.
\begin{lstlisting}
typedef struct {
   float x;
   float y;
   float z;
} Point3D;

Point3D* get_origin () {
  Point3D* p = (Point3D*)malloc(sizeof(Point3D));
  p->x = 0.0f;
  p->y = 0.0f;
  p->z = 0.0f;
  return p;
}
\end{lstlisting}
\texttt{\frenchspacing Point3D} is a struct that contains three \texttt{\frenchspacing float} fields, and \texttt{\frenchspacing get\_origin} returns a pointer to a \texttt{\frenchspacing Point3D}. 

Here is how we would declare our own LoStanza type to mirror the C type definition.
\begin{lstlisting}
lostanza deftype Point3D :
   x: float
   y: float
   z: float
\end{lstlisting}

Here's a function that demonstrates calling \texttt{\frenchspacing get\_origin} and returning the \texttt{\frenchspacing x} field in the returned point.
\begin{lstlisting}
extern get_origin: () -> ptr<Point3D>

lostanza defn origin-x () -> ref<Float> :
   val p = call-c get_origin()
   return new Float{p.x}
\end{lstlisting}

Here's some code to test the \texttt{\frenchspacing origin-x} function.
\begin{lstlisting}
println("The x coordinate of the origin is %_." % [origin-x()])
\end{lstlisting}
which prints out
\begin{lstlisting}
The x coordinate of the origin is 0.000000.
\end{lstlisting}

\subsection*{Reference Types}
A reference to a Stanza object is represented with the \texttt{\frenchspacing ref<T>} type. The big \texttt{\frenchspacing T} represents any Stanza type. We've already used the \texttt{\frenchspacing ref<Int>}, and \texttt{\frenchspacing ref<Float>} types in our examples. 

Our previous function \texttt{\frenchspacing origin-x} returned the \texttt{\frenchspacing x} coordinate of the origin. But we would really like to just return the entire point to Stanza. Similar to how we converted \texttt{\frenchspacing int} values to \texttt{\frenchspacing Int} objects, this is done using the \texttt{\frenchspacing new} operator.
\begin{lstlisting}
lostanza defn origin () -> ref<Point3D> :
   val p = call-c get_origin()
   return new Point3D{p.x, p.y, p.z}
\end{lstlisting}

And here are the LoStanza getter functions for a \texttt{\frenchspacing Point3D} that allows Stanza to retrieve the coordinates within it.
\begin{lstlisting}
lostanza defn x (p:ref<Point3D>) -> ref<Float> :
   return new Float{p.x}
lostanza defn y (p:ref<Point3D>) -> ref<Float> :
   return new Float{p.y}
lostanza defn z (p:ref<Point3D>) -> ref<Float> :
   return new Float{p.z}
\end{lstlisting}

Here's some code to test our new \texttt{\frenchspacing origin} function.
\begin{lstlisting}
val p = origin()
println("The x coordinate of the origin is %_." % [x(p)])
println("The y coordinate of the origin is %_." % [y(p)])
println("The z coordinate of the origin is %_." % [z(p)])
\end{lstlisting}

Compiling and running the above code prints out
\begin{lstlisting}
The x coordinate of the origin is 0.000000.
The y coordinate of the origin is 0.000000.
The z coordinate of the origin is 0.000000.
\end{lstlisting}

As one last example, let's write, in LoStanza, a constructor function for \texttt{\frenchspacing Point3D} objects that can be called from Stanza.
\begin{lstlisting}
lostanza defn Point3D (x:ref<Float>, y:ref<Float>, z:ref<Float>) -> ref<Point3D> :
   return new Point3D{x.value, y.value, z.value}
\end{lstlisting}

Here's some test code for trying out our constructor function.
\begin{lstlisting}
val p2 = Point3D(1.0f, 3.4f, 4.2f)
println("The x coordinate of p2 is %_." % [x(p2)])
println("The y coordinate of p2 is %_." % [y(p2)])
println("The z coordinate of p2 is %_." % [z(p2)])
\end{lstlisting}
which, when compiled and ran, prints out
\begin{lstlisting}
The x coordinate of p2 is 1.000000.
The y coordinate of p2 is 3.400000.
The z coordinate of p2 is 4.200000.
\end{lstlisting}

With these definitions, \texttt{\frenchspacing Point3D} becomes a type that we can freely manipulate from Stanza. We can create \texttt{\frenchspacing Point3D} objects, and we can retrieve its fields.  

\subsection*{Literal Strings}
A literal string in LoStanza has type \texttt{\frenchspacing ptr<byte>} and refers to a pointer to a memory location where the ascii byte representation of its characters are stored. 

For example, the following snippet will retrieve the ascii byte value of the character \texttt{\frenchspacing 'o'} and store it in the value \texttt{\frenchspacing c}.
\begin{lstlisting}
val str:ptr<byte> = "Hello"
val c:byte = str[4]
\end{lstlisting}

The characters are also stored with a terminating zero byte after all the characters. This allows the literal strings to be suitably used with external libraries expecting C language strings.

\subsection*{External Unknown Arity Functions}
Neither LoStanza nor Stanza supports the definition of functions that take an unknown number of arguments. But there are external libraries containing such functions. The C \texttt{\frenchspacing printf} function is the most famous one.

The \texttt{\frenchspacing printf} function would be declared like this.
\begin{lstlisting}
extern printf: (ptr<byte>, ? ...) -> int
\end{lstlisting}

Here is an example of calling it from a function called \texttt{\frenchspacing test}.
\begin{lstlisting}
lostanza defn test () -> ref<False> :
   call-c printf("The friendship between %s and %s is valued at over %d.\n",
                 "Timon", "Pumbaa", 9000)
   return false

test()
\end{lstlisting}

Compiling and running the above prints out
\begin{lstlisting}
The friendship between Timon and Pumbaa is valued at over 9000.
\end{lstlisting}

\section{External Global Variables}
Let us suppose that \texttt{\frenchspacing generate\_fib} was written differently. Suppose that it does not accept any arguments, and also returns \texttt{\frenchspacing void}. Instead it will retrieve its argument from a global variable named \texttt{\frenchspacing FIB\_PARAM}, and store the result in \texttt{\frenchspacing FIB\_PARAM} when finished. 

\begin{lstlisting}
int FIB_PARAM;

void generate_fib (void) {
   int a = 0;
   int b = 1;
   while(FIB_PARAM > 0){
      int c = a + b;
      a = b;
      b = c;
      FIB_PARAM = FIB_PARAM - 1;
   }
   FIB_PARAM = b;
}
\end{lstlisting}

To call the new \texttt{\frenchspacing generate\_fib}, our LoStanza \texttt{\frenchspacing call-fib} function would need to be able to read and write to the \texttt{\frenchspacing FIB\_PARAM} variable. Here's how to do that.
\begin{lstlisting}
extern FIB_PARAM : int
extern generate_fib : () -> int

lostanza defn call-fib (n:ref<Int>) -> ref<Int> :
   FIB_PARAM = n.value
   call-c generate_fib()
   return new Int{FIB_PARAM}

println("fib(10) = %_" % [call-fib(10)])
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
fib(10) = 89
\end{lstlisting}

\section{Function Pointers}
Certain C libraries tend to make heavy use of function pointers for implementing callbacks or parameterized behaviour. Let us suppose there is a C function called \texttt{\frenchspacing choose\_greeting} that when given an integer argument returns one of several possible greeting functions to return. These greeting functions then accept a C string and print out an appropriate message.
\begin{lstlisting}
void standard_greeting (char* name) {
  printf("Hello %s!\n", name);
}

void chill_greeting (char* name) {
  printf("'Sup %s.\n", name);
}

void excited_greeting (char* name) {
  printf("%c", name[0]);
  for(int i=0; i<5; i++)
    printf("%c", name[1]);
  printf("%s! Heyyyy!\n", name+2);    
}

typedef void (*Greeting)(char* name);
Greeting choose_greeting (int option) {
  switch(option){
  case 1: return &chill_greeting;
  case 2: return &excited_greeting;
  default: return &standard_greeting;
  }
}
\end{lstlisting}

The \texttt{\frenchspacing extern} declaration for \texttt{\frenchspacing choose\_greeting} would look like this.
\begin{lstlisting}
extern choose_greeting: int -> ptr<(ptr<byte> -> int)>
\end{lstlisting}
Here's how to decipher that piece by piece. The returned greeting functions all have type
\begin{lstlisting}
ptr<byte> -> int
\end{lstlisting}
The \texttt{\frenchspacing choose\_greeting} function returns a {\em pointer} to a greeting function. So the return type of \texttt{\frenchspacing choose\_greeting} is
\begin{lstlisting}
ptr<(ptr<byte> -> int)>
\end{lstlisting}
And \texttt{\frenchspacing choose\_greeting}, itself, requires an integer argument. Thus the full type for \texttt{\frenchspacing choose\_greeting} is
\begin{lstlisting}
int -> ptr<(ptr<byte> -> int)>
\end{lstlisting}

Here is the LoStanza \texttt{\frenchspacing greet} function which takes an integer argument called \texttt{\frenchspacing option} and greets Patrick appropriately.
\begin{lstlisting}
lostanza defn greet (option:ref<Int>) -> ref<False> :
   val greet = call-c choose_greeting(option.value)
   call-c [greet]("Patrick")
   return false
\end{lstlisting}
Notice that the value \texttt{\frenchspacing greet} has type \texttt{\frenchspacing ptr<(ptr<byte> -> int)>}, and thus it needs to be first dereferenced before it can be called.
\begin{lstlisting}
call-c [greet]("Patrick")
\end{lstlisting}

Let's try it out!
\begin{lstlisting}
println("Option 0")
greet(0)

println("\nOption 1")
greet(1)

println("\nOption 2")
greet(2)
\end{lstlisting}
Compiling and running the above prints out
\begin{lstlisting}
Option 0
Hello Patrick!

Option 1
'Sup Patrick.

Option 2
Paaaaatrick! Heyyyy!
\end{lstlisting}

\section{The Address Operator}
The \texttt{\frenchspacing greet} function in the previous example accepts an integer argument to select the type of greeting, but it only ever greets Patrick. Let's generalize \texttt{\frenchspacing greet} to accept whom to greet as well.

We want \texttt{\frenchspacing greet} to be callable from Stanza, so the name will be passed in as a \texttt{\frenchspacing String} object.
\begin{lstlisting}
lostanza defn greet (option:ref<Int>, name:ref<String>) -> ref<False> :
   ...
\end{lstlisting}

But the \texttt{\frenchspacing greet} function requires a \texttt{\frenchspacing ptr<byte>} as its argument, and \texttt{\frenchspacing name} is a \texttt{\frenchspacing ref<String>}. How do we get access to a pointer to the string's characters?

The \texttt{\frenchspacing String} type is declared in the core library as
\begin{lstlisting}
lostanza deftype String :
   length: long
   hash: int
   chars: byte ...
\end{lstlisting}
The ellipsis following the \texttt{\frenchspacing byte} indicates that the \texttt{\frenchspacing String} object ends with a variable number of trailing \texttt{\frenchspacing byte} values. We need a pointer to those values to call \texttt{\frenchspacing greet} with. To do that we will use the \texttt{\frenchspacing addr} operator, which will return the pointer address of a location.

Let's now write our \texttt{\frenchspacing greet} function with the \texttt{\frenchspacing addr} operator.
\begin{lstlisting}
lostanza defn greet (option:ref<Int>, name:ref<String>) -> ref<False> :
   val greet = call-c choose_greeting(option.value)
   call-c [greet](addr(name.chars))
   return false
\end{lstlisting}

And update our test code to pass in a different name for each type of greeting.
\begin{lstlisting}
println("Option 0")
greet(0, "Emmy")

println("\nOption 1")
greet(1, "Patrick")

println("\nOption 2")
greet(2, "Luca")
\end{lstlisting}

Attempting to compile the above, however, gives us this error.
\begin{lstlisting}
Cannot retrieve address of unstable location using addr operator.
\end{lstlisting}
What does that mean?

\subsection*{Stable and Unstable Locations}
Underneath the hood, Stanza uses a precise {\em relocating} garbage collector. What this means is that objects are constantly being shuffled around in memory during the garbage collection process. An unstable location is a location whose address is not fixed, such as a field in a Stanza object. In contrast, a stable location is one whose address is fixed, such as a piece of memory allocated using \texttt{\frenchspacing malloc}.

The error above is saying that we cannot use the \texttt{\frenchspacing addr} operator to retrieve the address of \texttt{\frenchspacing name.chars}, which is an unstable location. \texttt{\frenchspacing name} is a Stanza string and will be relocated whenever the garbage collector runs, and so the address of \texttt{\frenchspacing name.chars} is constantly changing. 

However, we are planning to pass the address of \texttt{\frenchspacing name.chars} to C and then {\em immediately} start executing C code. Additionally, the C function is guaranteed not to hang onto the pointer after it returns. Thus, in this particular case, we know that Stanza's garbage collector will never have a chance to run, and it {\em is} safe to retrieve the pointer of \texttt{\frenchspacing name.chars}.

To {\em force} Stanza to give you the address of an unstable location, Stanza provides you the \texttt{\frenchspacing addr!} operator. So let's update our \texttt{\frenchspacing greet} function by using the \texttt{\frenchspacing addr!} operator this time,
\begin{lstlisting}
lostanza defn greet (option:ref<Int>, name:ref<String>) -> ref<False> :
   val greet = call-c choose_greeting(option.value)
   call-c [greet](addr!(name.chars))
   return false
\end{lstlisting}
and try compiling and running the program again. The program now prints out
\begin{lstlisting}
Option 0
Hello Emmy!

Option 1
'Sup Patrick.

Option 2
Luuuuuca! Heyyyy!
\end{lstlisting}

You should stick to using the \texttt{\frenchspacing addr} operator whenever you can, and use the \texttt{\frenchspacing addr!} operator only when you're {\em very} sure that the object won't be relocated while you're using the pointer.

\section{Calling LoStanza from C}
So far we've only considered calling C functions from Stanza, but what if you wanted to call a Stanza function from C? Stanza supports both directions of calling and this section will explain how.

Let us reconsider the \texttt{\frenchspacing generate\_fib} function again. This time, we will have \texttt{\frenchspacing generate\_fib} call a Stanza function for each number that is generated. Here is the code for \texttt{\frenchspacing generate\_fib}.
\begin{lstlisting}
#include<stdio.h>
#include<stdlib.h>

void number_generated (int x);

void generate_fib (int n) {
   int a = 0;
   int b = 1;
   while(n > 0){
      number_generated(b);
      int c = a + b;
      a = b;
      b = c;
      n = n - 1;
   }
}
\end{lstlisting}
Notice that we assume the existence of a function called \texttt{\frenchspacing number\_generated} that we can call from C.

C will call \texttt{\frenchspacing number\_generated} using the C calling convention, so we need to be able to define a LoStanza function that is expecting to be called with the C calling convention. The \texttt{\frenchspacing extern} keyword will allow us to do that. Our \texttt{\frenchspacing number\_generated} function will push the generated number to a global vector called \texttt{\frenchspacing FIB\_NUMBERS}.
\begin{lstlisting}
val FIB_NUMBERS = Vector<Int>()

extern defn number_generated (n:int) -> int :
   add(FIB_NUMBERS, new Int{n})
   return 0
\end{lstlisting}

The implementation of the \texttt{\frenchspacing call-fib} function remains as it was before.
\begin{lstlisting}
extern generate_fib: int -> int

lostanza defn call-fib (n:ref<Int>) -> ref<False> :
   call-c generate_fib(n.value)
   return false
\end{lstlisting}

Let's try it out then! Here's our test code.
\begin{lstlisting}
call-fib(20)
println("Generated Numbers: %_" % [FIB_NUMBERS])
\end{lstlisting}

Compiling and running the above prints out
\begin{lstlisting}
Generated Numbers: [1 1 2 3 5 8 13 21 34 55 89 144 233
                    377 610 987 1597 2584 4181 6765]
\end{lstlisting}

\section{Passing Callbacks to C}
In the last section, we showed you how to write a LoStanza function that can be called with C. However, C libraries are not typically architected to directly call a named user function. Instead, the user will pass the library a pointer to a callback function that is then later called by the library. 

Let's change our \texttt{\frenchspacing generate\_fib} function so that it no longer directly calls the \texttt{\frenchspacing number\_generated} function. It will accept instead, as an argument, a pointer to a callback function which it will call. 
\begin{lstlisting}
void generate_fib (int n, void (*number_generated)(int x)) {
   int a = 0;
   int b = 1;
   while(n > 0){
      number_generated(b);
      int c = a + b;
      a = b;
      b = c;
      n = n - 1;
   }
}
\end{lstlisting} 

We shall keep the LoStanza definition of \texttt{\frenchspacing number\_generated} the same, but we will need to change the declaration of the \texttt{\frenchspacing generate\_fib} function, and also pass a pointer to \texttt{\frenchspacing number\_generated} to the call to \texttt{\frenchspacing generate\_fib}.
\begin{lstlisting}
extern generate_fib: (int, ptr<(int -> int)>) -> int

lostanza defn call-fib (n:ref<Int>) -> ref<False> :
   call-c generate_fib(n.value, addr(number_generated))
   return false
\end{lstlisting}
Notice the use of the standard \texttt{\frenchspacing addr} operator for retrieving the address of the \texttt{\frenchspacing number\_generated} function.

Compiling and running the above prints out
\begin{lstlisting}
Generated Numbers: [1 1 2 3 5 8 13 21 34 55 89 144 233
                    377 610 987 1597 2584 4181 6765]
\end{lstlisting}

Let's take this time to review everything that this example demonstrates.
\begin{enumerate}
\item Stanza is calling \texttt{\frenchspacing call-fib}, which is a function written in LoStanza.
\item  \texttt{\frenchspacing call-fib} is calling \texttt{\frenchspacing generate\_fib}, which is a function written in C.
\item  \texttt{\frenchspacing generate\_fib} is passed a pointer to the \texttt{\frenchspacing number\_generated} function which is written in LoStanza.
\item  \texttt{\frenchspacing generate\_fib} runs and calls \texttt{\frenchspacing number\_generated} multiple times.
\item Each time \texttt{\frenchspacing number\_generated} is called, it creates a Stanza \texttt{\frenchspacing Int} object from the argument passed to it by \texttt{\frenchspacing generate\_fib}, and calls the Stanza function \texttt{\frenchspacing add} to push it onto a vector.
\end{enumerate}

This will likely be the most complicated usage of Stanza's foreign function interface you will come across, but it's nice to know that the flexibility is there when you need it.

\chapter{Appendix}
Stanza has a number of convenience constructs that make your life easier, but they are not necessary for day to day programming. You may skim through this appendix and learn about these constructs as their need arises.

\section{Stanza Compiler Options}
\subsection*{.stanza Configuration File}
Stanza's platform and compiler settings are stored in the \texttt{\frenchspacing .stanza} file that was created when you installed Stanza with \texttt{\frenchspacing stanza install}. When you run Stanza it will first look for an appropriate \texttt{\frenchspacing .stanza} file. Here are the places that Stanza searches in, in order, for the \texttt{\frenchspacing .stanza} file.
\begin{enumerate}
\item Stanza first looks in the current working directory.
\item If the \texttt{\frenchspacing STANZA\_CONFIG} environment variable is set, then Stanza looks in that directory.
\item If the \texttt{\frenchspacing HOME} environment variable is set, then Stanza looks in that directory.
\end{enumerate}

\subsection*{Basic Compilation}
To compile \texttt{\frenchspacing myfile.stanza} and generate the binary \texttt{\frenchspacing myprogram} use the following command.
\begin{lstlisting}
stanza myfile.stanza -o myprogram
\end{lstlisting}

\subsection*{Optimization}
To compile with optimizations, use the \texttt{\frenchspacing -optimize} flag. 
\begin{lstlisting}
stanza myfile.stanza -o myprogram -optimize
\end{lstlisting}

Be warned that Stanza's optimizer is only designed to handle {\em correct} programs. A {\em correct} program is defined to be a program that successfully runs to completion without ever failing with a call to \texttt{\frenchspacing fatal}. If an unoptimized program runs to completion and generates a result, then the optimized program is guaranteed to run to completion and generate the same result. However, if the unoptimized program fails, then the behaviour of the optimized program is undefined.

\subsection*{Generating Assembly Files}
By default, Stanza generates a temporary \texttt{\frenchspacing .asm} file containing the generated assembly instructions and then links it with GCC. To use a specific name for the \texttt{\frenchspacing .asm} file use the \texttt{\frenchspacing -s} flag.
\begin{lstlisting}
stanza myfile.stanza -s myprogram.s -o myprogram
\end{lstlisting}
The above command will generate the assembly file \texttt{\frenchspacing myprogram.s} and link it to produce the binary file \texttt{\frenchspacing myprogram}.

For expert users that only want the assembly file, the \texttt{\frenchspacing -o} flag may be omitted. The following command only generates the assembly file \texttt{\frenchspacing myprograms.s}.
\begin{lstlisting}
stanza myfile.stanza -s myprogram.s
\end{lstlisting}

\subsection*{Pkg Files}
Stanza's separate compilation system allows for packages to be compiled into \texttt{\frenchspacing .pkg} files. The following command compiles each package in \texttt{\frenchspacing myfile.stanza} to a separate \texttt{\frenchspacing .pkg} file.
\begin{lstlisting}
stanza myfile.stanza -pkg
\end{lstlisting}

By default, the resultant \texttt{\frenchspacing .pkg} files are generated in the current working directory. To specify the folder into which they should be generated, provide the path after the \texttt{\frenchspacing -pkg} flag. The following command puts the resultant \texttt{\frenchspacing .pkg} files in the \texttt{\frenchspacing mypkgs} folder.
\begin{lstlisting}
stanza myfile.stanza -pkg mypkgs
\end{lstlisting}

Note that the current compiler requires for source files containing mutually dependent packages to be compiled together. For example, if \texttt{\frenchspacing myfile1.stanza} contains 
\begin{lstlisting}
defpackage mypackage1 :
   import mypackage2
...   
\end{lstlisting}
and \texttt{\frenchspacing myfile2.stanza} contains
\begin{lstlisting}
defpackage mypackage2 :
   import mypackage1
...
\end{lstlisting}
then \texttt{\frenchspacing myfile1.stanza} and \texttt{\frenchspacing myfile2.stanza} must be compiled together with the following command.
\begin{lstlisting}
stanza myfile1.stanza myfile2.stanza -pkg
\end{lstlisting}

\subsection*{Automatic Pkg Loading}
When you compile a program, Stanza automatically looks for the \texttt{\frenchspacing .pkg} files containing the definitions of the packages that you import. Here is the order in which Stanza looks for appropriate \texttt{\frenchspacing .pkg} files.
\begin{enumerate}
\item If you've provided a path using the \texttt{\frenchspacing -pkg-path} flag, then Stanza will first look there for \texttt{\frenchspacing .pkg} files. For example, the following command compiles \texttt{\frenchspacing myfile.stanza} using the \texttt{\frenchspacing .pkg} files in the \texttt{\frenchspacing mypkgs} folder.
\begin{lstlisting}
stanza myfile.stanza -pkg-path mypkgs
\end{lstlisting}

\item If the \texttt{\frenchspacing -pkg-path} flag is not provided, then Stanza will first look in the current working directory for \texttt{\frenchspacing .pkg} files.

\item If the \texttt{\frenchspacing -optimize} flag is provided, then Stanza will look in the directories specified by the \texttt{\frenchspacing fast-pkg-dirs} option in your \texttt{\frenchspacing .stanza} configuration file. To add additional directories to the pkg path, add the following to your \texttt{\frenchspacing .stanza} file.
\begin{lstlisting}
fast-pkg-dirs = ("/path/to/myfastpkgs1" "/path/to/myfastpkgs2")
\end{lstlisting}

\item If the \texttt{\frenchspacing -optimize} flag is provided, then Stanza will look in the \texttt{\frenchspacing fast-pkgs} folder in your Stanza installation directory.

\item Stanza will then look in the directories specified by the \texttt{\frenchspacing pkg-dirs} option in your \texttt{\frenchspacing .stanza} configuration file. To add additional directories to the pkg path, add the following to your \texttt{\frenchspacing .stanza} file.
\begin{lstlisting}
pkg-dirs = ("/path/to/mypkgs1" "/path/to/mypkgs2")
\end{lstlisting}

\item Stanza will then look in the \texttt{\frenchspacing pkgs} folder in your Stanza installation directory.
\end{enumerate}

\subsection*{C Compiler Options}
Stanza provides the \texttt{\frenchspacing -ccfiles} flag to include additional files to the call to the C compiler. The following command compiles the \texttt{\frenchspacing myfile.stanza} program and links it against the functions contained in \texttt{\frenchspacing supportfunctions.c} to produce the \texttt{\frenchspacing myprogram} executable.
\begin{lstlisting}
stanza myfile.stanza -ccfiles supportfunctions.c -o myprogram
\end{lstlisting}

You may also use the \texttt{\frenchspacing -ccflags} flag to include additional flags to the C compiler. The following command compiles the \texttt{\frenchspacing myfile.stanza}  program and calls the C compiler with the additional \texttt{\frenchspacing -lmylib} flag to produce the \texttt{\frenchspacing myprogram} executable.
\begin{lstlisting}
stanza myfile.stanza -ccflags -lmylib -o myprogram
\end{lstlisting}

Note that to provide multiple flags to the C compiler, the flags must be quoted.
\begin{lstlisting}
stanza myfile.stanza -ccflags -lmylib1 -lmylib2 -o myprogram
\end{lstlisting}

\subsection*{Target Platform Settings}
By default, Stanza generates code appropriate for the platform that you specified in the call to \texttt{\frenchspacing stanza install}. If you wish to generate code appropriate for a different platform, then you can override the platform using the \texttt{\frenchspacing -platform} flag.

The following generates the assembly file \texttt{\frenchspacing myprogram.s} appropriate for the Windows platform.
\begin{lstlisting}
stanza myfile.stanza -s myprogram.s -platform windows
\end{lstlisting}

\section{The When Expression}
The \texttt{\frenchspacing when} expression provides a convenient syntax for very short if expressions. The following
\begin{lstlisting}
val name =
   if meerkat? : "Timon"
   else : "Pumbaa"
\end{lstlisting}
assigns the string "Timon" to \texttt{\frenchspacing name} if \texttt{\frenchspacing meerkat?} is \texttt{\frenchspacing true}, otherwise it assigns "Pumbaa". It can be equivalently written as
\begin{lstlisting}
val name = "Timon" when meerkat? else "Pumbaa"
\end{lstlisting}

In general, the form
\begin{lstlisting}
a when c else b
\end{lstlisting}
is equivalent to the if expression
\begin{lstlisting}
if c : a
else : b
\end{lstlisting}

\subsection*{Optional Else Branch}
You may also leave off the \texttt{\frenchspacing else} branch, in which case
\begin{lstlisting}
a when c
\end{lstlisting}
is equivalent to the if expression
\begin{lstlisting}
if c : a
\end{lstlisting}

This form is often convenient if you want to call a function only when some condition is \texttt{\frenchspacing true}.
\begin{lstlisting}
press(button) when action == "press"
\end{lstlisting}

The when expression is another example of a convenience construct implemented as a macro. 

\section{The Where Expression}
The \texttt{\frenchspacing where} expression provides a convenient syntax for pulling out short definitions from complicated expressions. The following code
\begin{lstlisting}
println("They call me Mr. %_" % [name]) where :
   val name = "Pig!" when angry? else "Pumbaa."
\end{lstlisting}
{\em first} defines \texttt{\frenchspacing name}, and then prints the message. It is equivalent to
\begin{lstlisting}
let :
   val name = "Pig!" when angry? else "Pumbaa."
   println("They call me Mr. %_" % [name])
\end{lstlisting}

The where expression is also implemented as a macro. As you can see, Stanza's core library makes heavy use of macros.

\section{The Switch Expression}
The \texttt{\frenchspacing switch} expression provides a convenient syntax for choosing amongst a number of nested \texttt{\frenchspacing if} branches. Here is an example of evaluating the first branch for which \texttt{\frenchspacing empty?} evaluates to \texttt{\frenchspacing true}.
\begin{lstlisting}
switch empty? :
   a : println("List a is empty.")
   b : println("List b is empty.")
   head(c) : println("The head of list c is empty.")
   else : println("Nothing is empty.")
\end{lstlisting}
The above is equivalent to these nested \texttt{\frenchspacing if} expressions.
\begin{lstlisting}
if empty?(a) :
   println("List a is empty.")
else if empty?(b) :
   println("List b is empty.")
else if empty?(head(c)) :
   println("The head of list c is empty.")
else :
   println("Nothing is empty.")
\end{lstlisting}
If the \texttt{\frenchspacing else} branch is omitted then a default \texttt{\frenchspacing else} branch is provided that prints an error and causes the program to fail. 

The \texttt{\frenchspacing switch} construct is commonly used with an anonymous function as its predicate. Here is an example of using \texttt{\frenchspacing switch} to evaluate different branches depending on the value of \texttt{\frenchspacing x}.
\begin{lstlisting}
switch {x == _} :
   0 : println("Sunday")
   1 : println("Monday")
   2 : println("Tuesday")
   3 : println("Wednesday")
   4 : println("Thursday")
   5 : println("Friday")
   6 : println("Saturday")
   else : println("Elseday")
\end{lstlisting}

\section{More on Visibility}
\subsection*{Package Qualified Identifiers}
Suppose our main program makes use of the following definitions from an \texttt{\frenchspacing animals} package.
\begin{lstlisting}
public defstruct Dog
public defstruct Cat
public name (x:Dog|Cat) -> String
public sound (x:Dog|Cat) -> String
\end{lstlisting}

{\em Package-qualified identifiers} allow us to reference those definitions without having to import the \texttt{\frenchspacing animals} package. Here is a \texttt{\frenchspacing main} function written using package-qualified identifiers and without importing \texttt{\frenchspacing animals}.
\begin{lstlisting}
defpackage animal-main :
   import core

defn main () :
   val d = animals/Dog("Shadow")
   val c = animals/Cat("Sassy")
   println("My dog %_ goes %_!" % [animals/name(d), animals/sound(d)])
   println("My cat %_ goes %_!" % [animals/name(c), animals/sound(c)])
\end{lstlisting}

In general, a package qualified identifier is any identifier that contains the \texttt{\frenchspacing '/'} character. The characters after the last occurrence of the \texttt{\frenchspacing '/'} form the name of the definition being referenced. The characters before the last occurrence form the name of the package containing the definition being referenced. For example, the following identifier
\begin{lstlisting}
stanza/compiler/type/FunctionType
\end{lstlisting}
refers to the \texttt{\frenchspacing FunctionType} definition in the \texttt{\frenchspacing stanza/compiler/type} package.

Package-qualified identifiers are mostly used by macro writers. Macros should expand into references to package-qualified identifiers to prevent users from having to explicitly import the runtime libraries that the macros depend upon.

\subsection*{Top Level Identifiers}
Identifiers whose only occurrence of the \texttt{\frenchspacing '/'} character is at the beginning of the identifier are called {\em top-level} identifiers. For example, \texttt{\frenchspacing /sound} and \texttt{\frenchspacing /name} are top-level identifiers. 

Top level identifiers are used to refer to a definition that is visible from the top most scope in the current package. It is used to refer to a top-level definition when its actual name has been shadowed by a local definition.

For example, the following
\begin{lstlisting}
defn main () :
   val s = "Hello"
   val length = 42
   println(length(s))
\end{lstlisting}
fails to compile with the error
\begin{lstlisting}
Value length of type Int cannot be called as a function.
\end{lstlisting}
This is because \texttt{\frenchspacing length} refers to the value \texttt{\frenchspacing 42}, {\em not} the function that returns the length of a string. We can get around this either by renaming the \texttt{\frenchspacing length} value to something else, or by using a top-level identifier to refer to the length function.
\begin{lstlisting}
defn main () :
   val s = "Hello"
   val length = 42
   println(/length(s))
\end{lstlisting}

\subsection*{Protected Visibility}
In addition to public and private visibilities, Stanza supports one last visibility setting: the protected visibility. A definition with protected visibility {\em can} be referred to from other packages, but they can {\em only} be referred to using package-qualified identifiers. 

Suppose we have an \texttt{\frenchspacing animals} package containing the following definitions.
\begin{lstlisting}
public defstruct Dog
public defstruct Cat
public name (x:Dog|Cat) -> String
protected sound (x:Dog|Cat) -> String
\end{lstlisting}

And we will import the \texttt{\frenchspacing animals} package into our \texttt{\frenchspacing animals-main} package.
\begin{lstlisting}
defpackage animals-main :
   import animals

defn main () :
   val d = Dog("Shadow")
   val c = Cat("Sassy")
   name(d)
   animals/sound(c)
\end{lstlisting}

All of the public definitions in \texttt{\frenchspacing animals} can be directly referred to in \texttt{\frenchspacing animals-main} after they have been imported, {\em but} the protected function \texttt{\frenchspacing sound} must be package-qualified. 

Protected definitions are most often used by macro writers. Often, a macro simply expands into a decorated call to a helper function. We want to encourage users to use the macro form, and {\em not} call the helper function directly. By annotating the macro with the protected visibility we make it unlikely for users to accidentally call the helper function. 
\end{document}
